{"0": {
    "doc": "InteliJ",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/InteliJ#color-utilities",
    
    "relUrl": "/docs/02_Tech/InteliJ#color-utilities"
  },"1": {
    "doc": "InteliJ",
    "title": "Table of contents",
    "content": ". ",
    "url": "/docs/02_Tech/InteliJ#table-of-contents",
    
    "relUrl": "/docs/02_Tech/InteliJ#table-of-contents"
  },"2": {
    "doc": "InteliJ",
    "title": "InteliJ",
    "content": " ",
    "url": "/docs/02_Tech/InteliJ",
    
    "relUrl": "/docs/02_Tech/InteliJ"
  },"3": {
    "doc": "5. API Gateway",
    "title": "API Gatewayy",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway#api-gatewayy",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#api-gatewayy"
  },"4": {
    "doc": "5. API Gateway",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. CloudShell 사용하기 | 2. CloudShell 에서의 Docker 지원 | 3. CloudShell을 사용하여 Docker 이미지 업로드 단계 | . ",
    "url": "/docs/02_Tech/AWS/APIGateway#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#목차"
  },"5": {
    "doc": "5. API Gateway",
    "title": "글을 쓴 배경",
    "content": "AWS CloudShell을 사용하여 Docker 이미지를 ECR Repository에 업로드하는 방법에 대해 설명합니다. Mac으로 docker 이미지를 가져올 때 Linux 운영체제와 호환 문제를 피하기 위해 고민한 내용을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/APIGateway#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#글을-쓴-배경"
  },"6": {
    "doc": "5. API Gateway",
    "title": "글 요약",
    "content": "CloudShell을 활용하여 Docker Hub에서 이미지를 가져와 ECR에 업로드하는 방법입니다. ",
    "url": "/docs/02_Tech/AWS/APIGateway#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#글-요약"
  },"7": {
    "doc": "5. API Gateway",
    "title": "시작하기 전",
    "content": "이 튜토리얼은 특히 Mac 사용자에게 유용하며, AWS ECR 및 Docker에대한 기본적인 지식이 있는 분을 대상으로 작성되었습니다. ",
    "url": "/docs/02_Tech/AWS/APIGateway#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#시작하기-전"
  },"8": {
    "doc": "5. API Gateway",
    "title": "1. CloudShell 사용하기",
    "content": "CloudShell은 AWS 콘솔에서 리소스에 직접 액세스할 수 있는 셸을 제공합니다. Bash, PowerShell, Z shell과 같은 다양한 셸을 지원하며, 추가 다운로드나 설치 없이 AWS CLI 명령을 실행할 수 있습니다. CloudShell을 시작하면 Amazon Linux 2023을 기반으로 하는 컴퓨팅 환경이 제공됩니다. CloudShell 사용 시작하기: Cloudshell 시작하기 . ",
    "url": "/docs/02_Tech/AWS/APIGateway#1-cloudshell-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#1-cloudshell-사용하기"
  },"9": {
    "doc": "5. API Gateway",
    "title": "2. CloudShell 에서의 Docker 지원",
    "content": "AWS CloudShell은 현재 13개 리전에서 Docker를 지원합니다. 자세히 알아보기: AWS CloudShell, 이제 13개 리전에서 Docker 지원 . ",
    "url": "/docs/02_Tech/AWS/APIGateway#2-cloudshell-%EC%97%90%EC%84%9C%EC%9D%98-docker-%EC%A7%80%EC%9B%90",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#2-cloudshell-에서의-docker-지원"
  },"10": {
    "doc": "5. API Gateway",
    "title": "3. CloudShell을 사용하여 Docker 이미지 업로드 단계",
    "content": "Docker 이미지 가져오기: 먼저 CloudShell 환경으로 dockerhub에서 nignx와 같은 sample Docker 이미지를 가져옵니다. ECR에 업로드: 이미지가 CloudShell에 있으면, ECR 저장소에 업로드합니다. ",
    "url": "/docs/02_Tech/AWS/APIGateway#3-cloudshell%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-docker-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%97%85%EB%A1%9C%EB%93%9C-%EB%8B%A8%EA%B3%84",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway#3-cloudshell을-사용하여-docker-이미지-업로드-단계"
  },"11": {
    "doc": "5. API Gateway",
    "title": "5. API Gateway",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway"
  },"12": {
    "doc": "AWS",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/AWS#color-utilities",
    
    "relUrl": "/docs/02_Tech/AWS#color-utilities"
  },"13": {
    "doc": "AWS",
    "title": "Table of contents",
    "content": ". | TOC | . ",
    "url": "/docs/02_Tech/AWS#table-of-contents",
    
    "relUrl": "/docs/02_Tech/AWS#table-of-contents"
  },"14": {
    "doc": "AWS",
    "title": "AWS",
    "content": " ",
    "url": "/docs/02_Tech/AWS",
    
    "relUrl": "/docs/02_Tech/AWS"
  },"15": {
    "doc": "AWS CloudScape Component",
    "title": "ECS 용량공급자",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#ecs-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#ecs-용량공급자"
  },"16": {
    "doc": "AWS CloudScape Component",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 용량공급자란 | 2. AWS ECS Cluster 에서 용량공급자 선택하기 | . # . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#목차"
  },"17": {
    "doc": "AWS CloudScape Component",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#%EB%AA%A9%EC%B0%A8-1",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#목차-1"
  },"18": {
    "doc": "AWS CloudScape Component",
    "title": "글을 쓴 배경",
    "content": "ECS 서비스를 이용해 sample application 도커 이미지를 배포하는 방법을 공유합니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#글을-쓴-배경"
  },"19": {
    "doc": "AWS CloudScape Component",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#글-요약"
  },"20": {
    "doc": "AWS CloudScape Component",
    "title": "시작하기 전",
    "content": "참고자료 AWS ECS Workshop . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#시작하기-전"
  },"21": {
    "doc": "AWS CloudScape Component",
    "title": "1. 용량공급자란",
    "content": "Amazon Elastic Container Registry(ECR)에 ECS에서 실행되는 애플리케이션 이미지를 저장 및 관리할 수 있습니다. ECS TaskDefinition에 Amazon ECR 리포지토리를 지정하기만 하면 Amazon ECS에서 지정된 이미지를 가져와 배포합니다. 우선, 배포할 이미지를 업로드 해줍니다. 저는 nginx container 이미지를 업로드해주었습니다. 참고자료 : Amazon ECR . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#1-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90%EB%9E%80",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#1-용량공급자란"
  },"22": {
    "doc": "AWS CloudScape Component",
    "title": "2. AWS ECS Cluster 에서 용량공급자 선택하기",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#2-aws-ecs-cluster-%EC%97%90%EC%84%9C-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape#2-aws-ecs-cluster-에서-용량공급자-선택하기"
  },"23": {
    "doc": "AWS CloudScape Component",
    "title": "AWS CloudScape Component",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/awscloudscape"
  },"24": {
    "doc": "3. Bamboo",
    "title": "Bamboo",
    "content": "Bamboo는 Atlassian에 의해 개발된 CI/CD 도구입니다. ",
    "url": "/docs/02_Tech/CICD/Bamboo#bamboo",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#bamboo"
  },"25": {
    "doc": "3. Bamboo",
    "title": "목차",
    "content": ". | Bamboo . | 글 요약 | 시작하기 전 | 1. Bamboo 로컬에 설치하기 . | 1.1 Bamboo 파일 다운로드 하기 | 1.2 Bamboo 홈 위치 지정 | . | 2. Bamboo 시작 | 3. Bamboo 체험판 라이센스 받기 | 4. Configure Bamboo . | 4.1 Configure instance | . | . | . ",
    "url": "/docs/02_Tech/CICD/Bamboo#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#목차"
  },"26": {
    "doc": "3. Bamboo",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Bamboo#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#글-요약"
  },"27": {
    "doc": "3. Bamboo",
    "title": "시작하기 전",
    "content": "Bamboo instance 구성정보 . | OS: 다른 Linux OS를 사용하셔도 무방합니다. 저는 Mac Local에서 진행했습니다. | JDK: amazon-corretto-17 | Bamboo: 9.6 | . Bamboo . 참고자료 : supported platforms . ",
    "url": "/docs/02_Tech/CICD/Bamboo#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#시작하기-전"
  },"28": {
    "doc": "3. Bamboo",
    "title": "1. Bamboo 로컬에 설치하기",
    "content": "참고자료 : Installing Bamboo on Mac OS X . 1.1 Bamboo 파일 다운로드 하기 . | download the file link | . tar.gz for MacOS or Linux distributions. 1.2 Bamboo 홈 위치 지정 . Bamboo 데이터가 저장될 홈 디렉토리를 지정합니다. 설치 파일내 bamboo-init.properties 파일 수정 . | &lt;Bamboo 설치 디렉토리&gt;/atlassian-bamboo/WEB-INF/classes/ 내의 bamboo-init.properties 파일 수정 필요 | bamboo.home 줄의 주석 해제후 아래와 같이 홈 디렉토리의 절대 경로를 제공합니다. | . ## You can specify your bamboo.home and bamboo.shared.home property here or in your system environment variables. #Local Bamboo home. If running in HA (multi-node) mode, you need to provide a unique, not shared, home directory for node specific content bamboo.home=/Users/kimkmari/bamboo #If running in HA mode, you need to provide a shared home directory that will be used by all nodes #It is allowed to mount this shared directory as a subdirectory of bamboo.home #Can be left undefined when running in single node mode, in which case the data will be stored in ${bamboo.home}/shared #bamboo.shared.home= . ",
    "url": "/docs/02_Tech/CICD/Bamboo#1-bamboo-%EB%A1%9C%EC%BB%AC%EC%97%90-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#1-bamboo-로컬에-설치하기"
  },"29": {
    "doc": "3. Bamboo",
    "title": "2. Bamboo 시작",
    "content": "설치전 java 17 버전임을 확인해주세요. $ cd &lt;Bamboo 설치 디렉토리&gt; $ ./bin/start-bamboo.sh . Bamboo가 시작되면 다음 주소로 접속할 수 있습니다: http://localhost:8085/ . ",
    "url": "/docs/02_Tech/CICD/Bamboo#2-bamboo-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#2-bamboo-시작"
  },"30": {
    "doc": "3. Bamboo",
    "title": "3. Bamboo 체험판 라이센스 받기",
    "content": "참고 자료 : Get a Bamboo Data Center trial license . trial license 등록절차 . | my.atlassian.com 로그인 | Product - Bamboo / Organization - Data Center 입력 | Server ID - 앞서 생성한 Bamboo 주소에서 참조 -&gt; http://localhost:8085/ | . 해당 과정이 마무리되면 License Key를 발급받게 됩니다. ",
    "url": "/docs/02_Tech/CICD/Bamboo#3-bamboo-%EC%B2%B4%ED%97%98%ED%8C%90-%EB%9D%BC%EC%9D%B4%EC%84%BC%EC%8A%A4-%EB%B0%9B%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#3-bamboo-체험판-라이센스-받기"
  },"31": {
    "doc": "3. Bamboo",
    "title": "4. Configure Bamboo",
    "content": "4.1 Configure instance . Jenkins와 Bamboo는 모두 CI/CD 영역에서 강력한 도구입니다. Jenkins는 오픈 소스로 널리 사용되며, Bamboo는 상업적 라이선스를 가진 도구입니다. Bamboo는 사용자 친화적인 인터페이스와 Atlassian 제품군과의 긴밀한 통합으로 인해 특히 주목받습니다. 반면 Jenkins는 플러그인의 광범위한 지원으로 높은 확장성을 자랑합니다. 참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/CICD/Bamboo#4-configure-bamboo",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo#4-configure-bamboo"
  },"32": {
    "doc": "3. Bamboo",
    "title": "3. Bamboo",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Bamboo",
    
    "relUrl": "/docs/02_Tech/CICD/Bamboo"
  },"33": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 - cdk init 1편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#typescript-cdk%EB%A1%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%AA%A8%EB%93%88-%EA%B5%AC%EC%A1%B0-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---cdk-init-1%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#typescript-cdk로-재사용-가능한-모듈-구조-작성하기---cdk-init-1편"
  },"34": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "목차",
    "content": ". | TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 - cdk init 1편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. cdk init . | 1.1 기본 CDK 앱 예제 | . | 2. 모듈화된 CDK 구조 . | 2.1 디렉토리 구조 | 2.3 모듈화된 CDK 구조의 장점 | . | 3. 왜 모듈화가 필요한가? . | 3.1 기존 구조의 문제점 | . | 4. 다음 편에서 다룰 내용 | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#목차"
  },"35": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "글을 쓴 배경",
    "content": "AWS Cloud Development Kit (CDK)를 사용하여 재사용 가능한 모듈 구조를 작성하는 방법을 공유하고자 합니다. 기존 bootstrap으로 만든 구조에서는 배포할 스택에 하드코딩된 상세 정보들이 많아 이를 재사용하기 쉽지 않았습니다. 또한 배포 중 context를 이용한 리소스 공유 등 고도화된 런타임 설정이 요구되었습니다. 이를 개선하기 위해 config 파일을 사용하는 방법을 고안하였고, 해당 구조로 배포를 시도하게 되었습니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#글을-쓴-배경"
  },"36": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "글 요약",
    "content": "이 글에서는 cdk init 명령어로 생성되는 기본 CDK 프로젝트 구조와, 이를 개선하여 모듈화된 CDK 프로젝트 구조를 작성하는 방법을 설명합니다. 또한, 디렉토리 구조를 조직화하여 각 역할에 맞게 파일을 배치하는 방법을 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#글-요약"
  },"37": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "시작하기 전",
    "content": "AWS CDK와 TypeScript에 대한 기본 지식이 필요합니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#시작하기-전"
  },"38": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "1. cdk init",
    "content": "기본 CDK 구조 . cdk init 명령어를 사용하여 생성된 기본 CDK 프로젝트는 다음과 같은 구조를 가집니다 . lib 디렉토리에 배포할 스택을 관리하고, bin 디렉토리에 있는 app.ts 파일을 이용해 배포합니다. my-cdk-app/ ├── bin/ │ └── my-cdk-app.ts ├── lib/ │ └── my-cdk-app-stack.ts ├── node_modules/ ├── .gitignore ├── cdk.json ├── package.json ├── tsconfig.json └── README.md . 1.1 기본 CDK 앱 예제 . bin/my-cdk-app.ts . #!/usr/bin/env node import 'source-map-support/register'; import * as cdk from 'aws-cdk-lib'; import { TempStack } from '../lib/temp-stack'; const app = new cdk.App(); new TempStack(app, 'TempStack', { // env: { account: process.env.CDK_DEFAULT_ACCOUNT, region: process.env.CDK_DEFAULT_REGION }, // env: { account: '123456789012', region: 'us-east-1' }, }); . lib/temp-stack.ts . import * as cdk from 'aws-cdk-lib'; import { Construct } from 'constructs'; // import * as sqs from 'aws-cdk-lib/aws-sqs'; export class TempStack extends cdk.Stack { constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); // The code that defines your stack goes here // example resource // const queue = new sqs.Queue(this, 'TempQueue', { // visibilityTimeout: cdk.Duration.seconds(300) // }); } } . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#1-cdk-init",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#1-cdk-init"
  },"39": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "2. 모듈화된 CDK 구조",
    "content": "다양한 환경에서 배포하고, 스택 간의 의존성 관리등을 개선한 구조입니다. 코드 재사용성을 극대화하는데 목표를 두었습니다. ├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ ├── app-config-demo.json │ ├── config-sample.json ├── infra │ ├── pattern │ └── stack │ ├── cfn-template │ └── sample-cfn-vpc.yaml ├── jest.config.js ├── lib │ ├── app-config.ts │ └── app-context.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . 기본 구조와 변경된 구조 비교도 . 2.1 디렉토리 구조 . | bin 디렉토리: 애플리케이션의 진입점 파일을 포함합니다. | infra 디렉토리: 리소스 배포 스택을 포함합니다. | lib 디렉토리: 의존성과 관련된 코드를 포함합니다. | config 디렉토리: 환경 설정 파일을 포함합니다. | scripts 디렉토리: 배포 스크립트를 포함합니다. | . 2.3 모듈화된 CDK 구조의 장점 . | 유지보수 용이성: 각 디렉토리와 파일이 역할에 따라 나누어져 있어 관리가 용이합니다. | 재사용성: 설정 파일을 분리하여 여러 환경에서 재사용할 수 있습니다. | 유연성: 컨텍스트를 이용하여 런타임 중 설정 값을 동적으로 변경할 수 있습니다. | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#2-%EB%AA%A8%EB%93%88%ED%99%94%EB%90%9C-cdk-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#2-모듈화된-cdk-구조"
  },"40": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "3. 왜 모듈화가 필요한가?",
    "content": "기존의 구조에서는 스택을 정의할 때 하드코딩된 값들이 많아 재 사용이 어려웠습니다. 아래는 VPC와 ElastiCach를 설정하는 예제입니다. import * as cdk from \"aws-cdk-lib\"; import { Construct } from \"constructs\"; import * as EC2 from \"aws-cdk-lib/aws-ec2\"; import { aws_elasticache as ElastiCache } from \"aws-cdk-lib\"; import { SecurityGroup, Peer, Port } from \"aws-cdk-lib/aws-ec2\"; export default class ElasticacheNodeRedisStack extends cdk.Stack { private vpc: EC2.Vpc; constructor(scope: Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); const elastiCacheRedisPort = 6379; const elastiCacheVPCName = \"ElastiCacheVPC\"; const elastiCacheSubnetIds = []; const elastiCacheSubnetGroupName = \"ElastiCacheSubnetGroup\"; const elastiCacheSecurityGroupName = \"ElastiCacheSecurityGroup\"; const elastiCacheRedisName = \"ElastiCacheNodeRedis\"; this.vpc = new EC2.Vpc(this, elastiCacheVPCName.toLowerCase()); for (const subnet of this.vpc.privateSubnets) { console.log(`Private Subnet Id: ${subnet.subnetId}`); elastiCacheSubnetIds.push(subnet.subnetId); } const elastiCacheSubnetGroup = new ElastiCache.CfnSubnetGroup( this, elastiCacheSubnetGroupName.toLowerCase(), { description: \"ElastiCache Subnet Group CDK\", cacheSubnetGroupName: elastiCacheSubnetGroupName.toLowerCase(), subnetIds: elastiCacheSubnetIds, } ); const elastiCacheSecurityGroup = new SecurityGroup( this, elastiCacheSecurityGroupName.toLowerCase(), { vpc: this.vpc, allowAllOutbound: true, description: \"ElastiCache Security Group CDK\", securityGroupName: elastiCacheSecurityGroupName.toLowerCase(), } ); elastiCacheSecurityGroup.addIngressRule( Peer.anyIpv4(), Port.tcp(elastiCacheRedisPort), \"ElastiCache for Redis Port\" ); const elastiCacheRedis = new ElastiCache.CfnCacheCluster( this, elastiCacheRedisName.toLowerCase(), { clusterName: elastiCacheRedisName.toLowerCase(), cacheNodeType: \"cache.t3.micro\", engine: \"redis\", engineVersion: \"6.x\", numCacheNodes: 1, cacheSubnetGroupName: elastiCacheSubnetGroup.ref, vpcSecurityGroupIds: [elastiCacheSecurityGroup.securityGroupId], cacheParameterGroupName: \"default.redis6.x\", tags: [{ key: \"Environment\", value: \"production\" }], } ); } } . 3.1 기존 구조의 문제점 . | 하드코딩된 설정: VPC, Subnet, Security Group 등의 설정이 하드코딩되어 있어 재사용이 어렵습니다. | 유연성 부족: 환경에 따른 설정 변경이 어렵습니다. | 재사용성 부족: 다른 프로젝트나 환경에서 동일한 코드를 재사용하기 어렵습니다. | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#3-%EC%99%9C-%EB%AA%A8%EB%93%88%ED%99%94%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#3-왜-모듈화가-필요한가"
  },"41": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "4. 다음 편에서 다룰 내용",
    "content": "2-2. CDK 컨텍스트 값의 개념과 사용 . CDK 컨텍스트 값이란 무엇인지, 그리고 이를 어떻게 활용할 수 있는지에 대해 설명합니다. 주요 내용 . | 컨텍스트 값의 정의 | 컨텍스트 값의 저장 및 관리 | AppContext 클래스에서 컨텍스트 값 관리 | 컨텍스트 값의 사용 예 | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app#4-%EB%8B%A4%EC%9D%8C-%ED%8E%B8%EC%97%90%EC%84%9C-%EB%8B%A4%EB%A3%B0-%EB%82%B4%EC%9A%A9",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app#4-다음-편에서-다룰-내용"
  },"42": {
    "doc": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "title": "2-1. TypeScript CDK로 재사용 가능한 모듈 구조 작성하기 (1편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-app",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-app"
  },"43": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - Construct 4편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---construct-4%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#재활용-할-수-있는-cdk-모듈-생성하기---construct-4편"
  },"44": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - Construct 4편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. Construct 란? | 3. Construct 사용법 . | 3.1 Construct를 인스턴스화 하여 사용 | 3.2 기존 Construct 조합하기 | 3.3 직접 construct 작성하기 | 3.4 CodeBuildSimplePattern Construct 예제 . | 3.4.1 CodeBuildSimplePattern 클래스 코드 상세 설명 | . | 4. BaseConstruct 활용 | . | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#목차"
  },"45": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#글을-쓴-배경"
  },"46": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#글-요약"
  },"47": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#시작하기-전"
  },"48": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#1-프로젝트-구조"
  },"49": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "2. Construct 란?",
    "content": ". AWS Cloud Development Kit (AWS CDK)의 요소인 Construct는 AWS 리소스를 구성하고 관리하는 기본 단위입니다. construct hub을 통해 cdk resource를 쉽게 찾고 활용할 수 있습니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#2-construct-%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#2-construct-란"
  },"50": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "3. Construct 사용법",
    "content": "Construct는 AWS CDK 앱의 구성 요소로, 다음과 같은 방식으로 사용됩니다: . 3.1 Construct를 인스턴스화 하여 사용 . AWS CDK에서는 이미 정의된 Construct를 직접 인스턴스화하여 사용할 수 있습니다. 예를 들어, s3.Bucket 같은 Construct를 바로 인스턴스화하여 사용할 수 있습니다 . import * as cdk from 'aws-cdk-lib'; import * as s3 from 'aws-cdk-lib/aws-s3'; class MyBucketStack extends cdk.Stack { constructor(scope: cdk.App, id: string, props?: cdk.StackProps) { super(scope, id, props); new s3.Bucket(this, 'MyFirstBucket', { versioned: true, }); } } const app = new cdk.App(); new MyBucketStack(app, 'MyBucketStack'); . 3.2 기존 Construct 조합하기 . 여러 Construct를 조합하여 더 복잡한 구성 요소를 만들 수 있습니다. 예를 들어, S3 버킷과 SNS Topic을 조합하여 특정 이벤트에 대한 알림을 설정할 수 있습니다. import * as cdk from 'aws-cdk-lib'; import * as s3 from 'aws-cdk-lib/aws-s3'; import * as sns from 'aws-cdk-lib/aws-sns'; import * as s3notifications from 'aws-cdk-lib/aws-s3-notifications'; class MyNotificationBucketStack extends cdk.Stack { constructor(scope: cdk.App, id: string, props?: cdk.StackProps) { super(scope, id, props); const bucket = new s3.Bucket(this, 'MyBucket'); const topic = new sns.Topic(this, 'MyTopic'); bucket.addEventNotification(s3.EventType.OBJECT_CREATED, new s3notifications.SnsDestination(topic)); } } const app = new cdk.App(); new MyNotificationBucketStack(app, 'MyNotificationBucketStack'); . 3.3 직접 construct 작성하기 . 새 구문을 선언하려면 Construct 기본 클래스를 확장하는 클래스를 만들고, 초기화 할때 필요한 매개변수를 전달해 주면 됩니다. 다음은 Construct를 작성하고 배포하는 방법에 대한 예제입니다. 3.4 CodeBuildSimplePattern Construct 예제 . 이 예제 클래스에서는 Construct를 확장하여 CodeCommit 리포지토리, IAM 역할, 정책, S3 버킷을 포함하는 CodeBuildSimplePattern을 정의합니다. 이를 통해 복잡한 워크로드를 하나의 커스텀 Construct로 구성하고 배포할 수 있습니다. import * as codebuild from 'aws-cdk-lib/aws-codebuild'; import * as codecommit from 'aws-cdk-lib/aws-codecommit'; import * as iam from 'aws-cdk-lib/aws-iam'; import * as cdk from 'aws-cdk-lib'; import { Construct } from 'constructs'; import * as path from \"node:path\"; import * as fs from \"node:fs\"; import * as s3 from 'aws-cdk-lib/aws-s3'; import * as s3check from \"../../pattern/s3/s3-check-pattern\"; import { CodeBuildSimplePatternProps , Policy} from \"../../common/interfaces\" export class CodeBuildSimplePattern extends Construct { public readonly repository: codecommit.Repository; public Bucket: s3.IBucket; private stackConfig: any; private projectPrefix: string; constructor(scope: Construct, id: string, props: CodeBuildSimplePatternProps) { super(scope, id); this.stackConfig = props.stackConfig; this.projectPrefix = props.projectPrefix; const projectName = `${props.projectPrefix}-${this.stackConfig.ProjectName}` const repositoryName = `${props.projectPrefix}-${this.stackConfig.RepositoryName}`; const roleName = `${props.projectPrefix}-${this.stackConfig.RoleName}`; const policyName = `${props.projectPrefix}-${this.stackConfig.PolicyName}`; const bucketName = `${props.projectPrefix}-${this.stackConfig.BucketName}`; // Create CodeCommit Repository this.repository = new codecommit.Repository(this, repositoryName, { repositoryName: repositoryName, description: this.stackConfig.RepositoryDescription, }); const iamRole = new iam.Role(this, roleName, { assumedBy: new iam.ServicePrincipal('codebuild.amazonaws.com'), roleName: roleName, }); const policyPath = path.join(__dirname, \"codebuild-pol.json\"); const policyData: { Statement: Policy[] } = JSON.parse(fs.readFileSync(policyPath, 'utf8')); const Policy = new iam.Policy(this, policyName, { policyName: policyName, }); policyData.Statement.forEach((policy) =&gt; { Policy.addStatements(new iam.PolicyStatement({ effect: iam.Effect[policy.Effect as keyof typeof iam.Effect], resources: policy.Resource, actions: policy.Action, })); }); iamRole.attachInlinePolicy(Policy); // Set output values new cdk.CfnOutput(this, roleName, { value: iamRole.roleArn }); // Initialize and use CheckS3Pattern this.initializeBucket(props, bucketName, iamRole); } private async initializeBucket(props: CodeBuildSimplePatternProps, bucketName: string, iamRole: iam.IRole) { const checkS3Pattern = new s3check.CheckS3Pattern(this, bucketName, { bucketName: bucketName }); this.Bucket = await checkS3Pattern.bucket; this.createCodeBuildProject(this.stackConfig.Name, this.repository, iamRole, this.Bucket, props); } private createCodeBuildProject( projectName: string, repository: codecommit.IRepository, role: iam.IRole, bucket: s3.IBucket, props: CodeBuildSimplePatternProps ): codebuild.Project { return new codebuild.Project(this, projectName, { projectName: projectName, source: codebuild.Source.codeCommit({ repository }), environment: { buildImage: codebuild.LinuxBuildImage.AMAZON_LINUX_2_5, }, role, cache: codebuild.Cache.bucket(bucket, { prefix: `cache/${projectName}`, }), timeout: cdk.Duration.minutes(30), }); } } . 3.4.1 CodeBuildSimplePattern 클래스 코드 상세 설명 . 생성자 . | scope - 현재 Construct가 어디에 포함되는지를 정의합니다. | id - Construct의 고유 식별자입니다. 같은 scope 내에서 Construct를 구분하기 위한 이름입니다. 동일한 종류의 여러 리소스를 생성할 때 유용합니다. | props - 생성자에 전달된 추가 매개변수들을 포함합니다. | . constructor(scope: Construct, id: string, props: CodeBuildSimplePatternProps) { super(scope, id); . CodeBuildSimplePattern 클래는 아래와 같은 작업을 수행합니다. | CodeCommit 리포지토리 생성: 새로운 코드 저장소를 생성합니다. | IAM 역할 및 정책 설정: CodeBuild가 사용할 역할을 생성하고, 설정된 정책을 연결합니다. | S3 버킷: CodeBuild에서 캐시 버킷으로 사용할 버킷을 조회하고 없으면 생성합니다. | CodeBuild 프로젝트 생성: CodeCommit 리포지토리, IAM 역할, S3 버킷을 사용하여 CodeBuild 프로젝트를 생성하는 워크로드를 구성합니다. | . 4. BaseConstruct 활용 . construct도 stack과 마찬가지로 construct간의 공통된 속성을 적용하기 위해 BaseConstruct를 사용할 수 있습니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct#3-construct-%EC%82%AC%EC%9A%A9%EB%B2%95",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct#3-construct-사용법"
  },"51": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Construct (4편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-construct",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-construct"
  },"52": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - app, context 2편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---app-context-2%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#재활용-할-수-있는-cdk-모듈-생성하기---app-context-2편"
  },"53": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - app, context 2편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. CDK APP 이란? | 2. CDK Context란? | 3. bin 디렉토리와 app.ts 파일 . | 3.1 app.ts 파일의 역할 | 3.2 app.ts 파일 예제 | 3.3 AppContext 클래스와 컨텍스트 관리 | 3.4 주요 메소드 설명 | 3.4.1 createStackCommonProps() 메소드 | 3.4.2 ready() 메소드 | 3.4.3 findAppConfigFile(appConfigKey: string) 메소드 | 3.4.4 getProjectPrefix(appConfigKey: string) 메소드 | 3.4.5 applyProjectPrefixToStack(appConfig: any): void 메소드 | 3.4.5 loadAppConfigFile(filePath: string, contextArgs?: string[]): any 메소드 | 3.4.6 updateContextArgs(appConfig: any, contextArgs: string[]) 메소드 | 3.4.7 addPrefixIntoResourceName(appConfig: any, projectPrefix: string) 메소드 | . | 4. Context 사용 | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#목차"
  },"54": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "글을 쓴 배경",
    "content": "이 글은 AWS CDK를 사용하여 재사용 가능한 모듈 구조를 작성하는 방법을 설명하기 위해 작성되었습니다. CDK 앱의 초기화, bin 디렉토리의 역할, 컨텍스트 값의 개념과 사용법을 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#글을-쓴-배경"
  },"55": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "글 요약",
    "content": "이 글에서는 CDK 프로젝트의 진입점인 app과 context 역할을 설명하고, 어떻게 사용되는지에 대해 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#글-요약"
  },"56": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#시작하기-전"
  },"57": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#1-프로젝트-구조"
  },"58": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "2. CDK APP 이란?",
    "content": ". CDK 앱은 하나 이상의 스택으로 구성된 컬렉션을 의미합니다. 앱 인스턴스는 AWS CDK의 App 클래스를 사용하여 아래와 같이 생성됩니다. this.cdkApp = new cdk.App(); . 앱 내의 모든 스택과 리소스는 이 클래스의 범위 내에서 정의됩니다. 앱 인스턴스는 초기화 인수가 필요하지 않으며, 앱내의 리소스에 context를 제공합니다. 이렇게 생성된 App 클래스는 자신을 루트로 하는 계층구조를 정의합니다. 앱 내에서 하나 이상의 스택을 인스턴스화 할 수 있고, 스택 내에서 construct를 인스턴스화 하며, construct는 또 다른 construct를 인스턴스화 할 수 있습니다. 이러한 트리구조에서 모든 구문이 서로의 범위 내에 정의되도록하여 구문간의 관계를 명확히 설정하고있습니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#2-cdk-app-%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#2-cdk-app-이란"
  },"59": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "2. CDK Context란?",
    "content": "AWS CDK 앱에서 여러 스택과 리소스 간에 공통적으로 필요한 속성 값이나 메소드를 관리하는데 사용되는 클래스 입니다. 구문간의 관계가 명확히 설정된 환경에서 여러 스택 간에 공통적으로 필요한 값들을 관리하고 사용할 수 있는 컨텍스트가 필요하며, 이를 통해 일관된 환경 설정과 효율적인 리소스 관리를 할 수 있습니다. 그렇다면 이제 어떻게 app 과 context를 활용하는지 알아보겠습니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#2-cdk-context%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#2-cdk-context란"
  },"60": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "3. bin 디렉토리와 app.ts 파일",
    "content": "AWS CDK 프로젝트에서 bin 디렉토리는 애플리케이션의 진입점을 정의하는 파일들을 담고 있습니다. 이 디렉토리에는 CDK 앱을 초기화하고 스택을 생성 및 구성하는 코드가 들어 있습니다. 3.1 app.ts 파일의 역할 . | 앱 컨텍스트 초기화: 커스텀 클래스인 AppContext를 사용하여 앱의 환경 정보를 초기화합니다. | AppContext 클래스의 인스턴스를 생성하여 앱의 환경 정보를 초기화합니다. | appConfigFileKey를 통해 config파일이 있는 위치를 찾습니다. | contextArgs는 런타임에 구성을 동적으로 변경할 수 있는 cdk 명령어 인수입니다. | projectPrefixType은 프로젝트 접두사의 네이밍 규칙을 결정합니다. | . | 스택 생성 및 구성: CDK 스택을 생성하고 필요한 구성 정보를 전달합니다. | CodeBuildStack과 CodeDeployStack 스택을 생성합니다. | 각 스택은 특정 AWS 리소스를 구성하며, appContext와 스택에서 사용될 config 정보를 인수로 전달받습니다. | . | . 3.2 app.ts 파일 예제 . import { AppContext, AppContextError } from '../lib/app-context'; import {CodeBuildStack} from \"../infra/stack/codebuild/codebuild-stack\"; import {CodeDeployStack} from \"../infra/stack/codedeploy/codedeploy-stack\"; try { // 프로젝트의 환경 정보를 구성 const appContext = new AppContext({ appConfigFileKey: 'APP_CONFIG', contextArgs: ['Stack.SampleVpcEcs.DesiredCount'], projectPrefixType: 1 }); // 스택 생성 및 구성 new CodeBuildStack(appContext, appContext.appConfig.Stack.CodeBuildSimplePatternStack) new CodeDeployStack(appContext, appContext.appConfig.Stack.CodeDeploySimplePatternStack) } catch (error) { if (error instanceof AppContextError) { console.error('[AppContextError]:', error.message); } else { console.error('[Error]: not-handled-error', error); } } . 3.3 AppContext 클래스와 컨텍스트 관리 . 앞서 설명한대로 여러 스택 간의 공통적인 설정을 효과적으로 관리하는 것은 중요합니다. 이를 위해 AppContext 클래스와 이를 활용하는 방법에 대해 알아보겠습니다. 아래 AppContext 커스텀 클래스는 앱 실행시 가장먼저 실행되며 App 인스턴스를 생성하고, 인수로 전달된 구성 파일을 로드하며, 스택에 필요한 공통 설정을 적용합니다. lib/app-context.ts . const fs = require('fs'); const env = require('env-var'); import * as cdk from 'aws-cdk-lib'; import { AppConfig } from './app-config'; import { StackCommonProps } from './template/stack/base/base-stack'; export class AppContextError extends Error { constructor(message: string) { super(message); this.name = \"AppConfigFileFailError\"; } } export enum ProjectPrefixType { NameStage, NameHyphenStage, Name } export interface AppContextProps { appConfigFileKey: string; contextArgs?: string[]; projectPrefixType?: ProjectPrefixType; } export class AppContext { public readonly cdkApp: cdk.App; public readonly appConfig: AppConfig; public readonly stackCommonProps: StackCommonProps; private readonly appContextProps: AppContextProps; constructor(props: AppContextProps) { this.cdkApp = new cdk.App(); this.appContextProps = props; try { const appConfigFile = this.findAppConfigFile(props.appConfigFileKey); this.appConfig = this.loadAppConfigFile(appConfigFile, props.contextArgs); if (this.appConfig != undefined) { this.stackCommonProps = this.createStackCommonProps(appConfigFile); } } catch (e) { console.error(`==&gt; CDK App-Config File is empty, set up your environment variable (Usage: export ${props.appConfigFileKey}=config/app-config-xxx.json) or append inline-argurment (Usage: cdk list --context ${props.appConfigFileKey}=config/app-config-xxx.json)`, e); throw new AppContextError('Fail to find App-Config json file'); } } // ... } . 3.4 주요 메소드 설명 . CDK 애플리케이션의 설정과 환경을 관리하기 위한 다양한 메소드들이 AppContext 클래스에 존재합니다. export class AppContext { //... public ready(): boolean { return this.stackCommonProps ? true : false; } private createStackCommonProps(appConfigFilePath: string): StackCommonProps { //... return commonStackProps; } private findAppConfigFile(appConfigKey: string): string { //... return configFilePath; } public getProjectPrefix(CompanyCode: string, Environment: string,ServiceCode: string, DetailInfo: string): string { //... return prefix; } private applyProjectPrefix(appConfig: any): void { //... } private loadAppConfigFile(filePath: string, contextArgs?: string[]): any { //... return appConfig; } private updateContextArgs(appConfig: any, contextArgs: string[]) { //... } private addPrefixIntoResourceName(appConfig: any, projectPrefix: string) { //... } private addSimpleResourceName(appConfig: any) { //... } } . 3.4.1 createStackCommonProps() 메소드 . 설정 파일들을 기반으로 StackCommonProps 객체를 생성하는 메소드 입니다. | projectPrefix 생성: this.getProjectPrefix 메소드를 호출하여 appConfig.Project에 있는 값들을 활용해 projectPrefix를 생성합니다. | appConfig : 지정한 경로에 있는 config 파일을 JSON 객체로 전달된 값 | variables 속성: 빈 객체로 초기화하여 필요한 경우 추가적인 변수를 담기 위해 사용할 수 있습니다. | . private createStackCommonProps(appConfigFilePath: string): StackCommonProps{ const commonStackProps: StackCommonProps = { projectPrefix: this.getProjectPrefix(this.appConfig.Project.CompanyCode, this.appConfig.Project.Environment, this.appConfig.Project.ServiceCode, this.appConfig.Project.DetailInfo), appConfig: this.appConfig, appConfigPath: appConfigFilePath, env: { account: this.appConfig.Project.Account, region: this.appConfig.Project.Region }, variables: {} } return commonStackProps; } . 3.4.2 ready() 메소드 . 이 메소드는 특정 조건을 확인하여 클래스의 준비 상태를 반환합니다. | 역할 : stackCommonProps 객체가 올바르게 초기화되어 사용할 준비가 되었는지 여부를 확인합니다. | 사용 이유 : 다른 코드에서 AppContext 객체를 사용 전 객체가 올바르게 설정되었는지 확인할 수 있는 방법입니다. | . public ready(): boolean { return this.stackCommonProps ? true : false; } . 3.4.3 findAppConfigFile(appConfigKey: string) 메소드 . 이 메소드는 설정 파일의 경로를 찾습니다. | 역할: 주어진 키를 이용해 설정 파일의 경로를 찾습니다. | 사용 이유: 다양한 소스(컨텍스트 값 또는 환경 변수)를 통해 전달된 설정 파일의 경로를 로드할 수 있도록 합니다. | . Node.js에서 제공하는 env-var 패키지를 사용하여 지정된 환경변수 키 값을 이용해 설정 파일의 경로를 가져올 수 있습니다. 또한, CDK 명령어 인수로 설정 파일의 경로를 제공할 수도 있습니다. private findAppConfigFile(appConfigKey: string): string { let fromType = 'InLine-Argument'; let configFilePath = this.cdkApp.node.tryGetContext(appConfigKey); // CDK 컨텍스트에서 경로를 검색 if (configFilePath == undefined) { configFilePath = env.get(appConfigKey).asString(); // 환경 변수에서 경로를 검색 if (configFilePath != undefined &amp;&amp; configFilePath.length &gt; 0) { fromType = 'Environment-Variable'; // 환경 변수에서 값을 찾은 경우 출처를 변경 } else { configFilePath = undefined; // 값을 찾지 못한 경우 경로를 undefined로 설정 } } if (configFilePath == undefined) { throw new Error('Fail to find App-Config json file'); // 경로를 찾지 못한 경우 오류 발생 } else { console.info(`==&gt; CDK App-Config File is ${configFilePath}, which is from ${fromType}.`); // 경로와 출처를 로그로 출력 } return configFilePath; } . 참고 : 컨텍스트 값 설정 방법 ( 설정파일 전달 방법 ) . | cdk.json 파일 | . { \"context\": { \"APP_CONFIG\": \"path/to/config.json\" } } . | 명령줄 인수 | . cdk deploy --context APP_CONFIG=path/to/config.json . 3.4.4 getProjectPrefix(appConfigKey: string) 메소드 . 프로젝트 접두사를 생성합니다. | 역할: 주어진 프로젝트 정보를 바탕으로 프로젝트 접두사를 생성합니다. | 사용 이유: 스택 리소스 명명 규칙에 따라 일관된 접두사를 생성하여 리소스를 관리하기 쉽게 만듭니다. ProjectPrefixType 따라 다른 prefix를 제공할 수 있습니다. | . public getProjectPrefix(CompanyCode: string, Environment: string, ServiceCode: string, DetailInfo: string): string { let prefix = `${CompanyCode}${Environment}${ServiceCode}${DetailInfo}`; if (this.appContextProps.projectPrefixType === ProjectPrefixType.NameHyphenStage) { prefix = `${CompanyCode}-${Environment}-${ServiceCode}-${DetailInfo}`; } else if (this.appContextProps.projectPrefixType === ProjectPrefixType.Name) { prefix = ServiceCode; } return prefix; } . 3.4.5 applyProjectPrefixToStack(appConfig: any): void 메소드 . 주어진 AppConfig 객체의 스택 리소스 이름에 프로젝트 접두사를 적용합니다. | 역할: 주어진 프로젝트 접두사를 이용해 이를 스택 리소스에 적용하여 일관된 명명 규칙을 따르도록 합니다. | 사용 이유: 프로젝트의 스택 명칭에 일관되고 유일한 접두사를 부여함으로써, 리소스 관리 및 식별을 용이하게 합니다. | . private applyProjectPrefixToStack(appConfig: any): void { // getProjectPrefixProps 메소드를 사용하여 appConfig에서 필요한 속성들을 가져와서 getProjectPrefix 메소드에 전달 const prefix = this.getProjectPrefix(this.getProjectPrefixProps(appConfig)); // appConfig.Stack 객체의 모든 키에 대해 반복 Object.keys(appConfig.Stack).forEach(key =&gt; { // 스택 명칭은 별도로 설정 appConfig.Stack[key].StackName = `${prefix}-${appConfig.Stack[key].StackName}`; }); } . 3.4.5 loadAppConfigFile(filePath: string, contextArgs?: string[]): any 메소드 . 주어진 파일 경로에서 앱 구성 파일을 로드하고, 필요에 따라 컨텍스트 인자를 업데이트하며, 스택 이름에 프로젝트 접두사를 추가합니다. | 역할 : 앱 구성파일을 로드하여 JSON 객체로 파싱합니다. | 사용 이유 : JSON 객체로 파싱된 앱 구성파일을 이용해 실제 스택 리소스를 배포하기 위해 사용됩니다. | . private loadAppConfigFile(filePath: string, contextArgs?: string[]): any { // 파일 경로에서 앱 구성 파일을 읽어와 JSON 객체로 파싱 let appConfig = JSON.parse(fs.readFileSync(filePath).toString()); // 프로젝트 접두사를 생성 let projectPrefix = this.getProjectPrefix(this.getProjectPrefixProps(appConfig.Project)); // 컨텍스트 인자가 정의된 경우, 앱 구성에 반영 if (contextArgs != undefined) { this.updateContextArgs(appConfig, contextArgs); } // 리소스 이름에 프로젝트 접두사를 추가 this.addPrefixIntoResourceName(appConfig, projectPrefix); return appConfig; } . 3.4.6 updateContextArgs(appConfig: any, contextArgs: string[]) 메소드 . 주어진 컨텍스트 인자를 앱 구성에 업데이트합니다. | 역할: 컨텍스트 인자에 따라 앱 구성 파일의 값을 업데이트합니다. | 사용 이유: CDK 앱의 컨텍스트에서 가져온 값을 앱 구성 파일에 반영하여 동적으로 값을 변경할 수 있게 합니다. | . private updateContextArgs(appConfig: any, contextArgs: string[]) { for (let key of contextArgs) { const jsonKeys = key.split('.'); let oldValue = undefined; const newValue: string = this.cdkApp.node.tryGetContext(key); if (newValue != undefined &amp;&amp; jsonKeys.length &gt; 0) { try { // 기존 값을 찾아서 oldValue에 저장 oldValue = jsonKeys.reduce((reducer: any, pointer: string) =&gt; reducer.hasOwnProperty(pointer) ? reducer[pointer] : undefined, appConfig); } catch (e) { console.error(`[ERROR] updateContextArgs: This key[${key}] is an undefined value in Json-Config file.\\n`, e); throw e; } // 새로운 값을 설정 jsonKeys.reduce((reducer: any, pointer: string, count: number) =&gt; { if (count == jsonKeys.length - 1) reducer[pointer] = newValue; return reducer[pointer]; }, appConfig); console.info(`[INFO] updateContextArgs: Updated ${key} = ${oldValue}--&gt;${newValue}`); } } } . 코드 상세 설명 . 이 코드는 reduce 함수를 사용하여 중첩된 JSON 객체 내에서 새로운 값을 설정합니다. reduce 함수는 배열의 각 요소에 대해 누적 연산을 수행하는데, 이때 누적 값을 유지하기 위한 변수를 reducer라고 합니다. reduce 함수의 기본 구조는 다음과 같습니다. callback은 배열의 각 요소에 대해 호출되는 함수입니다. array.reduce(callback, initialValue) . 현재 호출된 내용을 보면 초기값으로 appConfig가 제공되어있습니다. oldValue = jsonKeys.reduce((reducer: any, pointer: string) =&gt; reducer.hasOwnProperty(pointer) ? reducer[pointer] : undefined, appConfig); . 만약 contextArgs 값으로 [‘Stack.CodeDeployStack.StackName’] 값이 넘어왔다면 . 최종적으로 oldValue는 appConfig[‘Stack’][‘CodeDeploySimplePatternStack’][‘StackName’]의 값을 가지게 됩니다. 3.4.7 addPrefixIntoResourceName(appConfig: any, projectPrefix: string) 메소드 . 주어진 앱 구성 객체의 스택 리소스 이름에 프로젝트 접두사를 추가합니다. private addPrefixIntoResourceName(appConfig: any, projectPrefix: string) { for (const key in appConfig.Stack) { const stackOriginalName = appConfig.Stack[key].StackName; appConfig.Stack[key].ShortStackName = stackOriginalName; appConfig.Stack[key].StackNameWithPrifix = `${projectPrefix}-${stackOriginalName}`; } } . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#3-bin-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EC%99%80-appts-%ED%8C%8C%EC%9D%BC",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#3-bin-디렉토리와-appts-파일"
  },"61": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "4. Context 사용",
    "content": ". | 명령줄 인수: cdk deploy –context key=value 명령을 통해 전달. | 환경 변수: export key=value 명령을 통해 설정. | cdk.json: 파일 내 직접 설정. | . 이렇게 설정된 컨텍스트 값은 CDK 애플리케이션의 실행 중에 필요한 다양한 설정을 동적으로 제공하며, 일관된 환경 설정과 효율적인 리소스 관리를 가능하게 합니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context#4-context-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context#4-context-사용"
  },"62": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - App, Context (2편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-context",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-context"
  },"63": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - pipeline 5편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---pipeline-5%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#재활용-할-수-있는-cdk-모듈-생성하기---pipeline-5편"
  },"64": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - pipeline 5편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. CDK APP 이란? | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#목차"
  },"65": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#글을-쓴-배경"
  },"66": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#글-요약"
  },"67": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#시작하기-전"
  },"68": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#1-프로젝트-구조"
  },"69": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "2. CDK APP 이란?",
    "content": "registerAction 함수는 Codepipeline 액션을 등록하는 역할 . ActionKind에 따라 적절한 액션을 생성하고 이를 파이프라인에 추가합니다. 이 함수는 다양한 종류의 액션을 처리하며, 각 액션에 대해 필요한 세부 정보를 포함하는 ActionProps 객체를 사용합니다. actionKind.startsWith(ActionKindPrefix.Source) 액션의 종류가 Source로 시작하는지 확인합니다. SourceCodeCommit , SourceS3Bucket 액션을 처리합니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#2-cdk-app-%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#2-cdk-app-이란"
  },"70": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern"
  },"71": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - pipeline 5편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---pipeline-5%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#재활용-할-수-있는-cdk-모듈-생성하기---pipeline-5편"
  },"72": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - pipeline 5편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. CDK APP 이란? | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#목차"
  },"73": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#글을-쓴-배경"
  },"74": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#글-요약"
  },"75": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#시작하기-전"
  },"76": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#1-프로젝트-구조"
  },"77": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "2. CDK APP 이란?",
    "content": "registerAction 함수는 Codepipeline 액션을 등록하는 역할 . ActionKind에 따라 적절한 액션을 생성하고 이를 파이프라인에 추가합니다. 이 함수는 다양한 종류의 액션을 처리하며, 각 액션에 대해 필요한 세부 정보를 포함하는 ActionProps 객체를 사용합니다. actionKind.startsWith(ActionKindPrefix.Source) 액션의 종류가 Source로 시작하는지 확인합니다. SourceCodeCommit , SourceS3Bucket 액션을 처리합니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#2-cdk-app-%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern#2-cdk-app-이란"
  },"78": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - pipeline (5편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-pipeline-pattern"
  },"79": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - Stack Advanced 5편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---stack-advanced-5%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#재활용-할-수-있는-cdk-모듈-생성하기---stack-advanced-5편"
  },"80": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - Stack Advanced 5편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. BaseStack 활용하기 | 3. CfnIncludeStack 클래스 . | 3.1 onLoadTemplateProps 메소드 | 3.2 onPostConstructor 메서드 | 3.3 loadTemplate 메서드 | 3.4 사용 예제 | . | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#목차"
  },"81": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "글을 쓴 배경",
    "content": "이 글은 AWS CDK를 사용하여 재사용 가능한 모듈 구조를 작성하는 방법을 설명하기 위해 작성되었습니다. stack 배포, infra 및 lib 디렉토리 역할, 사용법을 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#글을-쓴-배경"
  },"82": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "글 요약",
    "content": "이 글에서는 CDK 프로젝트의 진입점인 stack custom interface인 base-stack 인터페이스와 bin 디렉토리의 역할을 설명하고, CDK 컨텍스트 값이 무엇인지, 어떻게 사용되는지에 대해 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#글-요약"
  },"83": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#시작하기-전"
  },"84": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#1-프로젝트-구조"
  },"85": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "2. BaseStack 활용하기",
    "content": "기존 사용되고 있는 BaseStack의 주요 역할은 스택별 공통 설정 기능을 제공합니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#2-basestack-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#2-basestack-활용하기"
  },"86": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "3. CfnIncludeStack 클래스",
    "content": "CfnIncludeStack 클래스는 BaseStack을 확장하여 CloudFormation 템플릿을 포함하고, 이를 기반으로 스택을 구성하는 예제입니다. import * as cfn_inc from 'aws-cdk-lib/cloudformation-include'; import * as base from './base-stack'; import { AppContext } from '../../../app-context'; export interface CfnTemplateProps { templatePath: string; parameters?: any; } export abstract class CfnIncludeStack extends base.BaseStack { private cfnTemplate?: cfn_inc.CfnInclude; abstract onLoadTemplateProps(): CfnTemplateProps | undefined; abstract onPostConstructor(cfnTemplate?: cfn_inc.CfnInclude): void; constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); const props = this.onLoadTemplateProps(); if (props != undefined) { this.cfnTemplate = this.loadTemplate(props); } else { this.cfnTemplate = undefined; } this.onPostConstructor(this.cfnTemplate); } private loadTemplate(props: CfnTemplateProps): cfn_inc.CfnInclude { const cfnTemplate = new cfn_inc.CfnInclude(this, 'cfn-template', { templateFile: props.templatePath, }); if (props.parameters != undefined) { for (let param of props.parameters) { const paramEnv = cfnTemplate.getParameter(param.Key); paramEnv.default = param.Value; } } return cfnTemplate; } } . 3.1 onLoadTemplateProps 메소드 . 이 추상 메서드는 사용자가 CloudFormation 템플릿 경로와 필요한 매개변수를 제공하도록 합니다. 사용자는 이 메서드를 구현하여 필요한 설정을 반환해야 합니다. 3.2 onPostConstructor 메서드 . 이 추상 메서드는 스택 생성 후 추가적인 설정을 수행하기 위해 사용됩니다. 사용자는 이 메서드를 구현하여 스택 생성 후 필요한 작업을 정의할 수 있습니다. 3.3 loadTemplate 메서드 . 이 메서드는 CloudFormation 템플릿을 로드하고, 필요한 경우 매개변수를 설정합니다. 3.4 사용 예제 . SampleCfnVpcStack 클래스 . import * as ec2 from 'aws-cdk-lib/aws-ec2'; import * as cfn_inc from 'aws-cdk-lib/cloudformation-include'; import * as base from '../../../lib/template/stack/base/cfn-include-stack'; import { AppContext } from '../../../lib/app-context'; import { Override } from '../../../lib/template/stack/base/base-stack'; import { CfnTemplateProps } from '../../../lib/template/common/interfaces' export class SampleCfnVpcStack extends base.CfnIncludeStack { constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); } @Override onLoadTemplateProps(): CfnTemplateProps | undefined { return { templatePath: this.stackConfig.TemplatePath, parameters: this.stackConfig.Parameters }; } @Override onPostConstructor(cfnTemplate?: cfn_inc.CfnInclude) { const cfnVpc = cfnTemplate?.getResource('VPC') as ec2.CfnVPC; } } . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#3-cfnincludestack-%ED%81%B4%EB%9E%98%EC%8A%A4",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#3-cfnincludestack-클래스"
  },"87": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced"
  },"88": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - Stack Advanced 5편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---stack-advanced-5%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#재활용-할-수-있는-cdk-모듈-생성하기---stack-advanced-5편"
  },"89": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - Stack Advanced 5편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. BaseStack 활용하기 | 3. CfnIncludeStack 클래스 . | 3.1 onLoadTemplateProps 메소드 | 3.2 onPostConstructor 메서드 | 3.3 loadTemplate 메서드 | 3.4 사용 예제 | . | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#목차"
  },"90": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "글을 쓴 배경",
    "content": "이 글은 AWS CDK를 사용하여 재사용 가능한 모듈 구조를 작성하는 방법을 설명하기 위해 작성되었습니다. stack 배포, infra 및 lib 디렉토리 역할, 사용법을 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#글을-쓴-배경"
  },"91": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "글 요약",
    "content": "이 글에서는 CDK 프로젝트의 진입점인 stack custom interface인 base-stack 인터페이스와 bin 디렉토리의 역할을 설명하고, CDK 컨텍스트 값이 무엇인지, 어떻게 사용되는지에 대해 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#글-요약"
  },"92": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#시작하기-전"
  },"93": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#1-프로젝트-구조"
  },"94": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "2. BaseStack 활용하기",
    "content": "기존 사용되고 있는 BaseStack의 주요 역할은 스택별 공통 설정 기능을 제공합니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#2-basestack-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#2-basestack-활용하기"
  },"95": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "3. CfnIncludeStack 클래스",
    "content": "CfnIncludeStack 클래스는 BaseStack을 확장하여 CloudFormation 템플릿을 포함하고, 이를 기반으로 스택을 구성하는 예제입니다. import * as cfn_inc from 'aws-cdk-lib/cloudformation-include'; import * as base from './base-stack'; import { AppContext } from '../../../app-context'; export interface CfnTemplateProps { templatePath: string; parameters?: any; } export abstract class CfnIncludeStack extends base.BaseStack { private cfnTemplate?: cfn_inc.CfnInclude; abstract onLoadTemplateProps(): CfnTemplateProps | undefined; abstract onPostConstructor(cfnTemplate?: cfn_inc.CfnInclude): void; constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); const props = this.onLoadTemplateProps(); if (props != undefined) { this.cfnTemplate = this.loadTemplate(props); } else { this.cfnTemplate = undefined; } this.onPostConstructor(this.cfnTemplate); } private loadTemplate(props: CfnTemplateProps): cfn_inc.CfnInclude { const cfnTemplate = new cfn_inc.CfnInclude(this, 'cfn-template', { templateFile: props.templatePath, }); if (props.parameters != undefined) { for (let param of props.parameters) { const paramEnv = cfnTemplate.getParameter(param.Key); paramEnv.default = param.Value; } } return cfnTemplate; } } . 3.1 onLoadTemplateProps 메소드 . 이 추상 메서드는 사용자가 CloudFormation 템플릿 경로와 필요한 매개변수를 제공하도록 합니다. 사용자는 이 메서드를 구현하여 필요한 설정을 반환해야 합니다. 3.2 onPostConstructor 메서드 . 이 추상 메서드는 스택 생성 후 추가적인 설정을 수행하기 위해 사용됩니다. 사용자는 이 메서드를 구현하여 스택 생성 후 필요한 작업을 정의할 수 있습니다. 3.3 loadTemplate 메서드 . 이 메서드는 CloudFormation 템플릿을 로드하고, 필요한 경우 매개변수를 설정합니다. 3.4 사용 예제 . SampleCfnVpcStack 클래스 . import * as ec2 from 'aws-cdk-lib/aws-ec2'; import * as cfn_inc from 'aws-cdk-lib/cloudformation-include'; import * as base from '../../../lib/template/stack/base/cfn-include-stack'; import { AppContext } from '../../../lib/app-context'; import { Override } from '../../../lib/template/stack/base/base-stack'; import { CfnTemplateProps } from '../../../lib/template/common/interfaces' export class SampleCfnVpcStack extends base.CfnIncludeStack { constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); } @Override onLoadTemplateProps(): CfnTemplateProps | undefined { return { templatePath: this.stackConfig.TemplatePath, parameters: this.stackConfig.Parameters }; } @Override onPostConstructor(cfnTemplate?: cfn_inc.CfnInclude) { const cfnVpc = cfnTemplate?.getResource('VPC') as ec2.CfnVPC; } } . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#3-cfnincludestack-%ED%81%B4%EB%9E%98%EC%8A%A4",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#3-cfnincludestack-클래스"
  },"96": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced"
  },"97": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - Stack Advanced 5편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---stack-advanced-5%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#재활용-할-수-있는-cdk-모듈-생성하기---stack-advanced-5편"
  },"98": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - Stack Advanced 5편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. BaseStack 활용하기 | 3. CfnIncludeStack 클래스 . | 3.1 onLoadTemplateProps 메소드 | 3.2 onPostConstructor 메서드 | 3.3 loadTemplate 메서드 | 3.4 사용 예제 | . | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#목차"
  },"99": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "글을 쓴 배경",
    "content": "이 글은 AWS CDK를 사용하여 재사용 가능한 모듈 구조를 작성하는 방법을 설명하기 위해 작성되었습니다. stack 배포, infra 및 lib 디렉토리 역할, 사용법을 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#글을-쓴-배경"
  },"100": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "글 요약",
    "content": "이 글에서는 CDK 프로젝트의 진입점인 stack custom interface인 base-stack 인터페이스와 bin 디렉토리의 역할을 설명하고, CDK 컨텍스트 값이 무엇인지, 어떻게 사용되는지에 대해 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#글-요약"
  },"101": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#시작하기-전"
  },"102": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#1-프로젝트-구조"
  },"103": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "2. BaseStack 활용하기",
    "content": "기존 사용되고 있는 BaseStack의 주요 역할은 스택별 공통 설정 기능을 제공합니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#2-basestack-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#2-basestack-활용하기"
  },"104": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "3. CfnIncludeStack 클래스",
    "content": "CfnIncludeStack 클래스는 BaseStack을 확장하여 CloudFormation 템플릿을 포함하고, 이를 기반으로 스택을 구성하는 예제입니다. import * as cfn_inc from 'aws-cdk-lib/cloudformation-include'; import * as base from './base-stack'; import { AppContext } from '../../../app-context'; export interface CfnTemplateProps { templatePath: string; parameters?: any; } export abstract class CfnIncludeStack extends base.BaseStack { private cfnTemplate?: cfn_inc.CfnInclude; abstract onLoadTemplateProps(): CfnTemplateProps | undefined; abstract onPostConstructor(cfnTemplate?: cfn_inc.CfnInclude): void; constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); const props = this.onLoadTemplateProps(); if (props != undefined) { this.cfnTemplate = this.loadTemplate(props); } else { this.cfnTemplate = undefined; } this.onPostConstructor(this.cfnTemplate); } private loadTemplate(props: CfnTemplateProps): cfn_inc.CfnInclude { const cfnTemplate = new cfn_inc.CfnInclude(this, 'cfn-template', { templateFile: props.templatePath, }); if (props.parameters != undefined) { for (let param of props.parameters) { const paramEnv = cfnTemplate.getParameter(param.Key); paramEnv.default = param.Value; } } return cfnTemplate; } } . 3.1 onLoadTemplateProps 메소드 . 이 추상 메서드는 사용자가 CloudFormation 템플릿 경로와 필요한 매개변수를 제공하도록 합니다. 사용자는 이 메서드를 구현하여 필요한 설정을 반환해야 합니다. 3.2 onPostConstructor 메서드 . 이 추상 메서드는 스택 생성 후 추가적인 설정을 수행하기 위해 사용됩니다. 사용자는 이 메서드를 구현하여 스택 생성 후 필요한 작업을 정의할 수 있습니다. 3.3 loadTemplate 메서드 . 이 메서드는 CloudFormation 템플릿을 로드하고, 필요한 경우 매개변수를 설정합니다. 3.4 사용 예제 . SampleCfnVpcStack 클래스 . import * as ec2 from 'aws-cdk-lib/aws-ec2'; import * as cfn_inc from 'aws-cdk-lib/cloudformation-include'; import * as base from '../../../lib/template/stack/base/cfn-include-stack'; import { AppContext } from '../../../lib/app-context'; import { Override } from '../../../lib/template/stack/base/base-stack'; import { CfnTemplateProps } from '../../../lib/template/common/interfaces' export class SampleCfnVpcStack extends base.CfnIncludeStack { constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); } @Override onLoadTemplateProps(): CfnTemplateProps | undefined { return { templatePath: this.stackConfig.TemplatePath, parameters: this.stackConfig.Parameters }; } @Override onPostConstructor(cfnTemplate?: cfn_inc.CfnInclude) { const cfnVpc = cfnTemplate?.getResource('VPC') as ec2.CfnVPC; } } . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#3-cfnincludestack-%ED%81%B4%EB%9E%98%EC%8A%A4",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced#3-cfnincludestack-클래스"
  },"105": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack Advanced (5편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack-advanced"
  },"106": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "재활용 할 수 있는 CDK 모듈 생성하기 - Stack 3편",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0---stack-3%ED%8E%B8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#재활용-할-수-있는-cdk-모듈-생성하기---stack-3편"
  },"107": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "목차",
    "content": ". | 재활용 할 수 있는 CDK 모듈 생성하기 - Stack 3편 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 프로젝트 구조 | 2. Stack 이란 | 3. 재사용 가능한 코드를 위한 인터페이스 Stack의 필요성 . | 3.1 base-stack.ts 코드 | 3.1.1 base-stack 기능 1 - 공통 설정 및 기능 중앙 집중화 | 3.1.2 base-stack 기능 2 - 재사용 가능한 헬퍼 메소드 제공 | 3.1.3 base-stack 기능 3 - 코드 가독성 및 유지보수 향상 | . | 4. base-stack을 이용한 실제 스택 구현 코드 상세 설명 (CodeBuildSimplePatternStack) . | 4.1 부모 객체 초기화 | 4.2 BaseStack 클래스 | 4.3 CodeBuildSimplePattern 인스턴스 생성 | . | . | . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#목차"
  },"108": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "글을 쓴 배경",
    "content": "이 글은 AWS CDK를 사용하여 재사용 가능한 모듈 구조를 작성하는 방법을 설명하기 위해 작성되었습니다. stack 배포, 및 사용법을 다룹니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#글을-쓴-배경"
  },"109": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#글-요약"
  },"110": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "시작하기 전",
    "content": "이 글을 읽기 전 재활용 할 수 있는 CDK 모듈 생성하기을 우선 읽어주시길 바랍니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#시작하기-전"
  },"111": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "1. 프로젝트 구조",
    "content": "├── README.md ├── bin │ └── app.ts ├── cdk.context.json ├── cdk.json ├── config │ └── sample-pattern-config.json ├── infra │ ├── pattern │ │ ├── cloudwatch │ │ │ └── cloudwatch-simple-pattern.ts │ │ ├── codebuild │ │ │ ├── codebuild-pol.json │ │ │ └── codebuild-simple-pattern.ts │ │ ├── codedeploy │ │ │ ├── codedeploy-pol.json │ │ │ └── codedeploy-simple-pattern.ts │ │ └── s3 │ │ └── s3-check-pattern.ts │ └── stack │ ├── cfn-template │ │ └── sample-cfn-vpc.yaml │ ├── codebuild │ │ ├── codebuild-simple-pattern-stack.ts │ │ ├── codebuild-stack.ts │ ├── codecommit │ │ ├── codecommit-stack.d.ts │ │ └── codecommit-stack.ts │ ├── codedeploy │ │ ├── codedeploy-simple-pattern-stack.ts │ │ └── codedeploy-stack.ts │ ├── iam │ │ ├── codebuild-pol.json │ │ ├── codedeploy-pol.json │ │ └── iam-stack.ts │ └── vpc │ └── sample-cfn-vpc-stack.ts ├── jest.config.js ├── lib │ ├── app-config.ts │ ├── app-context.ts │ └── template │ ├── common │ │ ├── common-guardian.ts │ │ └── common-helper.ts │ ├── construct │ │ └── base │ │ └── base-construct.ts │ └── stack │ ├── base │ │ ├── base-stack.d.ts │ │ ├── base-stack.js │ │ ├── base-stack.ts │ │ ├── cfn-include-stack.d.ts │ │ ├── cfn-include-stack.js │ │ ├── cfn-include-stack.ts │ │ ├── vpc-base-stack.d.ts │ │ ├── vpc-base-stack.js │ │ └── vpc-base-stack.ts ├── package-lock.json ├── package.json ├── script │ ├── db │ │ └── database_helloworld.sql │ ├── deploy_stacks.sh │ ├── destroy_stacks.sh │ └── setup_initial.sh ├── setup_initial.sh └── tsconfig.json . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#1-프로젝트-구조"
  },"112": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "2. Stack 이란",
    "content": ". AWS Cloud Development Kit (AWS CDK) 스택은 리소스를 정의하는 하나 이상의 Construct의 모음입니다. 각 CDK 스택은 AWS CloudFormation 스택을 나타내며, 배포 시 스택 내의 리소스는 하나의 단위로 프로비저닝됩니다. 스택은 앱 내에서 정의되며, AWS CDK Stack 클래스를 사용하여 정의됩니다. ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#2-stack-%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#2-stack-이란"
  },"113": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "3. 재사용 가능한 코드를 위한 인터페이스 Stack의 필요성",
    "content": "cdk.Stack 클래스를 직접 사용할 수도 있지만, 프로젝트 복잡해질수록 코드의 중복을 줄이고 일관성을 유지하는 것이 필요합니다. 이러한 이유로 lib/template/stack/base-stack.ts 와 같은 재사용 가능한 베이스 스택을 정의하는 인터페이스를 도입하였습니다. 3.1 base-stack.ts 코드 . import * as cdk from 'aws-cdk-lib'; import * as s3 from 'aws-cdk-lib/aws-s3' import { AppContext } from '../../../app-context' import { AppConfig, StackConfig } from '../../../app-config' import { CommonHelper, ICommonHelper } from '../../common/common-helper' import { CommonGuardian, ICommonGuardian } from '../../common/common-guardian' export function Override(target: any, propertyKey: string, descriptor: PropertyDescriptor){} // 클래스 내에서 일반적으로 사용되는 기본 스택 설정을 정의합니다. // 이 설정은 애플리케이션 전체에서 공통적으로 사용될 기본 값들을 포함하며, // 일반적으로 애플리케이션 시작 시 한 번 로드되어 여러 스택에 걸쳐 재사용됩니다. export interface StackCommonProps extends cdk.StackProps { // 리소스 명명 시 사용 projectPrefix: string; appConfig: AppConfig; appConfigPath: string; // 스택 생성 시 필요한 변수 목록 variables: any; } export class BaseStack extends cdk.Stack implements ICommonHelper, ICommonGuardian { protected stackConfig: StackConfig; protected projectPrefix: string; protected commonProps: StackCommonProps; private commonHelper: ICommonHelper; private commonGuardian: ICommonGuardian; constructor(appContext: AppContext, stackConfig: any) { console.log(\"Received stackConfig:\", stackConfig); let newProps = BaseStack.getStackCommonProps(appContext, stackConfig); // 스택 명칭 정하는 곳 super(appContext.cdkApp, stackConfig.StackName, newProps); this.stackConfig = stackConfig; this.commonProps = newProps; // 현재 projectPrefix 설정 내용 `${projectName}-${projectStage}`; this.projectPrefix = appContext.stackCommonProps.projectPrefix; this.commonHelper = new CommonHelper({ construct: this, env: this.commonProps.env!, stackName: this.stackName, projectPrefix: this.projectPrefix, variables: this.commonProps.variables }); this.commonGuardian = new CommonGuardian({ construct: this, env: this.commonProps.env!, stackName: this.stackName, projectPrefix: this.projectPrefix, variables: this.commonProps.variables }); } private static getStackCommonProps(appContext: AppContext, stackConfig: any): StackCommonProps{ // 특정 스택 인스턴스에 대한 설정을 수정하거나 확장할 때 사용됩니다. // 예를 들어, 특정 스택이 다른 리전에 배포되어야 하거나 특별한 환경 변수가 필요한 경우, // newProps는 이러한 요구 사항에 맞추어 조정될 수 있습니다. // 이는 BaseStack.getStackCommonProps 함수를 통해 appContext의 stackCommonProps를 기반으로 생성되지만, // stackConfig에 따라 일부 속성이 변경되거나 추가될 수 있습니다. let newProps = appContext.stackCommonProps; if (stackConfig.UpdateRegionName) { console.log(`[INFO] Region is updated: ${stackConfig.Name} -&gt;&gt; ${stackConfig.UpdateRegionName}`); newProps = { ...appContext.stackCommonProps, env: { region: stackConfig.UpdateRegionName, account: appContext.appConfig.Project.Account } }; } else { console.log('not update region') } return newProps; } // ... } . 3.1.1 base-stack 기능 1 - 공통 설정 및 기능 중앙 집중화 . 앱 내의 여러 스택에서 공통적으로 사용되는 설정과 기능을 중앙에서 관리할 수 있습니다. 이를 통해 모든 스택이 일관된 설정을 가질 수 있도록 합니다. BaseStack 클래스에 있는 StackCommonProps 인터페이스는 스택을 생성할 때 필요한 공통 속성을 정의합니다. 해당 속성은 앞서 설명한 AppContext 클래스에서 불러온 설정파일을 통해 구성되게 됩니다. 재활용 할 수 있는 CDK 모듈 생성하기 - app, context 2편 . export interface StackCommonProps extends cdk.StackProps { projectPrefix: string; appConfig: AppConfig; appConfigPath: string; variables: any; } . 3.1.2 base-stack 기능 2 - 재사용 가능한 헬퍼 메소드 제공 . 스택에서 자주 사용되는 기능을 헬퍼 메서드로 정의해 두면 각 스택에서 이를 재 사용할 수 있게 됩니다. 자세한 메서드 구현은 lib/template/common/common-helper.ts 에 구현되어있습니다. export class BaseStack extends cdk.Stack implements ICommonHelper, ICommonGuardian { // ... other methods ... findEnumType&lt;T extends object&gt;(enumType: T, target: string): T[keyof T] { return this.commonHelper.findEnumType(enumType, target); } exportOutput(key: string, value: string, prefixEnable=true, prefixCustomName?: string) { this.commonHelper.exportOutput(key, value, prefixEnable, prefixCustomName); } putParameter(paramKey: string, paramValue: string, prefixEnable=true, prefixCustomName?: string): string { return this.commonHelper.putParameter(paramKey, paramValue, prefixEnable, prefixCustomName); } // ... other methods ... } . 3.1.3 base-stack 기능 3 - 코드 가독성 및 유지보수 향상 . 공통된 로직을 baseStack에 정의함으로써 각 스택 파일이 간결해지게 됩니다. 아래는 실제 codebuild 배포 스택입니다. import * as base from '../../../lib/template/stack/base/base-stack'; import { AppContext } from '../../../lib/app-context'; import * as codebuild from \"../../pattern/codebuild/codebuild-simple-pattern\"; export class CodeBuildSimplePatternStack extends base.BaseStack { private simpleCodeBuild: codebuild.CodeBuildSimplePattern; public onPostConstructor(codebuild: codebuild.CodeBuildSimplePattern): void {} constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); // Initialize CodeBuildSimplePattern this.simpleCodeBuild = new codebuild.CodeBuildSimplePattern(this, 'CodeBuildSimplePattern', { stackName: this.stackName, projectPrefix: this.projectPrefix, env: this.commonProps.env!, stackConfig: stackConfig, variables: this.commonProps.variables, }); this.onPostConstructor(this.simpleCodeBuild); } } . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#3-%EC%9E%AC%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-stack%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#3-재사용-가능한-코드를-위한-인터페이스-stack의-필요성"
  },"114": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "4. base-stack을 이용한 실제 스택 구현 코드 상세 설명 (CodeBuildSimplePatternStack)",
    "content": "CodeBuildSimplePatternStack 클래스는 BaseStack을 상속받아 AWS CodeBuild 프로젝트를 정의합니다. 4.1 부모 객체 초기화 . CodeBuildSimplePatternStack 클래스의 constructor에서 가장 먼저 부모 클래스(BaseStack)를 초기화합니다. infra/stack/codebuild/codebuild-simple-pattern-stack.ts . import { AppContext } from '../../lib/app-context'; import { BaseStack } from '../../lib/template/stack/base/base-stack'; export class CodeBuildSimplePatternStack extends BaseStack { constructor(appContext: AppContext, stackConfig: any) { super(appContext, stackConfig); // 추가 초기화 작업 수행 } // ... } . 4.2 BaseStack 클래스 . 마찬가지로 BaseStack 클래스는 cdk.Stack 클래스를 상속받아 구현되었습니다. 아래는 cdk.Stack 클래스의 constructor 정의 입니다. | scope: 스택의 상위 컨텍스트를 나타냅니다. 보통은 App 또는 Stage이지만, 다른 Construct도 될 수 있습니다. | id: 스택의 고유 식별자입니다. 이 값이 스택의 물리적 ID를 결정하는 데 사용됩니다. | props: 스택 속성을 포함하는 객체입니다. 여기에는 스택의 환경 설정, 설명, 태그 등이 포함될 수 있습니다. | . aws-cdk-lib/stack.d.ts . /** * Creates a new stack. * * @param scope Parent of this stack, usually an `App` or a `Stage`, but could be any construct. * @param id The construct ID of this stack. If `stackName` is not explicitly * defined, this id (and any parent IDs) will be used to determine the * physical ID of the stack. * @param props Stack properties. */ constructor(scope?: Construct, id?: string, props?: StackProps) { // CDK 애플리케이션에 스택을 등록하고 초기화 작업을 수행 } . 4.3 CodeBuildSimplePattern 인스턴스 생성 . BaseStack 클래스는 StackCommonProps 인터페이스를 사용하여 공통 속성을 정의하고, 정의된 속성을 이용해 CodeBuildSimplePattern 인스턴스를 만듭니다. 이 과정을 통해 각 스택은 일관된 설정을 가지게 됩니다. infra/stack/codebuild/codebuild-simple-pattern-stack.ts . // Initialize CodeBuildSimplePattern this.simpleCodeBuild = new codebuild.CodeBuildSimplePattern(this, 'CodeBuildSimplePattern', { stackName: this.stackName, projectPrefix: this.projectPrefix, env: this.commonProps.env!, stackConfig: stackConfig, variables: this.commonProps.variables, }); . ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack#4-base-stack%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%A4%EC%A0%9C-%EC%8A%A4%ED%83%9D-%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C-%EC%83%81%EC%84%B8-%EC%84%A4%EB%AA%85-codebuildsimplepatternstack",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack#4-base-stack을-이용한-실제-스택-구현-코드-상세-설명-codebuildsimplepatternstack"
  },"115": {
    "doc": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "title": "2-1. TypeScript CDK로 재사용가능한 모듈 구조 작성하기 - Stack (3편)",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK/cdk-module-stack",
    
    "relUrl": "/docs/02_Tech/CICD/CDK/cdk-module-stack"
  },"116": {
    "doc": "6. CDK",
    "title": "CDK 란",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK#cdk-%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#cdk-란"
  },"117": {
    "doc": "6. CDK",
    "title": "목차",
    "content": ". | CDK 란 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 재활용 할 수 있는 CDK 모듈 생성하기 . | 1.1 기본 원칙 | . | 2. 디렉토리 구조 . | 2.1 config | 2.2 lib/template | 2.3 script | . | 2. Bamboo 시작 | 3. Bamboo 체험판 라이센스 받기 | 4. Configure Bamboo . | 4.1 Configure instance | . | . | . ",
    "url": "/docs/02_Tech/CICD/CDK#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#목차"
  },"118": {
    "doc": "6. CDK",
    "title": "글을 쓴 배경",
    "content": "친숙한 프로그래밍 언어로 클라우드 애플리케이션 리소스를 프로비저닝 할 수 있는 프레임 워크를 찾던 중 선택하게 되었습니다. ",
    "url": "/docs/02_Tech/CICD/CDK#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#글을-쓴-배경"
  },"119": {
    "doc": "6. CDK",
    "title": "글 요약",
    "content": "개발자는 재사용 가능한 클라우드 구성 요소인 Constructs를 정의하고 이를 Stacks과 Apps로 구성할 수 있습니다. 주요 개념 . | Constructs: 재사용 가능한 클라우드 구성 요소. | Stacks: 논리적 단위의 배포 모델을 정의. | Apps: Stacks로 구성된 애플리케이션. | . 논리적 단위 . CDK 애플리케이션은 API, 데이터베이스, 모니터링 리소스와 같은 논리적 단위로 구성되어야 합니다. 이러한 단위는 Constructs로 구현되며 다음을 포함할 수 있습니다: . | 인프라: Amazon S3 버킷, Amazon RDS 데이터베이스, Amazon VPC 네트워크 등. | 런타임 코드: AWS Lambda 함수. | 구성 코드: 구성 스크립트 및 설정. | . ",
    "url": "/docs/02_Tech/CICD/CDK#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#글-요약"
  },"120": {
    "doc": "6. CDK",
    "title": "시작하기 전",
    "content": ". | 사용한 언어 : TypeScript ~5.2.2 | aws-cdk : 2.126.0 | . ",
    "url": "/docs/02_Tech/CICD/CDK#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#시작하기-전"
  },"121": {
    "doc": "6. CDK",
    "title": "1. 재활용 할 수 있는 CDK 모듈 생성하기",
    "content": "1.1 기본 원칙 . 개발 협업: 프로젝트 디렉토리를 역할에 따라 구성하여 협업이 용이하도록 합니다. 다중 대상 배포: 코드와 설정을 분리하여 다양한 AWS 계정/지역으로 자유롭게 배포할 수 있습니다. 스택 독립성: 스택 간 종속성을 관리하여 독립적인 배포가 가능하도록 합니다. 코드 재사용: 자주 사용되는 작업을 프레임워크로 추상화하고 쉽게 재사용할 수 있도록 합니다. ",
    "url": "/docs/02_Tech/CICD/CDK#1-%EC%9E%AC%ED%99%9C%EC%9A%A9-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-cdk-%EB%AA%A8%EB%93%88-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#1-재활용-할-수-있는-cdk-모듈-생성하기"
  },"122": {
    "doc": "6. CDK",
    "title": "2. 디렉토리 구조",
    "content": ". 2.1 config . 2.2 lib/template . AWS CDK에서 스택은 AWS 리소스들의 집합으로, 하나의 단위로 배포되거나 관리될 수 있습니다. construct 디렉토리는 CDK의 “컨스트럭트”를 정의하는 곳입니다. 컨스트럭트는 CDK의 기본 빌딩 블록으로, 하나 이상의 AWS 리소스를 캡슐화하고 재사용 가능한 컴포넌트로 만듭니다. 이 디렉토리는 특정 기능을 수행하는 더 작고 관리하기 쉬운 부분으로 리소스를 나누는 데 중점을 둡니다. 기능: 재사용 가능한 코드를 통해 프로젝트 전반에서 일관된 리소스 설정을 보장하고 개발 시간을 줄입니다. common 디렉토리는 프로젝트 전반에서 공통적으로 사용되는 기능이나 유틸리티 함수들을 저장합니다. 이곳에는 프로젝트의 다양한 부분에서 재사용될 수 있는 코드 스니펫, 헬퍼 함수, 설정 파일 등이 포함됩니다. lib/app-context.ts . 애플리케이션 구성과 스택 초기화를 관리 . AppContextError - 사용자 정의 에러 클래스 ProjectPrefix Type 열거형 . icommonGuardian 인터페이스 s3 버킷을 생성하고 관리하는 유틸리티 클래스 . 2.3 script . ",
    "url": "/docs/02_Tech/CICD/CDK#2-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#2-디렉토리-구조"
  },"123": {
    "doc": "6. CDK",
    "title": "2. Bamboo 시작",
    "content": "설치전 java 17 버전임을 확인해주세요. $ cd &lt;Bamboo 설치 디렉토리&gt; $ ./bin/start-bamboo.sh . Bamboo가 시작되면 다음 주소로 접속할 수 있습니다: http://localhost:8085/ . ",
    "url": "/docs/02_Tech/CICD/CDK#2-bamboo-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#2-bamboo-시작"
  },"124": {
    "doc": "6. CDK",
    "title": "3. Bamboo 체험판 라이센스 받기",
    "content": "참고 자료 : Get a Bamboo Data Center trial license . trial license 등록절차 . | my.atlassian.com 로그인 | Product - Bamboo / Organization - Data Center 입력 | Server ID - 앞서 생성한 Bamboo 주소에서 참조 -&gt; http://localhost:8085/ | . 해당 과정이 마무리되면 License Key를 발급받게 됩니다. ",
    "url": "/docs/02_Tech/CICD/CDK#3-bamboo-%EC%B2%B4%ED%97%98%ED%8C%90-%EB%9D%BC%EC%9D%B4%EC%84%BC%EC%8A%A4-%EB%B0%9B%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#3-bamboo-체험판-라이센스-받기"
  },"125": {
    "doc": "6. CDK",
    "title": "4. Configure Bamboo",
    "content": "4.1 Configure instance . Jenkins와 Bamboo는 모두 CI/CD 영역에서 강력한 도구입니다. Jenkins는 오픈 소스로 널리 사용되며, Bamboo는 상업적 라이선스를 가진 도구입니다. Bamboo는 사용자 친화적인 인터페이스와 Atlassian 제품군과의 긴밀한 통합으로 인해 특히 주목받습니다. 반면 Jenkins는 플러그인의 광범위한 지원으로 높은 확장성을 자랑합니다. 참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/CICD/CDK#4-configure-bamboo",
    
    "relUrl": "/docs/02_Tech/CICD/CDK#4-configure-bamboo"
  },"126": {
    "doc": "6. CDK",
    "title": "6. CDK",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CDK",
    
    "relUrl": "/docs/02_Tech/CICD/CDK"
  },"127": {
    "doc": "CICD",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/CICD#color-utilities",
    
    "relUrl": "/docs/02_Tech/CICD#color-utilities"
  },"128": {
    "doc": "CICD",
    "title": "Table of contents",
    "content": ". ",
    "url": "/docs/02_Tech/CICD#table-of-contents",
    
    "relUrl": "/docs/02_Tech/CICD#table-of-contents"
  },"129": {
    "doc": "CICD",
    "title": "CICD",
    "content": " ",
    "url": "/docs/02_Tech/CICD",
    
    "relUrl": "/docs/02_Tech/CICD"
  },"130": {
    "doc": "2. CircleCI",
    "title": "Circle CI",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CircleCI#circle-ci",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI#circle-ci"
  },"131": {
    "doc": "2. CircleCI",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. CircleCI의 주요 기능 | 2. CircleCI 사용 . | 2.1 지원되는 Git Repository | 2.2 프로젝트 추가 | 2.3 구성 파일 생성 | 2.4 구성 파일 상세 설명 . | 2.4.1 Jobs | 2.4.2 Build | 2.4.3 Deploy | 2.4.4 workflows | 2.4.5 CircleCI 콘솔 확인 | 2.4.6 CircleCI에서 AWS 자격증명 설정하기 | 2.4.7 deploy 결과 s3에서 확인하기 | 2.4.8 S3 버킷 웹페이지 활성화하기 | 2.4.9 실제 웹페이지 확인 | . | 3. Orbs 사용하기 . | 3.1 Orbs 사용 이유 | 3.2 Orbs 사용 방법 | 3.3 사용할 수 있는 Orbs 예시 | 3.4 aws orbs 적용 | 3.5 aws orbs 배포 확인 | . | . | . ",
    "url": "/docs/02_Tech/CICD/CircleCI#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI#목차"
  },"132": {
    "doc": "2. CircleCI",
    "title": "글을 쓴 배경",
    "content": "표준화 부족,레거시 기술의 복잡성,비효율적인 수작업 등이 엔터프라이즈 환경의 문제점으로 지적되었습니다. 이를 해결하기 위해 개발자 플랫폼을 통해 표준화된 도구와 기술 스택 제공의 필요성이 대두되었습니다. 이에 따라 CircleCI를 CI/CD 도구로 선택하고 가이드를 작성하게 되었습니다. 참고 연설 : Platform as Code: Simplifying developer platform design with reference architectures . ",
    "url": "/docs/02_Tech/CICD/CircleCI#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI#글을-쓴-배경"
  },"133": {
    "doc": "2. CircleCI",
    "title": "글 요약",
    "content": "이 가이드에서는 CI/CD 프로세스 자동화를 위한 구성 파일과 Orbs를 통한 써드 파티 통합을 설명하며, 최종적으로 정적 웹페이지 어플리케이션을 구성하는 방법을 소개합니다. ",
    "url": "/docs/02_Tech/CICD/CircleCI#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI#글-요약"
  },"134": {
    "doc": "2. CircleCI",
    "title": "시작하기 전",
    "content": ". | GitHub 계정 | CircleCI 계정 | . ",
    "url": "/docs/02_Tech/CICD/CircleCI#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI#시작하기-전"
  },"135": {
    "doc": "2. CircleCI",
    "title": "1. CircleCI의 주요 기능",
    "content": ". | 자동화: 코드의 빌드, 테스트, 배포 전체 CI/CD 프로세스를 자동화합니다. | 커스터마이징: YAML 파일을 통해 작업, 워크플로우, 단계를 구성하여 프로젝트 요구사항에 맞게 커스터마이징할 수 있습니다. | Orbs: 타사 도구 및 서비스와의 통합을 간소화하는 재사용 가능한 YAML 구성 패키지입니다. | 병렬 처리: 여러 작업을 병렬로 실행하여 CI/CD 파이프라인을 가속화할 수 있습니다. | SSH 디버깅: SSH를 사용하여 작업을 다시 실행할 수 있어 심층 디버깅이 가능합니다. | 환경 유연성: 다양한 운영 체제 및 커스텀 Docker 이미지를 지원하여 빌드 환경의 유연성을 제공합니다. | . ",
    "url": "/docs/02_Tech/CICD/CircleCI#1-circleci%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI#1-circleci의-주요-기능"
  },"136": {
    "doc": "2. CircleCI",
    "title": "2. CircleCI 사용",
    "content": "2.1 지원되는 Git Repository . | GitLab | GitHub | Bitbucket | . 2.2 프로젝트 추가 . CircleCI 대시보드에서 배포할 저장소를 선택한 후 프로젝트를 추가할 수 있습니다. 참고 코드 : https://github.com/AmanPathak-DevOps/CircleCI-ReactJS.git . 2.3 구성 파일 생성 . repository에 .circleci 폴더를 생성하고 config.yml 파일을 추가하세요. 기본 구성 예시 . Node.js 가 포함된 도커 이미지환경에서 코드를 체크아웃하고, 종속성을 설치하는 구성 파일입니다. version: 2.1 jobs: build: docker: - image: circleci/node:latest steps: - checkout - run: name: Install Dependencies command: npm install - run: name: Run Tests command: npm test workflows: version: 2 build_and_test: jobs: - build . CircleCI 구성 추가 예시 . 특정 브랜치의 변경 사항을 AWS S3 버킷에 배포하는 과정을 자동화 한 구성 파일입니다. version: 2.1 jobs: # Builing the project is going to start build: # working_directory: ~/repo machine: image: ubuntu-2004:202010-01 docker_layer_caching: true steps: - checkout # - run: # name: Installing AWS CLI # command: | # sudo apt-get update # sudo apt install python3-pip # sudo pip3 install awsebcli --upgrade - run: cd ./app &amp;&amp; npm install &amp;&amp; npm run build - persist_to_workspace: root: . paths: - . # Deploying the code to AWS S3 Bucket deploy: # working_directory: ~/repo machine: image: ubuntu-2004:202010-01 docker_layer_caching: true steps: - attach_workspace: at: . - checkout - run: name: Check Env command: | echo \"AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID\" echo \"AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY\" - run: name: Configuring AWS command: | aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY aws configure set default.region ap-northeast-2 - run: name: Deploying to S3 command: | if [ $CIRCLE_BRANCH = 'master' ]; then aws s3 sync ./app/build s3://kkm-s3/ fi workflows: version: 2 execute_bulk: jobs: - build - deploy: requires: - build filters: branches: only: - master . 2.4 구성 파일 상세 설명 . 2.4.1 Jobs . | jobs 섹션은 CircleCI에서 실행할 개별 작업을 정의합니다. 각 작업을 통해 빌드, 테스트, 배포등의 작업을 수행할 수 있습니다. | . 2.4.2 Build . | 빌드 작업을 실행할 이미지를 지정할 수 있습니다. | docker_layer_caching: true옵션을 통해 Docker 레이어 캐싱을 활성화하여 빌드 속도를 높일 수 있습니다. | . build: # working_directory: ~/repo machine: image: ubuntu-2004:202010-01 docker_layer_caching: true . | steps 를 통해 작업에서 수행할 단계 목록을 정의할 수 있습니다. | 어플리케이션 디렉토리로 이동하여 종속성을 설치하고 빌드합니다. | . build: steps: - checkout - run: cd ./app &amp;&amp; npm install &amp;&amp; npm run build - persist_to_workspace: root: . paths: - . | persist_to_workspace 빌드 결과를 작업 공간에 저장하여 이후 작업에서 사용할 수 있도록 합니다. | 현재 구성에서는 빌드 결과가 포함된 모든 파일과 디렉토리가 다음 step에서 사용될 수 있도록 저장된다는 의미입니다. | . - persist_to_workspace: root: . paths: - . 2.4.3 Deploy . | deploy step에서 빌드 결과를 AWS S3 버킷에 배포하는 작업을 수행합니다. | attach_workspace를 통해 이전 작업의 작업 공간을 연결하여 빌드 결과를 사용할 수 있습니다. | . steps: - attach_workspace: at: . - checkout - run: name: Configuring AWS command: | if [ $CIRCLE_BRANCH = 'master' ]; then aws s3 sync ./app/build s3://kkm-s3/ fi . 2.4.4 workflows . | 여러 작업을 조합하여 빌드 파이프라인을 정의할 수 있습니다. | workflow 하위의 execute_bulk는 단순 워크 플로우 이름입니다. | 빌드 작업 실행 후 deploy 작업이 실행됩니다. deploy 작업은 오직 master 브랜치에서만 실행되도록 필터링 되어있습니다. | . workflows: version: 2 execute_bulk: jobs: - build - deploy: requires: - build filters: branches: only: - master . 2.4.5 CircleCI 콘솔 확인 . master 브랜치에 push 했을 때는 deploy 작업이 추가로 수행된 것을 확인할 수 있습니다. 2.4.6 CircleCI에서 AWS 자격증명 설정하기 . 프로젝트 설정의 환경 변수 부분에서 AWS 자격증명을 등록해줍니다. 2.4.7 deploy 결과 s3에서 확인하기 . 2.4.8 S3 버킷 웹페이지 활성화하기 . | s3 버킷 내에 정적 웹 사이트 호스팅을 활성화 합니다. | 버킷 퍼블릭 액세스를 허용합니다. | ACL 없이 공개 접근을 허용합니다. | 버킷 정책을 수정합니다. | . 2.4.9 실제 웹페이지 확인 . 3. Orbs 사용하기 . Orbs는 CircleCI의 독특한 기능으로, 써드 파티 도구와의 통합을 쉽게 할 수 있는 재사용 가능한 YAML 구성 패키지입니다. 3.1 Orbs 사용 이유 . 프로젝트 구성 시간 절약: 반복적인 설정 작업을 단순화하여 프로젝트 구성 시간을 줄여줍니다. 효율성 증가: 여러 프로젝트에서 공통으로 사용하는 설정을 Orbs로 정의하여 효율성을 높입니다. 써드 파티 통합 간소화: Orbs를 사용하면 다양한 써드 파티 도구와의 통합이 쉬워집니다. 3.2 Orbs 사용 방법 . 기존 Orbs 사용: CircleCI Orbs 레지스트리에서 원하는 Orbs의 설정 코드를 복사하여 사용합니다. Orbs 직접 생성: 필요에 맞는 Orbs가 없는 경우, CircleCI의 베스트 프랙티스와 시작 가이드를 참고하여 직접 Orbs를 생성할 수 있습니다. 3.3 사용할 수 있는 Orbs 예시 . | Slack | AWS | Microsoft | Atlassian | . CircleCI Orbs 레지스트리 화면 . 3.4 aws orbs 적용 . 관련 orbs 문서 : Orbs/circleci/aws-cli@4.1.3 . version: 2.1 orbs: aws-cli: circleci/aws-cli@4.1.3 jobs: # Builing the project is going to start build: # working_directory: ~/repo machine: image: ubuntu-2004:202010-01 docker_layer_caching: true steps: - checkout - run: cd ./app &amp;&amp; npm install &amp;&amp; npm run build - persist_to_workspace: root: . paths: - . # Deploying the code to AWS S3 Bucket deploy: # working_directory: ~/repo machine: image: ubuntu-2004:202010-01 docker_layer_caching: true steps: - attach_workspace: at: . - checkout - aws-cli/setup: profile_name: mzc-pops-cnp aws_access_key_id: AWS_ACCESS_KEY_ID aws_secret_access_key: AWS_SECRET_ACCESS_KEY region: ap-northeast-2 - run: name: Check AWS Configuration command: | aws configure list aws sts get-caller-identity - run: name: Deploying to S3 command: | if [ $CIRCLE_BRANCH = 'master' ]; then aws s3 sync ./app/build s3://web-bucket-kkm/ fi workflows: version: 2 execute_bulk: jobs: - build - deploy: requires: - build filters: branches: only: - master . 3.5 aws orbs 배포 확인 . | aws orbs를 사용하면 AWS CLI 를 설치하고 aws configure을 간소화 할 수 있습니다. | . | aws configuration 적용된 모습 | . ",
    "url": "/docs/02_Tech/CICD/CircleCI#2-circleci-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI#2-circleci-사용"
  },"137": {
    "doc": "2. CircleCI",
    "title": "2. CircleCI",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CircleCI",
    
    "relUrl": "/docs/02_Tech/CICD/CircleCI"
  },"138": {
    "doc": "CKA",
    "title": "CKA Certification",
    "content": " ",
    "url": "/docs/02_Tech/IAC#cka-certification",
    
    "relUrl": "/docs/02_Tech/IAC#cka-certification"
  },"139": {
    "doc": "CKA",
    "title": "Table of contents",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 쿠버네티스 (Kubernetes)란 무엇인가? | 2. 쿠버네티스의 구성 요소 | 3. 쿠버네티스의 도전 과제 | 4. Borg의 유산 | 5. 쿠버네티스 아키텍처 | 6. 쿠버네티스 용어 정리 | 7. 쿠버네티스의 혁신 | 9. 쿠버네티스 툴 | 10. 실습 | 11. 설치 도구 | 12. Kubectl 설치 | . ",
    "url": "/docs/02_Tech/IAC#table-of-contents",
    
    "relUrl": "/docs/02_Tech/IAC#table-of-contents"
  },"140": {
    "doc": "CKA",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/IAC#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/IAC#글을-쓴-배경"
  },"141": {
    "doc": "CKA",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/IAC#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/IAC#글-요약"
  },"142": {
    "doc": "CKA",
    "title": "시작하기 전",
    "content": ". ",
    "url": "/docs/02_Tech/IAC#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/IAC#시작하기-전"
  },"143": {
    "doc": "CKA",
    "title": "1. 쿠버네티스 (Kubernetes)란 무엇인가?",
    "content": "로컬 컴퓨터에서 컨테이너를 실행하는 것은 비교적 간단합니다. 그러나 여러 호스트에 걸쳐 컨테이너를 연결하고, 확장하며, 다운타임 없이 애플리케이션을 배포하고, 관리하는 것은 어려운 일입니다. 쿠버네티스는 이러한 문제들을 해결해주는 강력한 도구입니다. 쿠버네티스는 처음부터 이러한 문제들을 해결하기 위해 설계된 기본 요소들과 확장 가능한 API를 제공합니다. 새로운 객체와 컨트롤러를 추가할 수 있는 능력 덕분에 다양한 요구 사항에 맞게 쉽게 커스터마이징할 수 있습니다. 쿠버네티스 공식 웹사이트에 따르면, 쿠버네티스는 다음과 같이 정의됩니다 . “an open-source software for automating deployment, scaling, and management of containerized applications.” . 쿠버네티스는 Google에서의 15년간의 경험을 바탕으로 개발되었습니다. Google은 ‘borg’라는 프로젝트에서 얻은 경험을 바탕으로 쿠버네티스를 만들었습니다. Google의 인프라는 데이터센터에서 가상 머신이 널리 사용되기 전부터 고도의 확장을 시작했으며, 컨테이너는 클러스터를 효율적으로 운영하기 위한 세밀한 솔루션을 제공했습니다. 클러스터의 효율적 사용과 분산 애플리케이션 관리는 Google의 핵심 과제 중 하나였습니다. 그리스어로 ‘κνβερνητης’는 배의 키잡이 또는 조타수를 의미합니다. 컨테이너의 해양 테마를 유지하며, 쿠버네티스는 컨테이너의 배의 조타수 역할을 합니다. 이름을 발음하기 어렵기 때문에 많은 사람들이 쿠버네티스의 K와 S 사이에 8개의 글자가 있다는 이유로 ‘K8s’라는 별명을 사용합니다. 쿠버네티스는 이렇게 복잡한 컨테이너 환경을 효과적으로 관리하고, 자동화하며, 확장할 수 있게 도와주는 강력한 도구입니다. ",
    "url": "/docs/02_Tech/IAC#1-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-kubernetes%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80",
    
    "relUrl": "/docs/02_Tech/IAC#1-쿠버네티스-kubernetes란-무엇인가"
  },"144": {
    "doc": "CKA",
    "title": "2. 쿠버네티스의 구성 요소",
    "content": "컨테이너를 배포하고 쿠버네티스를 사용하는 것은 애플리케이션 배포에 대한 개발 및 시스템 관리 접근 방식을 변화시킬 수 있습니다. 전통적인 환경에서는 애플리케이션이 전용 서버에 배치되는 모놀리식 애플리케이션이었습니다. 웹 트래픽이 증가함에 따라 애플리케이션이 조정되고, 더 큰 하드웨어로 이동될 수 있습니다. 몇 년 후에는 현재의 웹 트래픽 요구를 충족시키기 위해 많은 커스터마이징이 이루어졌을 것입니다. 쿠버네티스는 큰 서버 대신 다수의 작은 서버, 즉 마이크로서비스를 배포함으로써 동일한 문제에 접근합니다. 애플리케이션의 서버 및 클라이언트 측은 많은 에이전트가 요청에 응답할 수 있다는 것을 예상하도록 작성됩니다. 또한, 클라이언트는 서버 프로세스가 종료되고 교체될 수 있다는 점을 예상해야 하며, 이는 일시적인 서버 배포로 이어집니다. 많은 httpd 데몬이 페이지 요청에 응답하는 큰 Apache 웹 서버 대신, 여러 대의 nginx 서버가 각각 응답하게 됩니다. 작은 서비스의 일시적인 특성은 디커플링(Decoupling)도 가능하게 합니다. 전통적인 애플리케이션의 각 측면은 전용이지만 일시적인 마이크로서비스나 에이전트로 대체됩니다. 이러한 에이전트나 그 대체품을 결합하기 위해 우리는 서비스를 사용합니다. 서비스는 한 에이전트에서 다른 에이전트(예: 프론트엔드 웹 서버에서 백엔드 데이터베이스로)의 트래픽을 연결하고, 어느 하나가 종료되고 교체될 경우 새로운 IP나 기타 정보를 처리합니다. 통신은 전적으로 API 호출을 통해 이루어지며, 이를 통해 유연성을 제공합니다. 클러스터 구성 정보는 etcd 내부에 JSON 형식으로 저장되지만, 커뮤니티에서는 대부분 YAML로 작성됩니다. 쿠버네티스 에이전트는 YAML을 JSON으로 변환한 후 데이터베이스에 저장합니다. 쿠버네티스를 통해 애플리케이션을 더 효율적이고 유연하게 관리할 수 있으며, 다양한 마이크로서비스를 통해 확장성과 유지보수성을 높일 수 있습니다. Kubernetes의 이러한 특성은 현대 애플리케이션 배포에 매우 유용합니다. ",
    "url": "/docs/02_Tech/IAC#2-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C",
    
    "relUrl": "/docs/02_Tech/IAC#2-쿠버네티스의-구성-요소"
  },"145": {
    "doc": "CKA",
    "title": "3. 쿠버네티스의 도전 과제",
    "content": "컨테이너는 애플리케이션을 패키징하고 배포하며 실행하는 데 매우 유용한 방법을 제공합니다. 이는 Docker의 모토이기도 합니다. 컨테이너 덕분에 개발자 경험은 크게 향상되었습니다. 특히 Docker는 컨테이너 이미지를 쉽게 빌드하고, 레지스트리를 통해 이미지를 간단히 공유하며, 컨테이너를 관리할 수 있는 강력한 사용자 경험을 제공함으로써 개발자에게 큰 힘이 되었습니다. 하지만, 컨테이너를 대규모로 관리하고 마이크로서비스 원칙에 기반한 분산 애플리케이션을 설계하는 것은 도전 과제가 될 수 있습니다. | CI/CD 파이프라인 설정 | . 첫 번째 현명한 단계는 CI/CD(지속적 통합/지속적 배포) 파이프라인을 결정하는 것입니다. 이는 컨테이너 이미지를 빌드, 테스트 및 검증하는 과정입니다. Spinnaker, Jenkins, Helm과 같은 도구가 이러한 작업에 유용할 수 있습니다. 이러한 도구들은 동적 환경의 도전 과제를 해결하는 데 도움을 줄 수 있습니다. | 클러스터 구성 및 관리 | . 그 다음으로, 컨테이너를 실행할 기본 인프라로서 작동할 기계들의 클러스터가 필요합니다. 또한, 컨테이너를 시작하고, 실패 시 감시하며, 필요한 경우 교체하는 시스템이 필요합니다. 롤링 업데이트와 손쉬운 롤백 기능은 매우 중요하며, 더 이상 필요하지 않을 때 리소스를 해체하는 기능도 필요합니다. 이 모든 작업은 유연하고 확장 가능하며 사용하기 쉬운 네트워크와 스토리지가 필요합니다. 컨테이너가 어떤 워커 노드에서든 시작될 때 네트워크는 다른 컨테이너와 리소스를 연결해야 하며, 트래픽을 안전하게 유지해야 합니다. 또한, 원활하게 스토리지를 제공하고 재활용하는 스토리지 구조도 필요합니다. | 애플리케이션의 적응 | . 쿠버네티스는 이러한 문제를 해결해주지만, 가장 큰 도전 과제 중 하나는 컨테이너 내부에서 실행되는 애플리케이션 자체입니다. 애플리케이션은 완전히 일시적인 상태로 작성되거나 다시 작성되어야 합니다. 이를 생각해볼 수 있는 좋은 질문은 다음과 같습니다: 만약 Chaos Monkey를 배포하여 언제든지 컨테이너를 종료시킬 수 있다면, 고객들이 이를 눈치챌까요? . 쿠버네티스를 도입하면서 마주치는 이러한 도전 과제들을 해결하기 위해서는, 컨테이너 관리와 분산 애플리케이션 설계에 대한 깊은 이해와 지속적인 노력이 필요합니다. Kubernetes는 이러한 과제들을 해결하는 강력한 도구이며, 올바르게 사용하면 큰 이점을 제공할 수 있습니다. ",
    "url": "/docs/02_Tech/IAC#3-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%EB%8F%84%EC%A0%84-%EA%B3%BC%EC%A0%9C",
    
    "relUrl": "/docs/02_Tech/IAC#3-쿠버네티스의-도전-과제"
  },"146": {
    "doc": "CKA",
    "title": "4. Borg의 유산",
    "content": "쿠버네티스를 다른 시스템과 구별 짓는 주요 요소는 그 유산입니다. 쿠버네티스는 Google이 애플리케이션(Gmail, Apps, GCE 등)을 관리하기 위해 사용한 내부 시스템인 Borg에서 영감을 받았습니다. Google은 Borg를 15년 이상 작성하고 운영하면서 배운 귀중한 교훈을 쿠버네티스에 쏟아부었습니다. 이로 인해 컨테이너를 관리할 시스템을 결정할 때 쿠버네티스가 안전한 선택이 됩니다. 강력한 도구임에도 불구하고, 현재의 쿠버네티스 성장은 Google 데이터 센터에서 찾을 수 없는 작업 부하를 처리하고 사용하기 쉽게 만드는 데 중점을 두고 있습니다. 쿠버네티스에 대한 더 많은 아이디어를 알고 싶다면 Google의 Borg 논문, “Large-scale cluster management at Google with Borg”을 읽어볼 수 있습니다. | 쿠버네티스의 계보 | . 쿠버네티스의 계보는 오늘날의 데이터 센터 시스템뿐만 아니라 컨테이너 런타임에 사용되는 기본 기술에 영향을 미쳤습니다. Google은 2007년에 cgroups를 리눅스 커널에 기여했습니다. 이는 프로세스 집합이 사용하는 리소스를 제한합니다. cgroups와 리눅스 네임스페이스는 오늘날 Docker를 포함한 컨테이너의 핵심 요소입니다. Mesos는 Borg가 비밀이었을 때 Google과의 논의에서 영감을 받았습니다. 실제로 Mesos는 데이터 센터 클러스터를 더 잘 활용하기 위한 다단계 스케줄러를 구축합니다. Cloud Foundry Foundation은 12 Factor 애플리케이션 원칙을 받아들입니다. 이러한 원칙은 클라우드에서 쉽게 확장할 수 있고, 배포될 수 있으며, 빌드가 자동화된 웹 애플리케이션을 구축하기 위한 훌륭한 지침을 제공합니다. Borg와 쿠버네티스는 이러한 원칙을 잘 반영하고 있습니다. 이러한 Borg의 유산과 쿠버네티스의 발전은 현대의 컨테이너 관리 및 애플리케이션 배포 환경에 큰 영향을 미쳤습니다. 쿠버네티스는 Borg의 강력한 기능과 안정성을 바탕으로, 누구나 쉽게 사용할 수 있는 오픈 소스 프로젝트로 거듭났습니다. 이는 오늘날 많은 기업들이 쿠버네티스를 선택하는 이유 중 하나입니다. 쿠버네티스를 통해 여러분의 애플리케이션을 더욱 효율적이고 안정적으로 관리해보세요. Borg에서 시작된 이 놀라운 여정을 통해 여러분도 컨테이너 관리의 최전선에 설 수 있습니다. ",
    "url": "/docs/02_Tech/IAC#4-borg%EC%9D%98-%EC%9C%A0%EC%82%B0",
    
    "relUrl": "/docs/02_Tech/IAC#4-borg의-유산"
  },"147": {
    "doc": "CKA",
    "title": "5. 쿠버네티스 아키텍처",
    "content": "쿠버네티스를 빠르게 이해하기 위해, 시스템 구성 요소의 고수준 아키텍처 다이어그램을 보여주는 쿠버네티스 아키텍처 그래픽을 살펴보겠습니다. 모든 구성 요소가 표시된 것은 아니지만, 예를 들어 모든 컨테이너를 실행하는 노드는 kubelet과 kube-proxy를 가지고 있습니다. 쿠버네티스 아키텍처 . 가장 단순한 형태로, 쿠버네티스는 제어 평면 노드(Control Plane Nodes, 일명 cp 노드)와 작업자 노드(Worker Nodes, 이전에는 Minions라 불림)로 구성됩니다. 테스트 목적으로 모든 것을 단일 노드에서 실행할 수 있는 방법을 다음 장에서 살펴보겠습니다. Control Plane은 API 서버, 스케줄러, 다양한 컨트롤러 및 클러스터 상태, 컨테이너 설정 및 네트워킹 구성을 유지하기 위한 스토리지 시스템을 실행합니다. 쿠버네티스는 API 서버를 통해 API를 노출합니다. 로컬 클라이언트인 kubectl을 사용하여 API와 통신할 수 있으며, 직접 클라이언트를 작성하고 curl 명령을 사용할 수도 있습니다. kube-scheduler는 API로 들어오는 컨테이너 실행을 위한 pod 사양을 받아 적절한 노드를 찾아 해당 컨테이너를 실행합니다. 클러스터의 각 노드는 두 가지 프로세스를 실행합니다: 종종 시스템d 프로세스로 실행되는 kubelet과 kube-proxy입니다. kubelet은 컨테이너 실행 요청을 받아 필요한 리소스를 관리하고, 로컬 노드에서 컨테이너 엔진과 협력하여 이를 관리합니다. 로컬 컨테이너 엔진은 Docker, cri-o, containerd 또는 다른 것일 수 있습니다. kube-proxy는 네트워크 규칙을 생성하고 관리하여 컨테이너를 다른 컨테이너나 외부 세계에 노출합니다. API 기반의 통신 방식을 사용하면 비리눅스 작업자 노드와 컨테이너도 지원할 수 있습니다. Windows Server 2019에 대한 지원은 1.14 릴리스에서 안정화되었습니다. 현재로서는 리눅스 노드만이 클러스터의 제어 평면을 구성할 수 있습니다. 쿠버네티스의 주요 구성 요소 . API 서버 (API Server): . 쿠버네티스 클러스터와의 모든 상호작용은 API 서버를 통해 이루어집니다. API 서버는 클러스터의 상태를 관리하고, 다양한 클라이언트의 요청을 처리합니다. kube-scheduler: . kube-scheduler는 실행할 포드를 위한 적절한 노드를 찾는 역할을 합니다. 리소스 사용량, 정책, 제약 조건 등을 고려하여 최적의 노드를 선택합니다. kubelet: . kubelet은 각 노드에서 실행되는 에이전트로, API 서버로부터 컨테이너 실행 요청을 받아 처리합니다. 컨테이너의 상태를 모니터링하고, 필요한 리소스를 관리합니다. kube-proxy: . kube-proxy는 네트워크 프록시로서, 각 노드에서 네트워크 규칙을 관리하여 컨테이너 간의 통신을 가능하게 합니다. 또한, 외부 트래픽을 컨테이너로 전달합니다. 컨트롤러 매니저 (Controller Manager): . 컨트롤러 매니저는 클러스터의 상태를 원하는 상태로 유지하기 위한 다양한 컨트롤러를 실행합니다. 예를 들어, 레플리카셋 컨트롤러는 지정된 수의 포드가 항상 실행되도록 보장합니다. etcd: . etcd는 분산 키-값 저장소로, 쿠버네티스 클러스터의 모든 상태 정보를 저장합니다. 클러스터의 구성, 상태, 메타데이터 등이 여기에 저장됩니다. 쿠버네티스 아키텍처를 이해하면, 쿠버네티스를 더 효과적으로 사용할 수 있습니다. 이러한 구성 요소들이 어떻게 협력하여 컨테이너화된 애플리케이션을 자동화하고 관리하는지 파악하는 것이 중요합니다. 이를 통해, 복잡한 분산 시스템을 쉽게 관리하고 확장할 수 있는 능력을 갖추게 됩니다. ",
    "url": "/docs/02_Tech/IAC#5-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98",
    
    "relUrl": "/docs/02_Tech/IAC#5-쿠버네티스-아키텍처"
  },"148": {
    "doc": "CKA",
    "title": "6. 쿠버네티스 용어 정리",
    "content": "쿠버네티스는 컨테이너를 배포하고 관리하는 오케스트레이션 시스템입니다. 컨테이너는 개별적으로 관리되지 않으며, 대신 Pod라는 더 큰 객체의 일부로 관리됩니다. Pod는 하나 이상의 컨테이너로 구성되며, 이들은 IP 주소, 스토리지 접근 및 네임스페이스를 공유합니다. 일반적으로 Pod 내의 한 컨테이너는 애플리케이션을 실행하고, 다른 컨테이너들은 주 애플리케이션을 지원합니다. 네임스페이스 (Namespaces) . 쿠버네티스는 네임스페이스를 사용하여 객체를 서로 구분하고, 리소스 제어 및 다중 테넌트 환경을 고려합니다. 일부 객체는 클러스터 범위로 작동하며, 다른 객체들은 하나의 네임스페이스에만 작동합니다. 네임스페이스가 리소스의 분리를 담당하기 때문에, Pod 간의 통신은 서비스를 통해 이루어져야 합니다. 컨트롤러 및 오퍼레이터 (Controllers and Operators) . 오케스트레이션은 워치 루프(watch-loops)라고도 불리는 일련의 컨트롤러나 오퍼레이터를 통해 관리됩니다. 각 컨트롤러는 특정 객체 상태를 위해 kube-apiserver를 검사하고, 선언된 상태가 현재 상태와 일치할 때까지 객체를 수정합니다. 이러한 컨트롤러들은 kube-controller-manager에 컴파일되어 있지만, 사용자 정의 리소스 정의를 통해 다른 컨트롤러를 추가할 수 있습니다. 기본적으로 컨테이너를 위한 기능이 풍부한 오퍼레이터는 Deployment입니다. Deployment는 직접적으로 Pod와 작동하지 않으며, 대신 ReplicaSet을 관리합니다. ReplicaSet은 podSpec에 따라 Pod를 생성하거나 종료하는 오퍼레이터입니다. podSpec은 kubelet에 전달되며, kubelet은 컨테이너 엔진과 상호작용하여 필요한 리소스를 다운로드하고 사용할 수 있게 한 다음, 상태가 스펙과 일치할 때까지 컨테이너를 생성하거나 종료합니다. 서비스 (Services) . 서비스 오퍼레이터는 기존 IP 주소 및 엔드포인트 오퍼레이터의 정보를 요청하며, 라벨을 기반으로 네트워크 연결을 관리합니다. 서비스는 Pod, 네임스페이스 및 클러스터 외부와의 통신에 사용됩니다. 또한, 단일 또는 반복 작업을 처리하기 위한 Jobs와 CronJobs 같은 기본 오퍼레이터도 있습니다. 라벨 및 애노테이션 (Labels and Annotations) . 수백 개의 노드에 걸쳐 수천 개의 Pod를 쉽게 관리하기 위해 라벨을 사용할 수 있습니다. 라벨은 객체 메타데이터의 일부가 되는 임의의 문자열로, 개별 이름이나 UID를 알지 않고도 객체 상태를 확인하거나 변경할 때 사용될 수 있습니다. 노드는 Pod 할당을 억제하기 위해 taints를 가질 수 있으며, Pod 메타데이터에 toleration이 있는 경우에만 할당됩니다. 메타데이터에는 객체와 함께 유지되지만 선택자로 사용되지 않는 애노테이션을 위한 공간도 있습니다. 이 정보는 컨테이너, 서드파티 에이전트 또는 다른 도구에서 사용될 수 있습니다. 결론 쿠버네티스는 강력한 오케스트레이션 시스템으로, 컨테이너화된 애플리케이션의 배포와 관리를 크게 단순화합니다. 다양한 구성 요소와 용어를 이해하면, 쿠버네티스를 더 효과적으로 사용할 수 있습니다. 이러한 기본 개념을 바탕으로 쿠버네티스를 사용하여 대규모 분산 시스템을 관리하고 확장할 수 있는 능력을 갖추게 될 것입니다. ",
    "url": "/docs/02_Tech/IAC#6-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC",
    
    "relUrl": "/docs/02_Tech/IAC#6-쿠버네티스-용어-정리"
  },"149": {
    "doc": "CKA",
    "title": "7. 쿠버네티스의 혁신",
    "content": "쿠버네티스는 탄생 이후 놀라운 속도로 혁신과 채택이 이루어지고 있습니다. 개발자, 사용자, 테스터, 그리고 옹호자들의 커뮤니티는 매일 지속적으로 성장하고 있습니다. 소프트웨어의 발전 속도 또한 매우 빨라서 GitHub조차 그 속도에 대응하기 위해 노력하고 있습니다. 주요 혁신 지표 . 2014년 6월에 오픈 소스로 공개됨 수천 명의 기여자 10만 개 이상의 커밋 Slack 사용자 수만 명 현재 4개월 주기로 주요 릴리스 10일 정도마다 패치 릴리스 끊임없는 변화 이처럼 꾸준한 변화와 혁신은 단일 벤더의 모놀리식 애플리케이션에 익숙한 사람들에게는 도전 과제가 될 수 있습니다. 4개월마다 주요 릴리스가 이루어지지만, 10일마다 마이너 릴리스가 이루어질 수 있습니다. 새로운 릴리스와 변경 사항을 지속적으로 테스트하는 것은 쿠버네티스 클러스터를 적절히 유지 관리하는 데 필수적입니다. 커뮤니티와 기여 쿠버네티스의 빠른 발전은 활발한 커뮤니티와 수많은 기여자들 덕분입니다. 수천 명의 개발자들이 코드를 작성하고, 새로운 기능을 추가하며, 버그를 수정하고 있습니다. GitHub에서의 활발한 활동은 10만 개 이상의 커밋과 수많은 풀 리퀘스트로 증명됩니다. 또한, 수만 명의 사용자가 Slack 채널에서 서로 도움을 주고받으며 정보를 공유하고 있습니다. 릴리스 주기 쿠버네티스는 4개월 주기로 주요 릴리스를 진행하며, 새로운 기능과 개선 사항을 도입합니다. 이와 동시에 10일 정도마다 패치 릴리스를 통해 버그 수정과 작은 개선 사항을 제공합니다. 이러한 빠른 릴리스 주기는 쿠버네티스가 최신 기술을 빠르게 반영하고 사용자들에게 더 나은 기능을 제공할 수 있도록 합니다. 끊임없는 변화 관리 쿠버네티스를 효과적으로 사용하기 위해서는 끊임없는 변화에 대비하고 이를 관리하는 능력이 필요합니다. 지속적인 테스트와 업데이트는 안정적이고 효율적인 클러스터 운영에 필수적입니다. 새로운 버전이 릴리스될 때마다 테스트 환경에서 충분히 검증한 후 프로덕션 환경에 배포하는 것이 중요합니다. 결론 쿠버네티스는 혁신과 발전의 최전선에 서 있는 오케스트레이션 플랫폼입니다. 활발한 커뮤니티와 빠른 릴리스 주기는 쿠버네티스를 지속적으로 진화시키고 있으며, 이를 통해 사용자는 최신 기술을 빠르게 도입할 수 있습니다. 변화에 대비하고 이를 관리하는 능력을 키운다면, 쿠버네티스를 통해 더욱 효율적이고 안정적인 애플리케이션 관리를 할 수 있을 것입니다. ",
    "url": "/docs/02_Tech/IAC#7-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%9D%98-%ED%98%81%EC%8B%A0",
    
    "relUrl": "/docs/02_Tech/IAC#7-쿠버네티스의-혁신"
  },"150": {
    "doc": "CKA",
    "title": "9. 쿠버네티스 툴",
    "content": "쿠버네티스와 함께 작업할 수 있는 여러 가지 도구가 있습니다. 프로젝트가 성장함에 따라 새로운 도구가 제공되고 오래된 도구는 사용 중단됩니다. 여기 몇 가지 주요 도구를 소개합니다. Minikube . Minikube는 VirtualBox 내에서 실행되는 매우 간단한 도구입니다. 자원이 제한적이고 복잡한 설정을 원하지 않는 경우, Minikube는 빠르고 쉽게 시작할 수 있는 방법입니다. 일반적인 프로덕션 환경에 관심이 없고, 도구를 사용해보고 싶은 분들에게 추천드립니다. Kubeadm 및 Kubectl . 우리의 실습은 강력하고 복잡한 도구인 kubeadm과 kubectl의 사용에 중점을 둘 것입니다. Kubeadm: 쿠버네티스 클러스터를 초기화하고 설정하는 데 사용되는 도구입니다. kubeadm은 클러스터의 모든 필수 구성 요소를 자동으로 설정하여, 사용자가 쉽게 클러스터를 구축할 수 있도록 돕습니다. Kubectl: 쿠버네티스 클러스터와 상호작용하기 위한 커맨드 라인 도구입니다. kubectl을 사용하여 애플리케이션을 배포하고, 리소스를 관리하며, 로그를 검사하는 등 다양한 작업을 수행할 수 있습니다. Helm . 추후 챕터에서는 Helm을 사용하여 쿠버네티스를 쉽게 다루는 방법을 배울 것입니다. Helm은 차트를 사용하여 소프트웨어를 검색하고 설치하는 도구로, 복잡한 애플리케이션 배포를 간단하게 만들어줍니다. Kompose . Docker Compose 파일을 쿠버네티스 객체로 변환하려는 경우, Kompose와 같은 유용한 명령어를 사용할 수 있습니다. Kompose는 Docker Compose 파일을 읽고, 이를 쿠버네티스의 포드, 서비스 등으로 변환해줍니다. 변화에 대비하기 이러한 도구들은 자주 변경될 수 있으므로, 항상 최신 정보를 유지하고 새로운 도구와 기능에 대비하는 것이 중요합니다. 결론 쿠버네티스 환경에서 작업할 때 다양한 도구를 사용할 수 있습니다. Minikube는 빠르게 시작하는 데 유용하고, kubeadm과 kubectl은 강력한 클러스터 관리 도구입니다. Helm과 Kompose는 애플리케이션 배포를 더욱 간편하게 만들어줍니다. 이러한 도구들을 잘 활용하면 쿠버네티스를 효과적으로 관리하고 사용할 수 있습니다. 지속적인 도구 업데이트와 변화에 대비하여 최신 정보를 유지하는 것도 중요합니다. ",
    "url": "/docs/02_Tech/IAC#9-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%ED%88%B4",
    
    "relUrl": "/docs/02_Tech/IAC#9-쿠버네티스-툴"
  },"151": {
    "doc": "CKA",
    "title": "10. 실습",
    "content": "공식 웹사이트 : kubernetes . 브라우저 열기: . 브라우저를 열고 https://kubernetes.io/ 웹사이트를 방문하세요. 버전 선택: . 오른쪽 상단 모서리의 드롭다운 메뉴를 사용하여 사용 가능한 버전을 확인하세요. 예를 들어 v1.30.3과 같은 버전이 표시됩니다. 문서 링크 선택: . 페이지 상단의 Documentation 링크를 선택하세요. 왼쪽의 링크는 탐색에 도움이 됩니다. 탐색: . 시간이 허락하는 한 SETUP, CONCEPTS, TASKS와 같은 다른 하위 페이지를 탐색하여 레이아웃에 익숙해지세요. Kubernetes 이슈 추적 . 쿠버네티스에는 매일 수백 명, 어쩌면 수천 명이 작업하고 있습니다. 이렇게 많은 사람들이 병렬로 작업하는 경우, 다른 사람들이 유사한 문제를 겪고 있는지 확인할 수 있는 좋은 리소스가 있습니다. 소스 코드뿐만 아니라 기능 및 이슈 추적은 현재 GitHub에서 진행되고 있습니다. GitHub 메인 페이지 방문: . 브라우저를 열고 https://github.com/kubernetes/kubernetes/ 페이지를 방문하세요. 서브 디렉토리 확인: . 다양한 서브 디렉토리를 클릭하여 기본 정보를 확인하세요. 이슈 페이지 방문: . URL을 https://github.com/kubernetes/kubernetes/issues로 업데이트하세요. 여러 이슈, 기능 요청 및 지원 커뮤니케이션을 볼 수 있습니다. 검색 필터 추가: . 검색 상자에 is:issue is:open과 같은 기존 텍스트가 보일 것입니다. 검색 문자열을 is:issue is:open label:kind/bug로 추가한 후 엔터를 누르세요. 버그 확인: . 이제 날짜순으로 정렬된 버그들을 볼 수 있습니다. 이슈 상단의 메뉴 영역을 통해 작성자, 라벨, 프로젝트, 마일스톤 및 담당자별로 항목을 볼 수 있습니다. 다양한 선택 기준을 확인해보세요. 출력 유형 제외: . 특정 유형의 출력을 제외하고 싶은 경우, URL을 업데이트하여 라벨 앞에 마이너스 기호를 추가하세요. 예를 들어 is:issue is:open -label:kind/bug로 업데이트하면 버그 보고서를 제외한 모든 것을 볼 수 있습니다. 이러한 실습을 통해 쿠버네티스의 공식 리소스를 탐색하고, GitHub에서 이슈를 추적하는 방법을 익힐 수 있습니다. 이는 쿠버네티스를 더 잘 이해하고 효과적으로 사용할 수 있는 능력을 키우는 데 도움이 될 것입니다. pod 의 속해있는것 . one or more containers shared ip address one namespace . ",
    "url": "/docs/02_Tech/IAC#10-%EC%8B%A4%EC%8A%B5",
    
    "relUrl": "/docs/02_Tech/IAC#10-실습"
  },"152": {
    "doc": "CKA",
    "title": "11. 설치 도구",
    "content": "이 장에서는 쿠버네티스 설치 및 구성에 대해 다룹니다. 쿠버네티스 클러스터를 만들기 위해 사용할 수 있는 몇 가지 설치 메커니즘을 검토할 것입니다. 클러스터 설치 및 구성 없이 시작하는 방법 . 설치 및 구성에 바로 뛰어들지 않고 시작할 수 있는 몇 가지 방법이 있습니다. Google Kubernetes Engine (GKE): . Google Cloud Platform의 클라우드 서비스로, 최신 안정 버전의 쿠버네티스 클러스터를 요청할 수 있습니다. Amazon Elastic Kubernetes Service (EKS): . Amazon의 서비스로, cp 노드에 대한 더 많은 제어를 허용합니다. Minikube: . 여러 운영 체제에서 실행할 수 있는 Oracle VirtualBox 소프트웨어에 배포되는 단일 바이너리입니다. Minikube는 로컬 및 단일 노드 환경에서 학습, 테스트 및 개발 플랫폼을 제공합니다. MicroK8s: . Canonical에서 개발한 최신 도구로, 간편한 설치를 목표로 합니다. 현재 Ubuntu 16.04 이상에서 실행됩니다. Kubernetes 클러스터 사용을 위한 CLI 도구 . 쿠버네티스 클러스터를 사용하려면 쿠버네티스 명령줄 도구인 kubectl 또는 gcloud와 같은 래퍼 명령을 설치해야 합니다. 이 도구는 로컬 머신에서 실행되며 API 서버 엔드포인트를 대상으로 합니다. 이를 통해 모든 쿠버네티스 리소스(예: Pod, Deployment, Service)를 생성, 관리 및 삭제할 수 있습니다. kubectl은 이 과정에서 계속 사용할 강력한 CLI이므로 익숙해지는 것이 중요합니다. Kubeadm을 사용한 설치 . 이 과정에서는 쿠버네티스 프로젝트에서 커뮤니티가 권장하는 도구인 kubeadm을 사용하여 쿠버네티스를 쉽게 설치하고 공급업체별 설치 도구를 피할 수 있습니다. 클러스터 실행은 두 가지 명령으로 구성됩니다: . kubeadm init: cp 노드에서 실행합니다. kubeadm join: 워커 노드나 중복 cp 노드에서 실행하여 클러스터를 부트스트랩합니다. 이 도구들의 유연성 덕분에 쿠버네티스를 다양한 장소에 배포할 수 있습니다. 실습에서는 이 방법을 사용합니다. 기타 설치 메커니즘 . 다른 설치 메커니즘으로는 AWS 노드에 쿠버네티스 클러스터를 생성하기 위해 사용되는 kubespray나 kops가 있습니다. 쿠버네티스는 매우 인기가 있기 때문에 클러스터를 구성하는 데 사용할 수 있는 여러 도구가 있습니다. 일부 도구는 인기를 끌 수 있지만, 몇 달 내에 사용 중단될 수도 있습니다. 이와 같은 다양한 도구를 사용하여 쿠버네티스를 설치하고 구성할 수 있으며, 각 도구의 특성과 사용 사례에 따라 적절한 도구를 선택할 수 있습니다. ",
    "url": "/docs/02_Tech/IAC#11-%EC%84%A4%EC%B9%98-%EB%8F%84%EA%B5%AC",
    
    "relUrl": "/docs/02_Tech/IAC#11-설치-도구"
  },"153": {
    "doc": "CKA",
    "title": "12. Kubectl 설치",
    "content": "클러스터를 구성하고 관리하려면 kubectl 명령을 사용할 것입니다. RESTful 호출이나 Go 언어를 사용할 수도 있습니다. 엔터프라이즈 리눅스 배포판에서의 설치 . 엔터프라이즈 리눅스 배포판에는 다양한 쿠버네티스 유틸리티 및 기타 파일들이 저장소에 제공됩니다. 예를 들어, RHEL/CentOS에서는 kubernetes-client 패키지에 kubectl이 포함되어 있습니다. OpenShift에서는 kubectl과 매우 유사한 oc 명령을 사용합니다. GitHub에서 설치 . 필요에 따라 GitHub에서 코드를 다운로드하여 kubectl을 컴파일하고 설치하는 일반적인 절차를 따를 수 있습니다. # 최신 kubectl 바이너리 다운로드 curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" ## mac curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/darwin/arm64/kubectl\" # 바이너리에 실행 권한 부여 chmod +x kubectl # 바이너리를 PATH에 있는 디렉토리로 이동 sudo mv kubectl /usr/local/bin/ . 이 명령줄은 $HOME/.kube/config를 구성 파일로 사용합니다. 이 파일에는 사용자가 사용할 수 있는 모든 쿠버네티스 엔드포인트가 포함되어 있습니다. 이를 검사하면 클러스터 정의(IP 엔드포인트), 자격 증명 및 컨텍스트를 확인할 수 있습니다. 컨텍스트 사용 . 컨텍스트는 클러스터와 사용자 자격 증명의 조합입니다. 이러한 매개변수를 명령줄에서 전달하거나, 명령어를 사용하여 쉘 간에 컨텍스트를 전환할 수 있습니다. 예를 들어: . $ kubectl config use-context foobar . 이 명령은 로컬 환경에서 클라우드의 클러스터로, 또는 개발 환경에서 프로덕션 환경으로 이동할 때 유용합니다. kubectl 설정 및 관리 . 구성 파일 경로 확인: . $HOME/.kube/config 파일이 올바르게 설정되어 있는지 확인하세요. 이 파일에는 클러스터에 연결하는 데 필요한 정보가 포함되어 있습니다. 컨텍스트 전환: . 여러 클러스터나 환경 간에 쉽게 전환할 수 있습니다. 예를 들어, 개발 환경에서 프로덕션 환경으로 전환하려면 다음 명령을 사용합니다: . $ kubectl config use-context my-production-context . kubectl 명령 사용: . 클러스터 리소스를 관리하기 위해 다양한 kubectl 명령을 사용할 수 있습니다. 예를 들어, 모든 포드를 나열하려면 다음을 실행합니다: . $ kubectl get pods . 도움말 명령: . 사용 가능한 명령과 옵션에 대한 도움말을 보려면 다음 명령을 실행합니다: . $ kubectl help . 이와 같은 방식으로 kubectl을 사용하여 쿠버네티스 클러스터를 구성하고 관리할 수 있습니다. 다양한 명령과 옵션을 익혀두면 클러스터를 효율적으로 운영할 수 있습니다. ",
    "url": "/docs/02_Tech/IAC#12-kubectl-%EC%84%A4%EC%B9%98",
    
    "relUrl": "/docs/02_Tech/IAC#12-kubectl-설치"
  },"154": {
    "doc": "CKA",
    "title": "CKA",
    "content": " ",
    "url": "/docs/02_Tech/IAC",
    
    "relUrl": "/docs/02_Tech/IAC"
  },"155": {
    "doc": "5. Amazon CloudFront",
    "title": "CloudFront",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront#cloudfront",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#cloudfront"
  },"156": {
    "doc": "5. Amazon CloudFront",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. CloudFront란? | 2. CloudFront의 주요 기능 | 3. CloudFront의 작동 방식 | 4. Lambda@Edge 함수 | . ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#목차"
  },"157": {
    "doc": "5. Amazon CloudFront",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#글을-쓴-배경"
  },"158": {
    "doc": "5. Amazon CloudFront",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#글-요약"
  },"159": {
    "doc": "5. Amazon CloudFront",
    "title": "시작하기 전",
    "content": ". ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#시작하기-전"
  },"160": {
    "doc": "5. Amazon CloudFront",
    "title": "1. CloudFront란?",
    "content": "Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빠르게 배포하도록 지원하는 웹 서비스입니다. 이 서비스는 엣지 로케이션이라는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다. ",
    "url": "/docs/02_Tech/AWS/CloudFront#1-cloudfront%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#1-cloudfront란"
  },"161": {
    "doc": "5. Amazon CloudFront",
    "title": "2. CloudFront의 주요 기능",
    "content": ". | 글로벌 콘텐츠 배포 . | 전 세계에 분포된 엣지 로케이션을 통해 사용자에게 콘텐츠를 제공합니다. | . | 오리진 서버와의 통합 . | 콘텐츠가 엣지 로케이션에 없을 경우, CloudFront는 Amazon S3 버킷, 또는 오리진 서버에서 콘텐츠를 가져옵니다. | . | 향상된 성능 및 신뢰성 . | 네트워크 간의 경유 횟수를 줄여 성능을 향상시키며, 파일의 사본을 전 세계 여러 엣지 로케이션에 캐시함으로써 안정성과 가용성을 높입니다. | . | . ",
    "url": "/docs/02_Tech/AWS/CloudFront#2-cloudfront%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#2-cloudfront의-주요-기능"
  },"162": {
    "doc": "5. Amazon CloudFront",
    "title": "3. CloudFront의 작동 방식",
    "content": ". | 배포 생성 . | 배포를 통해 콘텐츠를 어디에서 전송할지, 어떻게 전송할지를 지정할 수 있습니다. | . | 오리진 서버 설정 . | 콘텐츠의 최종 원본 버전을 저장합니다. | . | 캐싱 및 만료 설정 . | 기본적으로 엣지 로케이션에 캐시된 파일은 만료되기 전까지 24시간 동안 유지되며, 사용자 설정에 따라 이 시간을 조정할 수 있습니다. | . | 요금 구조 . | 엣지 로케이션에서 전송되는 데이터와 HTTP , HTTPS 요청에 대해 요금을 부과합니다. | . | . ",
    "url": "/docs/02_Tech/AWS/CloudFront#3-cloudfront%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#3-cloudfront의-작동-방식"
  },"163": {
    "doc": "5. Amazon CloudFront",
    "title": "4. Lambda@Edge 함수",
    "content": "CloudFront 콘텐츠를 보호하기 위한 Authorization@Edge 솔루션 사용자가 CloudFront 배포에 접근하기 전에 인증을 거치도록 할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/CloudFront#4-lambdaedge-%ED%95%A8%EC%88%98",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#4-lambdaedge-함수"
  },"164": {
    "doc": "5. Amazon CloudFront",
    "title": "5. Amazon CloudFront",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront"
  },"165": {
    "doc": "5. Amazon CloudFront",
    "title": "CloudFront",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront#cloudfront",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#cloudfront"
  },"166": {
    "doc": "5. Amazon CloudFront",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. CloudFront란? | 2. CloudFront의 주요 기능 | 3. CloudFront의 작동 방식 | 4. Lambda@Edge 함수 | . ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#목차"
  },"167": {
    "doc": "5. Amazon CloudFront",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#글을-쓴-배경"
  },"168": {
    "doc": "5. Amazon CloudFront",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#글-요약"
  },"169": {
    "doc": "5. Amazon CloudFront",
    "title": "시작하기 전",
    "content": ". ",
    "url": "/docs/02_Tech/AWS/CloudFront#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#시작하기-전"
  },"170": {
    "doc": "5. Amazon CloudFront",
    "title": "1. CloudFront란?",
    "content": "Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빠르게 배포하도록 지원하는 웹 서비스입니다. 이 서비스는 엣지 로케이션이라는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다. ",
    "url": "/docs/02_Tech/AWS/CloudFront#1-cloudfront%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#1-cloudfront란"
  },"171": {
    "doc": "5. Amazon CloudFront",
    "title": "2. CloudFront의 주요 기능",
    "content": ". | 글로벌 콘텐츠 배포 . | 전 세계에 분포된 엣지 로케이션을 통해 사용자에게 콘텐츠를 제공합니다. | . | 오리진 서버와의 통합 . | 콘텐츠가 엣지 로케이션에 없을 경우, CloudFront는 Amazon S3 버킷, 또는 오리진 서버에서 콘텐츠를 가져옵니다. | . | 향상된 성능 및 신뢰성 . | 네트워크 간의 경유 횟수를 줄여 성능을 향상시키며, 파일의 사본을 전 세계 여러 엣지 로케이션에 캐시함으로써 안정성과 가용성을 높입니다. | . | . ",
    "url": "/docs/02_Tech/AWS/CloudFront#2-cloudfront%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#2-cloudfront의-주요-기능"
  },"172": {
    "doc": "5. Amazon CloudFront",
    "title": "3. CloudFront의 작동 방식",
    "content": ". | 배포 생성 . | 배포를 통해 콘텐츠를 어디에서 전송할지, 어떻게 전송할지를 지정할 수 있습니다. | . | 오리진 서버 설정 . | 콘텐츠의 최종 원본 버전을 저장합니다. | . | 캐싱 및 만료 설정 . | 기본적으로 엣지 로케이션에 캐시된 파일은 만료되기 전까지 24시간 동안 유지되며, 사용자 설정에 따라 이 시간을 조정할 수 있습니다. | . | 요금 구조 . | 엣지 로케이션에서 전송되는 데이터와 HTTP , HTTPS 요청에 대해 요금을 부과합니다. | . | . ",
    "url": "/docs/02_Tech/AWS/CloudFront#3-cloudfront%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#3-cloudfront의-작동-방식"
  },"173": {
    "doc": "5. Amazon CloudFront",
    "title": "4. Lambda@Edge 함수",
    "content": "CloudFront 콘텐츠를 보호하기 위한 Authorization@Edge 솔루션 사용자가 CloudFront 배포에 접근하기 전에 인증을 거치도록 할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/CloudFront#4-lambdaedge-%ED%95%A8%EC%88%98",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront#4-lambdaedge-함수"
  },"174": {
    "doc": "5. Amazon CloudFront",
    "title": "5. Amazon CloudFront",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront"
  },"175": {
    "doc": "1. CloudFront Function vs Lambda@Edge 비교",
    "title": "CloudFront Function vs Lambda@Edge 비교",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFrontFunction#cloudfront-function-vs-lambdaedge-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFrontFunction#cloudfront-function-vs-lambdaedge-비교"
  },"176": {
    "doc": "1. CloudFront Function vs Lambda@Edge 비교",
    "title": "목차",
    "content": ". | 1. CloudFront Function이란? | 2. Lambda@Edge란? | 3. CloudFront Functions와 Lambda@Edge 비교 | 4. 사용 사례 . | 4.1 CloudFront Functions의 적합한 사용 사례 | CloudFront Functions의 적합한 사용 사례 | Lambda@Edge의 적합한 사용 사례 | 작업 내용 정리 | . | . ",
    "url": "/docs/02_Tech/AWS/CloudFrontFunction#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFrontFunction#목차"
  },"177": {
    "doc": "1. CloudFront Function vs Lambda@Edge 비교",
    "title": "1. CloudFront Function이란?",
    "content": "Amazon CloudFront는 글로벌 콘텐츠 배포 네트워크(CDN) 서비스로, 데이터, 비디오, 애플리케이션 및 API를 낮은 지연 시간과 높은 전송 속도로 유저에게 전달합니다. CloudFront Functions는 이러한 CloudFront 요청을 처리하기 위한 서버리스 함수 기능을 제공합니다. 이를 통해 간단한 JavaScript 코드를 사용하여 HTTP 요청과 응답을 수정할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/CloudFrontFunction#1-cloudfront-function%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFrontFunction#1-cloudfront-function이란"
  },"178": {
    "doc": "1. CloudFront Function vs Lambda@Edge 비교",
    "title": "2. Lambda@Edge란?",
    "content": "Lambda@Edge는 AWS Lambda 함수를 유저와 가까운 위치에서 응답하여 실행할 수 있는 서비스입니다. 이를 통해 함수가 아래와 같은 CloudFront 이벤트 종류에 따라 트리거됩니다 . Viewer Request: CloudFront가 뷰어의 요청을 받은 후 Viewer Response: CloudFront가 응답을 뷰어에게 전달하기 전 Origin Request: CloudFront가 오리진으로 요청을 전달하기 전 Origin Response: CloudFront가 오리진으로부터 응답을 받은 후 . Lambda@Edge를 사용하면 함수를 오리진 서버가 아닌 최종 사용자에게 가까운 위치에서 실행할 수 있습니다. 이는 지연 시간을 크게 단축시킬 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/CloudFrontFunction#2-lambdaedge%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFrontFunction#2-lambdaedge란"
  },"179": {
    "doc": "1. CloudFront Function vs Lambda@Edge 비교",
    "title": "3. CloudFront Functions와 Lambda@Edge 비교",
    "content": "Choosing between CloudFront Functions and Lambda@Edge . | 특징 | CloudFront Functions | Lambda@Edge | . | 프로그래밍 언어 | JavaScript (ECMAScript 5.1 호환) | Node.js 및 Python | . | 이벤트 소스 | Viewer request, Viewer response | Viewer request, Viewer response, Origin request, Origin response | . | Amazon CloudFront KeyValueStore 지원 | 예 (JavaScript 런타임 2.0에서만) | 아니요 | . | 확장성 | 초당 10,000,000 요청 이상 처리 가능 | 리전당 초당 최대 10,000 요청 | . | 함수 지속 시간 | 서브밀리초 | 최대 5초 (Viewer request 및 Viewer response), 최대 30초 (Origin request 및 Origin response) | . | 최대 메모리 | 2MB | 128MB – 10,240MB (10GB) | . | 함수 코드 및 라이브러리 최대 크기 | 10KB | 1MB (Viewer request 및 Viewer response), 50MB (Origin request 및 Origin response) | . | 네트워크 액세스 | 아니요 | 예 | . | 파일 시스템 액세스 | 아니요 | 예 | . | 요청 본문 액세스 | 아니요 | 예 | . | 지리적 위치 및 장치 데이터 액세스 | 예 | 아니요 (Viewer request 및 Viewer response), 예 (Origin request 및 Origin response) | . | CloudFront 내에서 완전한 빌드 및 테스트 가능 여부 | 예 | 아니요 | . | 함수 로깅 및 지표 | 예 | 예 | . | 가격 | 무료 티어 제공; 요청당 요금 부과 | 무료 티어 없음; 요청 및 함수 지속 시간에 따라 요금 부과 | . ",
    "url": "/docs/02_Tech/AWS/CloudFrontFunction#3-cloudfront-functions%EC%99%80-lambdaedge-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFrontFunction#3-cloudfront-functions와-lambdaedge-비교"
  },"180": {
    "doc": "1. CloudFront Function vs Lambda@Edge 비교",
    "title": "4. 사용 사례",
    "content": "4.1 CloudFront Functions의 적합한 사용 사례 . | 헤더 조작: CloudFront 응답에 사용자가 필요한 헤더를 추가하여 브라우저 캐싱 제어 및 특정 헤더 추가등 기능을 사용할 수 있습니다. | URL 리디렉션 또는 다시 쓰기: 요청 정보를 기반으로 사용자를 다른 페이지로 리디렉션하거나 경로를 변경합니다. | 요청 권한 부여: JWT와 같은 해시된 권한 부여 토큰을 검증하여 요청을 인증합니다. | . 샘플 코드 주소 : aws-samples/amazon-cloudfront-functions . CloudFront Functions의 적합한 사용 사례 . | 캐시 키 정규화: HTTP 요청 속성(헤더, 쿼리 문자열, 쿠키, URL 경로)을 변환하여 최적의 캐시 키를 생성하고 캐시 적중률을 개선합니다. | 헤더 조작: 요청 또는 응답에서 HTTP 헤더를 삽입, 수정 또는 삭제합니다. | URL 리디렉션 또는 다시 쓰기: 요청 정보를 기반으로 사용자를 다른 페이지로 리디렉션하거나 경로를 변경합니다. | 요청 권한 부여: JWT와 같은 해시된 권한 부여 토큰을 검증하여 요청을 인증합니다. | . CloudFront Functions 시작하기 . Lambda@Edge의 적합한 사용 사례 . | 수 밀리초 이상의 실행 시간이 필요한 함수 | 조정 가능한 CPU 또는 메모리가 필요한 함수 | 타사 라이브러리(AWS SDK 포함)에 의존하는 함수 | 외부 서비스 처리를 위해 네트워크 액세스가 필요한 함수 | 파일 시스템 액세스 또는 HTTP 요청 본문에 액세스가 필요한 함수 | . Lambda@Edge 시작하기 . 확장성 부분 재 정리 . CloudFront Functions는 Edge보다 훨신 높은 초당 트래픽 처리가 가능합니다. 초당 천만 / Edge 리전당 초당 만 . CloudFront Function은 주로 짧고 가벼운 작업에 최적화 되었습니다. Edge는 더 복잡하고 시간이 오래 걸리는 작업을 처리할 수 있지만 초당 트래픽 처리가 제한됩니다. 함수 지속 시간 . 이벤트에 응답하여 코드를 실행할 때 걸리는 시간에 대한 차이를 설명 . 함수가 실행되는 시간이 밀리초 단위로 매우 빠르다 . Lambda@Edge - viewer request 5ch // 상대적으로 긴 실행시간을 허용합니다. 최대 메모리 . 메모리 할당 제한 설명 / 각 function이 얼마나 많은 메모리를 사용할 수 있는지에 대한 차이점 . CloudFront는 2MB만 사용 가능 . Lambda@Edge는 128 ~ 10240 사용 가능 . cloudfront 내에서 완전한 빌드 및 테스트 가능 . CloudEdge 함수 코드 및 라이브러리 최대 크기: -&gt; RS256 방식까진 가능 1MB (Viewer request 및 Viewer response) . 네트워크 액세스 CloudFront Functions: 네트워크 액세스를 지원하지 않습니다. 의미: CloudFront Functions는 외부 네트워크에 접근할 수 없으므로, 외부 API 호출이나 데이터베이스 연결이 필요한 작업에 적합하지 않습니다. Lambda@Edge: 네트워크 액세스를 지원합니다. 의미: Lambda@Edge는 외부 네트워크에 접근할 수 있어 외부 API 호출이나 데이터베이스 연결을 수행할 수 있습니다. 파일 시스템 액세스 CloudFront Functions: 파일 시스템 액세스를 지원하지 않습니다. 의미: CloudFront Functions는 로컬 파일 시스템에 접근하거나 파일을 읽고 쓸 수 없습니다. Lambda@Edge: 파일 시스템 액세스를 지원합니다. 의미: Lambda@Edge는 로컬 파일 시스템에 접근할 수 있어 파일 읽기/쓰기 작업을 수행할 수 있습니다. 요청 본문 액세스 CloudFront Functions: 요청 본문에 접근할 수 없습니다. 의미: CloudFront Functions는 HTTP 요청의 본문 데이터를 읽을 수 없으므로, 본문 데이터를 기반으로 하는 작업에 적합하지 않습니다. Lambda@Edge: 요청 본문에 접근할 수 있습니다. 의미: Lambda@Edge는 HTTP 요청의 본문 데이터를 읽을 수 있어, 본문 데이터를 처리하는 작업에 적합합니다. 지리적 위치 및 장치 데이터 액세스 CloudFront Functions: 지리적 위치 및 장치 데이터에 접근할 수 있습니다. 의미: CloudFront Functions는 사용자 위치나 장치 정보를 기반으로 작업을 수행할 수 있습니다. Lambda@Edge: 지리적 위치 및 장치 데이터 접근 여부가 이벤트 유형에 따라 다릅니다. Viewer request 및 Viewer response: 지리적 위치 및 장치 데이터에 접근할 수 없습니다. Origin request 및 Origin response: 지리적 위치 및 장치 데이터에 접근할 수 있습니다. CloudFront 내에서 완전한 빌드 및 테스트 가능 여부 CloudFront Functions: CloudFront 내에서 완전한 빌드 및 테스트가 가능합니다. 의미: CloudFront Functions는 CloudFront 콘솔 내에서 직접 빌드하고 테스트할 수 있습니다. Lambda@Edge: CloudFront 내에서 완전한 빌드 및 테스트가 불가능합니다. 의미: Lambda@Edge는 AWS Lambda 콘솔에서 빌드하고 테스트해야 하며, CloudFront 콘솔 내에서는 테스트할 수 없습니다. 함수 로깅 및 지표 CloudFront Functions: 함수 로깅 및 지표를 지원합니다. 의미: CloudFront Functions는 실행 로그와 성능 지표를 제공하여 함수의 동작을 모니터링할 수 있습니다. Lambda@Edge: 함수 로깅 및 지표를 지원합니다. 의미: Lambda@Edge도 실행 로그와 성능 지표를 제공하여 함수의 동작을 모니터링할 수 있습니다. 가격 CloudFront Functions: 무료 티어 제공; 요청당 요금 부과 의미: CloudFront Functions는 무료 티어가 있으며, 요청 수에 따라 요금이 부과됩니다. Lambda@Edge: 무료 티어 없음; 요청 및 함수 지속 시간에 따라 요금 부과 의미: Lambda@Edge는 무료 티어가 없으며, 요청 수와 함수 실행 시간에 따라 요금이 부과됩니다. 이 비교를 통해 CloudFront Functions와 Lambda@Edge의 기능 차이를 이해하고, 특정 사용 사례에 적합한 도구를 선택할 수 있습니다. 가격 비교 . Lambda@Edge 보다 지연시간이 짧다 비용이 6/1 정도 . 가장 큰 차이점은 execution time, 네트워크 액세스 유무, 가격 . body 내용 접근이 불가 . 가격 (Request 요금 / 백만 개 당) : 0.1 USD / 0.6 USD . 작업 내용 정리 . | API Gateway . | HTTP API 구축 완료: HTTP API 구축완료 및 API 라우팅 경로 생성 방법 전달 완료. | CloudWatch 로그 수집 구축 완료: API Gateway의 로그가 CloudWatch로 수집되도록 설정 완료. API 호출 및 응답에 대한 모니터링 가능 | 인증 절차 구현 완료: Header에 포함된 Jwt 토큰을 통한 인증처리가 구현되었습니다. RS256 알고리즘 방식을 적용했으며, 현재 임시 토큰을 사용하고 있습니다. | API 호출 설정: POST https://$API_GATEWAY_DOMAIN/$ENV/tls 로 구성하였습니다. | . | Lambda . | SAM을 통한 배포 프로세스 구축: AWS SAM(Serverless Application Model)을 사용한 람다 배포 프로세스가 구축되었으며, 사용법도 함께 전달하였습니다. | SAMPLE 코드 업로드: JWT Authorization 및 Redis Search Lambda 함수 코드가 AWS CodeCommit을 통해 업로드되었습니다. | Lambda 코드 배포 예정: HAE 에서 실제 배포할 람다함수 소스를 업로드 예정 | . | GitLab . | 자격증명 설정: AWS S3에 접근하기 위한 GitLab AWS 자격증명 설정 방법 전달 완료. | 산출물 업로드 방법 가이드: GitLab에서 빌드 완료된 산출물을 지정된 S3 버킷에 업로드 하는 법 가이드 완료 | . | . 남은일 . | api gateway와 custom domain 연결 | Lambda source 업로드 후 opensearch 테스트 진행 | 실제 token을 이용한 jwt 인증 람다 테스트 | 배포 파이프라인 구축 필요 | . ",
    "url": "/docs/02_Tech/AWS/CloudFrontFunction#4-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFrontFunction#4-사용-사례"
  },"181": {
    "doc": "1. CloudFront Function vs Lambda@Edge 비교",
    "title": "1. CloudFront Function vs Lambda@Edge 비교",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFrontFunction",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFrontFunction"
  },"182": {
    "doc": "5. CloudShell",
    "title": "CloudShell을 사용하여 Docker Image 업로드 하기",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudShell#cloudshell%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-docker-image-%EC%97%85%EB%A1%9C%EB%93%9C-%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#cloudshell을-사용하여-docker-image-업로드-하기"
  },"183": {
    "doc": "5. CloudShell",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. CloudShell 사용하기 | 2. CloudShell 에서의 Docker 지원 | 3. CloudShell을 사용하여 Docker 이미지 업로드 단계 | . ",
    "url": "/docs/02_Tech/AWS/CloudShell#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#목차"
  },"184": {
    "doc": "5. CloudShell",
    "title": "글을 쓴 배경",
    "content": "AWS CloudShell을 사용하여 Docker 이미지를 ECR Repository에 업로드하는 방법에 대해 설명합니다. Mac으로 docker 이미지를 가져올 때 Linux 운영체제와 호환 문제를 피하기 위해 고민한 내용을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/CloudShell#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#글을-쓴-배경"
  },"185": {
    "doc": "5. CloudShell",
    "title": "글 요약",
    "content": "CloudShell을 활용하여 Docker Hub에서 이미지를 가져와 ECR에 업로드하는 방법입니다. ",
    "url": "/docs/02_Tech/AWS/CloudShell#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#글-요약"
  },"186": {
    "doc": "5. CloudShell",
    "title": "시작하기 전",
    "content": "이 튜토리얼은 특히 Mac 사용자에게 유용하며, AWS ECR 및 Docker에대한 기본적인 지식이 있는 분을 대상으로 작성되었습니다. ",
    "url": "/docs/02_Tech/AWS/CloudShell#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#시작하기-전"
  },"187": {
    "doc": "5. CloudShell",
    "title": "1. CloudShell 사용하기",
    "content": "CloudShell은 AWS 콘솔에서 리소스에 직접 액세스할 수 있는 셸을 제공합니다. Bash, PowerShell, Z shell과 같은 다양한 셸을 지원하며, 추가 다운로드나 설치 없이 AWS CLI 명령을 실행할 수 있습니다. CloudShell을 시작하면 Amazon Linux 2023을 기반으로 하는 컴퓨팅 환경이 제공됩니다. CloudShell 사용 시작하기: Cloudshell 시작하기 . ",
    "url": "/docs/02_Tech/AWS/CloudShell#1-cloudshell-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#1-cloudshell-사용하기"
  },"188": {
    "doc": "5. CloudShell",
    "title": "2. CloudShell 에서의 Docker 지원",
    "content": "AWS CloudShell은 현재 13개 리전에서 Docker를 지원합니다. 자세히 알아보기: AWS CloudShell, 이제 13개 리전에서 Docker 지원 . ",
    "url": "/docs/02_Tech/AWS/CloudShell#2-cloudshell-%EC%97%90%EC%84%9C%EC%9D%98-docker-%EC%A7%80%EC%9B%90",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#2-cloudshell-에서의-docker-지원"
  },"189": {
    "doc": "5. CloudShell",
    "title": "3. CloudShell을 사용하여 Docker 이미지 업로드 단계",
    "content": "Docker 이미지 가져오기: 먼저 CloudShell 환경으로 dockerhub에서 nignx와 같은 sample Docker 이미지를 가져옵니다. ECR에 업로드: 이미지가 CloudShell에 있으면, ECR 저장소에 업로드합니다. ",
    "url": "/docs/02_Tech/AWS/CloudShell#3-cloudshell%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-docker-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%97%85%EB%A1%9C%EB%93%9C-%EB%8B%A8%EA%B3%84",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell#3-cloudshell을-사용하여-docker-이미지-업로드-단계"
  },"190": {
    "doc": "5. CloudShell",
    "title": "5. CloudShell",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudShell",
    
    "relUrl": "/docs/02_Tech/AWS/CloudShell"
  },"191": {
    "doc": "2. Cloud Watch Alarm",
    "title": "CodeDeploy ECS Blue/Green 배포시 Install 단계 Timeout 시간 제한 조정 방법 (Feat. CloudWatch Alarm)",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#codedeploy-ecs-bluegreen-%EB%B0%B0%ED%8F%AC%EC%8B%9C-install-%EB%8B%A8%EA%B3%84-timeout-%EC%8B%9C%EA%B0%84-%EC%A0%9C%ED%95%9C-%EC%A1%B0%EC%A0%95-%EB%B0%A9%EB%B2%95-feat-cloudwatch-alarm",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#codedeploy-ecs-bluegreen-배포시-install-단계-timeout-시간-제한-조정-방법-feat-cloudwatch-alarm"
  },"192": {
    "doc": "2. Cloud Watch Alarm",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS CloudWatch 란? | 2. AWS CloudWatch 적용 . | 2.1 오류 상황 시나리오 . | 2.1.1 AWS ECS에서 서비스를 Blue/Green 방식으로 배포 진행 | 2.1.2 AWS CodeDeploy를 이용한 배포 과정 | 2.1.3 신규 배포된 task set의 컨테이너 상태 | . | 2.2 오류 상황 해결 방안 . | 2.2.1 AWS Code Deploy의 롤백 및 알람 설정 | . | . | 3. CloudWatch Metric Alarm 설정 . | 3.1 알림 설정 방법 . | 3.1.1 HealthyHostCount 알림 생성 | 3.1.2 UnHealthyHostCount 알림 생성 | 3.1.2 생성된 두 알림을 결합하여 복합 알림 만들기 | . | 3.2 AWS CloudWatch 누락된 데이터 처리 방법 | . | 4. 시나리오 해결 확인 | . ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#목차"
  },"193": {
    "doc": "2. Cloud Watch Alarm",
    "title": "글을 쓴 배경",
    "content": "AWS ECS로 Blue/Green 배포를 진행하던 중 신규 task set 배포 과정에서 문제가 발생할 경우 Code Deploy의 Install 단계에서 최대 60분 동안 재시도 후 자동으로 실패하고 롤백이 이루어집니다. 이러한 기본 설정으로 인해 발생하는 시간 지연을 최소화하기 위해, Install 단계의 타임아웃 시간을 조정할 수 있는 방법을 찾게 되었습니다. 관련 문서 : CodeDeploy ECS Blue/Green 배포 시 Install 단계 Timeout 시간 제한 조정 . ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#글을-쓴-배경"
  },"194": {
    "doc": "2. Cloud Watch Alarm",
    "title": "글 요약",
    "content": "AWS ECS에서 Blue/Green 배포를 진행할 때, CodeDeploy의 Install 단계에서 발생할 수 있는 지연을 최소화하기 위해 Timeout 설정을 조정하는 방법을 설명합니다. 본문은 CloudWatch Alarm을 사용하여 이러한 문제를 탐지하고 자동으로 대응하는 과정을 다룹니다. ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#글-요약"
  },"195": {
    "doc": "2. Cloud Watch Alarm",
    "title": "시작하기 전",
    "content": ". | AWS ECS와 CodeDeploy의 기본 작동 원리 | Blue/Green 배포 전략에 대한 이해 | AWS CloudWatch의 기본적인 사용법과 메트릭 시스템 | . ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#시작하기-전"
  },"196": {
    "doc": "2. Cloud Watch Alarm",
    "title": "1. AWS CloudWatch 란?",
    "content": "AWS CloudWatch는 AWS 리소스 상태를 모니터링하고 경보를 설정하여 자원의 상태 변화를 실시간으로 감지할 수 있는 서비스입니다. 사용 중인 AWS 서비스에 관한 지표가 자동으로 표시되고 해당 지표를 감시해 알림을 보내거나 지표에서 설정한 임계값을 위반한 경우 모니터링 중인 리소스를 자동으로 변경하는 경보를 생성할 수 있습니다. CloudWatch를 통해 시스템 전체의 리소스 사용률, 운영 상태를 파악할 수 있습니다. 참고자료 : Amazon CloudWatch란 무엇인가요? . ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#1-aws-cloudwatch-%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#1-aws-cloudwatch-란"
  },"197": {
    "doc": "2. Cloud Watch Alarm",
    "title": "2. AWS CloudWatch 적용",
    "content": "CloudWatch에서 제공하는 메트릭을 활용하여 AWS ECS의 Blue/Green 배포 중 발생할 수 있는 문제를 감지할 수 있습니다. 이 섹션은 CloudWatch의 Alarm 기능과 CodeDeploy의 롤백기능을 통해 code deploy 의 install 과정에 걸리는 지연 시간을 최소화 하는 과정을 설명합니다. 2.1 오류 상황 시나리오 . 2.1.1 AWS ECS에서 서비스를 Blue/Green 방식으로 배포 진행 . | 새로운 버전의 애플리케이션을 기존 서비스와 병행하여 배포합니다. | . 2.1.2 AWS CodeDeploy를 이용한 배포 과정 . AWS ECS에서 서비스를 Blue/Green 방식으로 배포할 때, AWS CodeDeploy를 사용이 강제화 됩니다. 특히, code deploy Install 단계에서는 새로운 task set을 배포하고, 각 task의 상태를 체크합니다. 이 단계는 새로운 task(컨테이너)가 기존 ECS 서비스에 배포되기 전 중요한 체크포인트 역할을 합니다. | AWS Code Deploy가 ECS에 신규 태스크 배포를 진행 중인 모습 | . | ECS Service에서 새로운 Task Set 배포되는 모습을 확인할 수 있습니다. | . 2.1.3 신규 배포된 task set의 컨테이너 상태 . 신규 배포된 태스크 중 일부에서 문제가 발생하여 Unhealthy 상태가 될 수 있습니다. code deploy는 헬스 체크를 통과하지 못한 컨테이너를 install 단계에서 지속적으로 체크하며 재배포를 시도해, 해당 단계 시간이 많이 지연될 수 있습니다. | Unhealthy Status 가 발생한 모습. 타겟그룹에서 확인 가능 | . | install 단계에서 지속적인 상태 체크 및 재배포 | . 2.2 오류 상황 해결 방안 . AWS Code Deploy와 Amazon CloudWatch를 결합하여 install 단계에서 배포가 지연되는 상황을 해결할 수 있습니다. 2.2.1 AWS Code Deploy의 롤백 및 알람 설정 . CodeDeploy에서는 CloudWatch 알림을 활용하여 배포 중 문제가 감지되었을 때 자동으로 이전 버전으로 롤백할 수 있는 기능을 제공합니다. 배포에 실패하거나 지정된 알림이 활성화될 경우 자동으로 마지막으로 성공한 버전을 재 배포하게 됩니다. | 설정 위치 | . | cloudwatch알람 및 CodeDeploy 롤백 설정 | . ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#2-aws-cloudwatch-%EC%A0%81%EC%9A%A9",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#2-aws-cloudwatch-적용"
  },"198": {
    "doc": "2. Cloud Watch Alarm",
    "title": "3. CloudWatch Metric Alarm 설정",
    "content": "활용할 지표 . | HealthyHostCount: Application Load Balancer에서 지정한 Target Group의 건강한 호스트 수를 나타냅니다. | UnhealthyHostCount: 오류 상태를 보고하는 호스트의 수를 나타냅니다. 이 메트릭도 target group에 등록된 대상을 기준으로, 비정상 상태의 호스트 수를 추적합니다. | . 해당 지표들은 실시간으로 target 그룹에 등록된 task의 건강 상태를 모니터링 합니다. 이를 통해 신규 태스크가 unhealthy 나는 상황을 빠르게 감지하고, code deploy의 install 단계가 1시간동안 지속적으로 재 배포를 시도하는 상황을 중단하고 가장 마지막으로 성공한 배포 내역으로 롤백할 수 있습니다. 참고 자료 : CloudWatch Application Load Balancer의 지표 . 3.1 알림 설정 방법 . CloudWatch에서는 서비스의 건강 상태를 모니터링 하기 위해 특정 지표를 이용하여 알림을 생성할 수 있습니다. 본 섹션에서는 HealthyHostCount와 UnhealthyHostCount 두 지표를 이용해 알림을 생성해 보겠습니다. 3.1.1 HealthyHostCount 알림 생성 . | 트리거 조건: HealthyHostCount 값이 설정한 임계값 미만으로 3분 동안 3개의 데이터 포인트가 연속해서 발생하면 알림이 트리거됩니다. | 임계값: 임계값을 1로 설정하여, HealthyHostCount가 평균적으로 1 미만인 경우 (즉, 모든 호스트가 건강하지 않은 경우) 알람이 울리도록 설정했습니다. | . | 누락 데이터 처리 : 누락된 데이터를 ‘good’으로 처리하여, 데이터가 없는 경우 임계값 위반으로 간주하지 않습니다. 이는 불필요한 알람을 방지하고, 실제 문제가 있을 때만 알람이 울리도록 합니다. | . 3.1.2 UnHealthyHostCount 알림 생성 . | 트리거 조건: UnhealthyHostCount 값이 설정한 임계값 이상으로 3분 동안 3개의 데이터 포인트가 연속해서 발생하면 알림이 트리거됩니다. | 임계값: 임계값을 1로 설정하여, UnhealthyHostCount가 최소 1 이상인 경우 (즉, 하나 이상의 호스트가 건강하지 않은 경우) 알람이 울리도록 설정했습니다. | . | 누락 데이터 처리 : 누락된 데이터를 ‘good’으로 처리하여, 데이터가 없는 경우 임계값 위반으로 간주하지 않습니다. 이는 불필요한 알람을 방지하고, 실제 문제가 있을 때만 알람이 울리도록 합니다. | . 3.1.2 생성된 두 알림을 결합하여 복합 알림 만들기 . 앞서 두 지표를 이용해 만든 알림을 선택하고 Create composite alarm 버튼을 클릭합니다. 두 지표가 모두 만족해야 알림이 울리도록 설정합니다. 논리연산자 AND/OR 혹은 NOT을 사용할 수 있습니다. 별다른 configure action을 선택하지 않고 경보만 울릴 수 있도록 설정합니다. 아래와 같은 알림을 만들었습니다. 3.2 AWS CloudWatch 누락된 데이터 처리 방법 . CloudWatch 알람을 설정할 때, 다양한 옵션을 통해 누락된 데이터를 어떻게 처리할지 결정할 수 있습니다. | notBreaching: 누락된 데이터를 임계값 위반으로 간주하지 않습니다. | breaching: 누락된 데이터를 임계값 위반으로 간주합니다. 이는 중요한 시스템 지표가 누락될 때 적합합니다. | ignore: 현재 알람 상태를 유지합니다. | missing: 모든 데이터 포인트가 누락된 경우 알람 상태를 ‘INSUFFICIENT_DATA’로 변경합니다. | . 데이터 누락 케이스 별 알람 상태 평가 . | 완전한 데이터가 있는 경우: CloudWatch는 가장 최근의 데이터 포인트를 기반으로 알람 상태를 평가합니다. | 일부 데이터가 누락된 경우: 필요한 최소한의 데이터 포인트가 존재한다면, 실제 데이터 포인트를 기반으로 알람 상태를 평가합니다. | 대부분의 데이터가 누락된 경우: 사용자가 지정한 누락된 데이터 처리 방법에 따라 알람 상태를 평가합니다. | . ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#3-cloudwatch-metric-alarm-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#3-cloudwatch-metric-alarm-설정"
  },"199": {
    "doc": "2. Cloud Watch Alarm",
    "title": "4. 시나리오 해결 확인",
    "content": ". | cloudwatch 경보 발생 | . | 경보로 인한 code deploy install 단계 timeout 적용 확인 | . | code deploy 롤백 확인 | . | cloud watch 경보 ok 정상 원복 확인 | . ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#4-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4-%ED%95%B4%EA%B2%B0-%ED%99%95%EC%9D%B8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm#4-시나리오-해결-확인"
  },"200": {
    "doc": "2. Cloud Watch Alarm",
    "title": "2. Cloud Watch Alarm",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch/cloudwatch-alarm"
  },"201": {
    "doc": "2. CloudWatch",
    "title": "AWS Cloud Watch",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudWatch#aws-cloud-watch",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch#aws-cloud-watch"
  },"202": {
    "doc": "2. CloudWatch",
    "title": "목차",
    "content": ". 참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/AWS/CloudWatch#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch#목차"
  },"203": {
    "doc": "2. CloudWatch",
    "title": "2. CloudWatch",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudWatch",
    
    "relUrl": "/docs/02_Tech/AWS/CloudWatch"
  },"204": {
    "doc": "2. CodePipeline",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CodePipeline#color-utilities",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline#color-utilities"
  },"205": {
    "doc": "2. CodePipeline",
    "title": "Table of contents",
    "content": ". 참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/CICD/CodePipeline#table-of-contents",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline#table-of-contents"
  },"206": {
    "doc": "2. CodePipeline",
    "title": "2. CodePipeline",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CodePipeline",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline"
  },"207": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "content": "AWS의 Lambda 함수 배포 과정을 자동화하는 방법을 소개합니다. AWS CodePipeline과 SAM(Serverless Application Model)을 활용해 코드의 변경이 있을 때 자동으로 배포 프로세스가 실행되도록 하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#aws-codepipeline%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-sam%EC%9C%BC%EB%A1%9C-lambda-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#aws-codepipeline을-이용해-sam으로-lambda-배포하기"
  },"208": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "목차",
    "content": ". | AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS CodeCommit Repository 구성 . | 1.1 전체 소스코드 구조 | 2. buildspec.yml 구성 . | 2.1 buildspec.yml 상세설명 | . | 3. samconfig.toml 구성 . | 3.1 samconfig.toml 상세설명 . | 3.1.1 [default.global.parameters] | . | . | awscli를 활용한 EC2 Ubuntu OS 배포 | . | 2. userdata를 이용한 Jenkins 배포 자동화 . | 2.1 userdata.txt | 2.2 userdata.txt 상세 설명 | . | jenkins 접속하기 | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#목차"
  },"209": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "글을 쓴 배경",
    "content": "Lambda 함수를 Git으로 관리하고, 배포 과정을 자동화하는 방법을 고민하던 중 작성되었습니다. ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#글을-쓴-배경"
  },"210": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "글 요약",
    "content": "AWS CodePipeline은 소스 스테이지로 지정된 AWS CodeCommit의 소스 변경 사항을 감지하고, . CodeBuild를 빌드 스테이지를 사용하여 SAM을 통해 Lambda 함수를 배포하는 과정을 소개합니다. Lambda 함수 코드와 관련 파이프라인 구성 파일은 모두 AWS CodeCommit 레포지토리에 저장되어 관리됩니다. AWS CodePipeline : AWS에서 제공하는 통합 CI/CD 서비스 입니다. 코드의 변경 사항을 자동으로 배포할 수 있습니다. AWS SAM : AWS 서버리스 애플리케이션의 구축 및 배포를 돕는 프레임워크입니다. SAM은 배포 시 AWS CloudFormation 템플릿으로 변환되어, Lambda, API Gateway, DynamoDB 등 AWS 서버리스 서비스의 구성을 코드 형태로 관리할 수 있습니다. ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#글-요약"
  },"211": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "시작하기 전",
    "content": "AWS Code Series 및 AWS Lambda, SAM에 대한 기본 지식이 필요합니다. 사용한 레포지토리 주소 . ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#시작하기-전"
  },"212": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "1. AWS CodeCommit Repository 구성",
    "content": "소스 코드 저장소로 AWS CodeCommit을 사용합니다. CodeCommit은 AWS에서 제공하는 GIT 형상 관리 서비스로, 프라이빗 레포지토리를 제공합니다. 1.1 전체 소스코드 구조 . | 실제 프로젝트 파일 구조 | 파일 및 디렉토리 구조 간단 설명 | . | | | . 2. buildspec.yml 구성 . buildspec.yml은 CodeBuild 프로젝트 구성파일입니다. version: 0.2 env: shell: bash phases: install: runtime-versions: nodejs: 20 commands: build: commands: - echo Build started on `date` - ls -alh ./ - sam build - sam deploy --no-confirm-changeset --no-progressbar --no-fail-on-empty-changeset . 2.1 buildspec.yml 상세설명 . 2.1.1 sam build . template.yaml 파일에 정의된 AWS 서버리스 애플리케이션의 빌드 작업을 수행합니다. SAM은 템플릿에 정의된 각 AWS 리소스(예: Lambda 함수)에 필요한 종속성을 설치하고, 이를 포함한 배포 패키지를 구성합니다. Node.js를 예로 들면, npm install을 통해 필요한 라이브러리를 설치하는 것과 유사합니다. 2.1.2 sam deploy --no-confirm-changeset --no-progressbar --no-fail-on-empty-changeset . | sam build를 통해 생성된 배포 패키지를 sam deploy는 AWS CloudFormation 스택으로 배포합니다. 여러 하위 옵션들과 함께 사용될 수 있습니다. | --no-confirm-changeset: SAM이 AWS CloudFormation이 리소스를 생성 혹은 업데이트할 때 사용자의 확인 절차 없이 바로 진행합니다. | --no-progressbar: 배포 프로세스 progress bar을 표시하지 않도록 합니다. | --no-fail-on-empty-changeset: 만약 변경 사항이 없는 경우에도 배포 프로세스가 실패하지 않도록 합니다. | . - sam build - sam deploy --no-confirm-changeset --no-progressbar --no-fail-on-empty-changeset . 3. samconfig.toml 구성 . samconfig.toml은 sam deploy 실행 시 포함되는 AWS SAM CLI 명령의 파라미터 값을 저장하고, 명령 실행 시 그 내용이 적용할 수 있게 해주는 파일입니다. sam deploy 명령을 간소화 해줍니다. toml 혹은 yaml 형식도 지원됩니다. 만약 명령줄에서 직접 제공된 파라미터 값이 있다면 그 값이 구성 파일보다 우선합니다. sam deploy --guided 명령어를 통해 애플리케이션을 배포하는 데 필요한 설정을 대화형으로 수행할 수 있습니다. 설정된 값은 samconfig.toml에 저장됩니다. 참조 문서 : AWS SAMCLI구성 파일 . version=0.1 [default.global.parameters] stack_name = \"common-stack\" [environment.command.parameters] option = \"parameter value\" [default.deploy.parameters] stack_name = \"stack-lambda\" s3_bucket = \"kkm-s3\" s3_prefix = \"\" region = \"ap-northeast-2\" capabilities = \"CAPABILITY_IAM\" [default.build.parameters] no_beta_features = true . 3.1 samconfig.toml 상세설명 . 3.1.1 [default.global.parameters] . 모든 SAM 명령에 적용되는 기본 파라미터를 지정합니다. | stack_name - AWS CloudFormation 스택 이름을 정의합니다. | . template.yaml 파일에 정의된 AWS 서버리스 애플리케이션의 빌드 작업을 수행합니다. version: 파일 형식의 버전을 명시합니다. [default.global.parameters]: 모든 SAM 명령에 적용되는 전역 설정을 정의합니다. stack_name: 기본적으로 사용될 AWS CloudFormation 스택의 이름을 설정합니다. 배포 설정 [default.deploy.parameters] stack_name: 배포할 때 사용될 CloudFormation 스택의 이름입니다. s3_bucket: SAM 패키지를 업로드할 Amazon S3 버킷의 이름입니다. s3_prefix: S3 버킷 내에서 SAM 패키지를 저장할 경로(프리픽스)입니다. region: 배포 대상 AWS 리전을 지정합니다. confirm_changeset: 배포 전 변경 세트를 확인할지 여부를 결정합니다. (true 설정 시 확인 절차 필요) capabilities: CloudFormation 스택 생성 시 필요한 권한을 명시합니다. (CAPABILITY_IAM은 IAM 리소스 생성 권한을 부여) 빌드 설정 [default.build.parameters] no_beta_features: 베타 기능의 사용 여부를 결정합니다. (true로 설정 시 베타 기능 비활성화) . awscli를 활용한 EC2 Ubuntu OS 배포 . aws ec2 run-instances \\ --image-id ${UBUNTU_AMI_ID} \\ --count 1 \\ --instance-type t3.large \\ --key-name ${KEY_NAME} \\ --iam-instance-profile Name=${INSTANCE_PROFILE_ROLE} \\ --subnet-id ${SUBNET_ID} \\ --security-group-ids ${JENKINS_SG} \\ --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=jenkins-aws-cli-generate}]' \\ --block-device-mappings 'DeviceName=/dev/sda1,Ebs={VolumeSize=100}' \\ --user-data file://userdata.txt . ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#1-aws-codecommit-repository-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#1-aws-codecommit-repository-구성"
  },"213": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "2. userdata를 이용한 Jenkins 배포 자동화",
    "content": "2.1 userdata.txt . 아래 스크립트는 EC2 인스턴스 생성 시 실행되며 Jenkins을 설치하기 위한 환경을 구축합니다. Jenkins 디렉토리 생성, Docker 설치 및 설정, Jenkins Docker 컨테이너 실행 등으로 구성되었습니다. #!/bin/bash # 사용자 변수 설정 USER_NAME=ubuntu # Jenkins 디렉토리 생성 및 디렉토리 소유권변경 mkdir -p /home/ubuntu/jenkins/jenkins_home chown -R ubuntu:ubuntu /home/ubuntu/jenkins # Docker 설치 echo \"1. [docker program installation] start\" apt-get update -y curl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh usermod -aG docker ${USER_NAME} # Docker 서비스 활성화 및 시작 systemctl enable docker systemctl start docker # Jenkins Docker 컨테이너 실행 docker run -d -p 80:8080 -p 50000:50000 \\ --name jenkins \\ -v /home/ubuntu/jenkins/jenkins_home:/var/jenkins_home \\ jenkins/jenkins:jdk17 # Jenkins 초기 관리자 비밀번호 저장 echo \"Waiting for Jenkins to initialize...\" sleep 30 # Jenkins 초기화를 기다림 docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword &gt; /home/ubuntu/jenkins/initialAdminPassword.txt chown ubuntu:ubuntu /home/ubuntu/jenkins/initialAdminPassword.txt . 2.2 userdata.txt 상세 설명 . 사용자 변수 지정 . | Jenkins과 Docker를 실행할 사용자 이름을 설정합니다. USER_NAME=ubuntu . | . Jenkins 디렉토리 생성 및 디렉토리 소유권변경 . mkdir -p /home/ubuntu/jenkins/jenkins_home chown -R ubuntu:ubuntu /home/ubuntu/jenkins . Docker 설치 . | 공식 Docker 설치 스크립트를 다운받아 실행합니다. 설정한 USER_NAME에 해당하는 사용자를 Docker 그룹에 추가합니다. | 기본적으로 도커 실행 권한은 root에만 있습니다. ${USER_NAME} 사용자를 Docker 그룹에 추가하여, sudo 없이 Docker 명령을 실행할 수 있도록 합니다. | . echo \"1. [docker program installation] start\" apt-get update -y curl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh usermod -aG docker ${USER_NAME} . Docker 서비스 활성화 및 시작 . systemctl enable docker systemctl start docker . Jenkins Docker 컨테이너 실행 . | -d 컨테이너 백그라운드 실행 | -p 8080:8080 젠킨슨은 기본적으로 8080 포트에서 웹 인터페이스를 제공합니다. 호스트 포트를 변경하여 외부에서 Jenkins 웹 인터페이스에 접근하는 포트를 변경할 수 있습니다. | -p 50000:50000 젠킨슨 에이전트가 실행되기 위한 포트도 컨테이너에 연결해 줍니다. | –name 컨테이너 이름을 지정합니다. | -v Jenkins 데이터를 호스트 서버에 마운트하기 위한 설정입니다. Jenkins 설정 및 빌드데이터가 컨테이너 재시작 후에도 유지됩니다. | . # Jenkins Docker 컨테이너 실행 docker run -d -p 8080:8080 -p 50000:50000 \\ --name jenkins \\ -v /home/ubuntu/jenkins/jenkins_home:/var/jenkins_home \\ jenkins/jenkins:jdk17 . Jenkins 초기 관리자 비밀번호 저장 . | 컨테이너 내부에 있는 var/jenkins_home/secrets 디렉토리내에 있는 비밀번호를 확인합니다. | echo \"Waiting for Jenkins to initialize...\" sleep 30 # Jenkins 초기화를 기다림 docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword &gt; /home/ubuntu/jenkins/initialAdminPassword.txt chown ubuntu:ubuntu /home/ubuntu/jenkins/initialAdminPassword.txt . | . ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#2-userdata%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-jenkins-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#2-userdata를-이용한-jenkins-배포-자동화"
  },"214": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "jenkins 접속하기",
    "content": "http://:8080 에 접속합니다. 서버에 접속한 후 Administrator password를 확인합니다. /home/ubuntu/jenkins/initialAdminPassword.txt 해당 경로에서 확인 가능합니다. 컨테이너를 배포할 때 확인했던 비밀번호를 입력해줍니다. install suggested plugins를 클릭하고 젠킨슨을 설치해줍니다. | 이미 jenkins/jenkins:jdk17을 이용해서 젠킨슨을 설치했기 때문에 Oracle Java SE Development Kit Installer 해당 플러그인은 삭제하여도 무방합니다. | . 접속 성공 . ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#jenkins-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#jenkins-접속하기"
  },"215": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "별첨",
    "content": "설치된 플러그인에대한 간략한 설명 . Pipeline: REST API: 파이프라인 상태, 결과 등을 조회할 수 있습니다. Pipeline: Stage View: 파이프라인의 각 스테이지를 시각적으로 표현해주는 UI를 제공합니다. Oracle Java SE Development Kit Installer: Oracle의 웹사이트에서 Java SE Development Kit(JDK)를 다운로드하여 설치할 수 있게 해주는 플러그인입니다. Command Agent Launcher: 지정된 명령어를 사용하여 에이전트를 실행할 수 있게 해주는 에이전트 관리 플러그인입니다. SSH server: Jenkins에 SSH 서버 기능을 추가하여, CLI 명령을 통해 Jenkins를 원격으로 조작할 수 있게 해주는 플러그인입니다. Authentication Tokens API: 자격증명을 인증 토큰으로 변환하는 API를 제공합니다. Jenkins에서 보다 안전한 인증 방법을 구현할 때 사용됩니다. Docker Pipeline: Jenkins 파이프라인에서 Docker 컨테이너를 빌드하고 사용할 수 있게 해주는 플러그인입니다. Lockable Resources: 복수의 작업이 동일한 외부 자원에 의존하는 복잡한 CI/CD 파이프라인을 구성할 때 유용합니다. 이 플러그인을 사용함으로써 자원 충돌을 방지하고, 빌드 프로세스의 안정성과 효율성을 높일 수 있습니다. Role-based Authorization Strategy: 사용자 권한을 역할 기반으로 관리할 수 있게 해주는 보안 플러그인입니다. JSch dependency: SSH 연결을 위한 Java 라이브러리인 JSch를 Jenkins 플러그인으로 제공합니다. Maven Integration: Maven 프로젝트와 Jenkins 사이의 통합을 제공합니다. Docker Commons: 다양한 Docker 관련 플러그인에서 사용할 수 있는 공통 기능을 제공합니다. HTML Publisher: 빌드 후 생성된 HTML 보고서를 Jenkins에서 직접 볼 수 있게 해주는 플러그인입니다. Role-based Authorization Strategy: 사용자와 그룹에 역할 기반의 접근 제어를 허용하는 보안 플러그인입니다. Subversion: Jenkins에서 Apache Subversion 지원을 추가합니다. SVNKit을 통해 Subversion 저장소와의 상호 작용을 가능하게 합니다. Favorite: 사용자가 특정 작업을 ‘즐겨찾기’로 설정할 수 있게 해주는 플러그인입니다. Parameterized Trigger: 한 빌드가 완료된 후 다양한 방법으로 새 빌드를 트리거할 수 있게 해주는 플러그인입니다. 새 빌드에 파라미터를 전달하는 것도 가능합니다. Bitbucket Branch Source: Bitbucket Cloud 및 Bitbucket Server를 사용하여 프로젝트의 소스로 활용할 수 있게 해주는 플러그인입니다. Blue Ocean: 이들 모두 Blue Ocean UI와 관련된 플러그인으로, Jenkins의 사용자 경험을 현대화하고, 파이프라인 관리 및 시각화를 향상시키기 위해 설계되었습니다. DataTables.net API: jQuery DataTables를 Jenkins 플러그인에 제공합니다. 이를 통해 HTML 테이블에 고급 기능을 쉽게 추가할 수 있습니다. ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#별첨"
  },"216": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "FAQ",
    "content": "Q: 설치된 젠킨슨에서 플러그인을 재대로 다운받지 못하면 어떻게 해야 하나요? . A: 보안 그룹 설정에 플러그인을 다운받기위한 HTTP, HTTPS 포트가 열려 있는지 확인합니다. ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#faq",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda#faq"
  },"217": {
    "doc": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "title": "2-1. AWS CodePipeline을 이용해 SAM으로 Lambda 배포하기",
    "content": " ",
    "url": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda",
    
    "relUrl": "/docs/02_Tech/CICD/CodePipeline/codepipeline-sam-lambda"
  },"218": {
    "doc": "Security6",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/01_languages/Java/Security6#color-utilities",
    
    "relUrl": "/docs/01_languages/Java/Security6#color-utilities"
  },"219": {
    "doc": "Security6",
    "title": "Table of contents",
    "content": ". | TOC | . ",
    "url": "/docs/01_languages/Java/Security6#table-of-contents",
    
    "relUrl": "/docs/01_languages/Java/Security6#table-of-contents"
  },"220": {
    "doc": "Security6",
    "title": "Security6",
    "content": " ",
    "url": "/docs/01_languages/Java/Security6",
    
    "relUrl": "/docs/01_languages/Java/Security6"
  },"221": {
    "doc": "2. ECS 용량공급자",
    "title": "ECS 용량공급자",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#ecs-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#ecs-용량공급자"
  },"222": {
    "doc": "2. ECS 용량공급자",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 용량공급자란 | 2. AWS ECS Cluster 에서 용량공급자 선택하기 | . # . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#목차"
  },"223": {
    "doc": "2. ECS 용량공급자",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#%EB%AA%A9%EC%B0%A8-1",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#목차-1"
  },"224": {
    "doc": "2. ECS 용량공급자",
    "title": "글을 쓴 배경",
    "content": "ECS 서비스를 이용해 sample application 도커 이미지를 배포하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#글을-쓴-배경"
  },"225": {
    "doc": "2. ECS 용량공급자",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#글-요약"
  },"226": {
    "doc": "2. ECS 용량공급자",
    "title": "시작하기 전",
    "content": "참고자료 AWS ECS Workshop . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#시작하기-전"
  },"227": {
    "doc": "2. ECS 용량공급자",
    "title": "1. 용량공급자란",
    "content": "Amazon Elastic Container Registry(ECR)에 ECS에서 실행되는 애플리케이션 이미지를 저장 및 관리할 수 있습니다. ECS TaskDefinition에 Amazon ECR 리포지토리를 지정하기만 하면 Amazon ECS에서 지정된 이미지를 가져와 배포합니다. 우선, 배포할 이미지를 업로드 해줍니다. 저는 nginx container 이미지를 업로드해주었습니다. 참고자료 : Amazon ECR . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#1-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#1-용량공급자란"
  },"228": {
    "doc": "2. ECS 용량공급자",
    "title": "2. AWS ECS Cluster 에서 용량공급자 선택하기",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#2-aws-ecs-cluster-%EC%97%90%EC%84%9C-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider#2-aws-ecs-cluster-에서-용량공급자-선택하기"
  },"229": {
    "doc": "2. ECS 용량공급자",
    "title": "2. ECS 용량공급자",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-capacity-provider"
  },"230": {
    "doc": "1. ECS 구축하기",
    "title": "ECS CLuster 구축 하기",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#ecs-cluster-%EA%B5%AC%EC%B6%95-%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#ecs-cluster-구축-하기"
  },"231": {
    "doc": "1. ECS 구축하기",
    "title": "목차",
    "content": ". | ECS . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS ECR 레포지토리 생성 | 2. AWS ECS Cluster 생성 . | 2.1 ECS 배포 방식 선정 | 2.2 ECS 클러스터 생성 . | 2.3.1 vpc 네트워크 인프라 구축 | 2.3.2 보안 그룹 설정 | 2.3.3 IAM 역할 만들기 | . | 2.3 ECS 클러스터 구성하기 . | 2.3.1 인프라 | 2.3.2 Amazon EC2 인스턴스의 네트워크 설정 | 2.3.3 생성된 Auto Scaling Group 확인하기 | . | 2.4 ECS TaskDefinition 생성 . | 2.4.1 인프라 요구 사항 . | 2.4.1.1 시작 유형 | . | 2.4.2 인프라 요구 사항 | 2.4.3 인프라 요구 사항 | 2.4.1 인프라 요구 사항 | 컨테이너 - 1 | . | 2.3 ECS IAM 역할 수정 | 2.3 ALB 생성 후 TaskDefinition 기반으로 어플리케이션 배포 | . | . | . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#목차"
  },"232": {
    "doc": "1. ECS 구축하기",
    "title": "ECS",
    "content": "Amazon Elastic Container Service(Amazon ECS)는 완전관리형 컨테이너 오케스트레이션 서비스입니다. 다른 AWS 서비스와 통합을 통해 ECS에 새로운 기능을 추가할 수도 있습니다. ECS는 EC2 뿐만아니라 AWS Fargate를 지원하여 컨테이너에 적합한 서버리스 컴퓨팅 환경을 제공합니다. ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#ecs",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#ecs"
  },"233": {
    "doc": "1. ECS 구축하기",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#%EB%AA%A9%EC%B0%A8-1",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#목차-1"
  },"234": {
    "doc": "1. ECS 구축하기",
    "title": "글을 쓴 배경",
    "content": "ECS 서비스를 이용해 sample application 도커 이미지를 배포하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#글을-쓴-배경"
  },"235": {
    "doc": "1. ECS 구축하기",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#글-요약"
  },"236": {
    "doc": "1. ECS 구축하기",
    "title": "시작하기 전",
    "content": "참고자료 AWS ECS Workshop . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#시작하기-전"
  },"237": {
    "doc": "1. ECS 구축하기",
    "title": "1. AWS ECR 레포지토리 생성",
    "content": "Amazon Elastic Container Registry(ECR)에 ECS에서 실행되는 애플리케이션 이미지를 저장 및 관리할 수 있습니다. ECS TaskDefinition에 Amazon ECR 리포지토리를 지정하기만 하면 Amazon ECS에서 지정된 이미지를 가져와 배포합니다. 우선, 배포할 이미지를 업로드 해줍니다. 저는 nginx container 이미지를 업로드해주었습니다. 참고자료 : Amazon ECR . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#1-aws-ecr-%EB%A0%88%ED%8F%AC%EC%A7%80%ED%86%A0%EB%A6%AC-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#1-aws-ecr-레포지토리-생성"
  },"238": {
    "doc": "1. ECS 구축하기",
    "title": "2. AWS ECS Cluster 생성",
    "content": "2.1 ECS 배포 방식 선정 . ECS는 다음 두 가지 배포 방식을 제공합니다. 본 블로그에서는 EC2 방식을 선택하여 ECS 서비스를 배포합니다. | 구분 | EC2 | Fargate | . | 관리 유형 | 사용자 관리 | AWS 관리 (서버리스) | . | 적합한 사용 사례 | - 규정 준수 필요한 워크로드 - 사용자 정의 환경 필요한 워크로드 - 고정 비용 구조 선호 | - 마이크로서비스 아키텍처 - 이벤트 기반 컴퓨팅 | . | 장점 | - 다양한 인스턴스 유형 중 최적 선택 가능 - 세밀한 리소스 설정 가능 - 규정 준수 및 보안 커스터마이징 | - 인프라 관리 불필요, 개발에 집중 - 자동 스케일링 및 운영 용이 | . | 단점 | - 인스턴스 관리 및 보안 업데이트 필요 - 모니터링 및 장애 대응 필요 | - 특정 인스턴스 유형 선택 불가 - 일부 고급 기능 사용 제한 (예: GPU, EBS) | . | 비용 | - 인스턴스 비용 기준 - 예약 인스턴스로 비용 절감 가능 | - 사용량(CPU/MEM) 기준 청구 - 일반적으로 EC2 대비 비용 높음 | . | 선택 포인트 | - 세밀한 컨트롤 및 규정 준수 요구 사항이 있는 경우 - 장기적 비용 최적화 원하는 경우 | - 인프라 관리 부담 없이 개발에 집중하고자 하는 경우 - 빠른 배포 및 자동 스케일링이 중요한 경우 | . 2.2 ECS 클러스터 생성 . 2.3.1 vpc 네트워크 인프라 구축 . 본 블로그에서는 AWS에서 제공하는 default VPC를 사용합니다. 혹은 workshop에서 제공하는 cloudformation을 사용하거나, 사용자 정의 VPC를 구성할 수 있습니다. 2.3.2 보안 그룹 설정 . ALB 보안 그룹: 80, 443 포트를 열어줍니다. EC2 인스턴스 보안 그룹: ALB로부터 오는 모든 트래픽을 허용합니다. 2.3.3 IAM 역할 만들기 . 이미지를 배포할 EC2 에 부여할 IAM 역할을 생성합니다. 엔터티 유형 선택: AWS 서비스 -&gt; EC2 . 정책 추가: AmazonEC2ContainerServiceforEC2Role, AmazonSSMManagedInstanceCore . 추가 권한: 필요한 경우, 예를 들어 S3 접근 권한, 추가 정책을 포함합니다. s3 접근 권한 정책 추가 예시 json 파일입니다. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"s3:ListAllMyBuckets\", \"Resource\": \"*\" }, { \"Sid\": \"ListObjectsInBucket\", \"Effect\": \"Allow\", \"Action\": [ \"s3:ListBucket\" ], \"Resource\": [ \"arn:aws:s3:::s3-an2-prd-instance-bucket\", \"arn:aws:s3:::s3-an2-prd-instance-bucket/*\" ] }, { \"Sid\": \"AllObjectActions\", \"Effect\": \"Allow\", \"Action\": \"s3:*Object*\", \"Resource\": [ \"arn:aws:s3:::s3-an2-prd-instance-bucket\", \"arn:aws:s3:::s3-an2-prd-instance-bucket/*\" ] } ] } . 2.3 ECS 클러스터 구성하기 . 2.3.1 인프라 . Auto Scaling 그룹 생성: Amazon Linux 2 운영 체제를 선택합니다. EC2 인스턴스 역할: 앞서 생성한 EC2용 IAM 역할을 지정합니다. 2.3.2 Amazon EC2 인스턴스의 네트워크 설정 . Subnet과 VPC 선택: 인스턴스가 위치할 네트워크를 지정합니다. 보안 그룹 지정: EC2 인스턴스용 보안 그룹을 선택합니다. 앞서 생성한 보안그룹을 선택해 줍니다. 2.3.3 생성된 Auto Scaling Group 확인하기 . ECS 클러스터 생성 시 자동으로 생성된 Auto Scaling Group을 확인합니다. Auto Scaling Group에 연결된 시작 템플릿 (Launch Template ) 을 수정하여 EC2 인스턴스의 용량이나 다른 설정을 컨트롤 할 수 있습니다. Launch template 을 수정하여 용량을 변경해보겠습니다. 템플릿 관리를 유연하게 하기위해 네트워크 설정은 포함되지 않게 합니다. launch template을 수정했다면 시작 템플릿 편집을 클릭하여 버전을 2 혹은 latest로 수정합니다. 템플릿 버전을 적용하기 위해 새로고침을 해줍니다. 참고 자료 : Launch Template 수정하기 . 2.4 ECS TaskDefinition 생성 . 어플리케이션을 ecs에 배포할 명세서 역할을 하는 태스크 정의를 생성해봅니다. 2.4.1 인프라 요구 사항 . 2.4.1.1 시작 유형 . | FARGATE | EC2 | . ECS가 작업 또는 서비스를 시작하는 위치를 결정합니다. 작업정의 - 시작 유형 요구 사항과 일치하지 않으면 . 작업 정의 매개변수는 시작 유형에 허용된 . 작업 정의에 지정된 시작 유형에 따라 Amazon ECS가 작업 또는 서비스를 시작하는 위치가 결정됩니다. 작업 정의 매개변수는 시작 유형에 허용된 값을 기준으로 검증됩니다. 기본적으로 AWS Fargate가 설정되어 있습니다. Amazon EC2 인스턴스를 선택할 수도 있습니다. Amazon ECS는 서비스를 생성하거나 태스크를 실행할 때 지정된 인프라 유형에서 해당 태스크 정의를 사용할 수 없는 경우 오류를 반환합니다. 이 필드는 requiresCompatibilities 태스크 정의 파라미터에 해당합니다. 2.4.2 인프라 요구 사항 . 2.4.3 인프라 요구 사항 . 2.4.1 인프라 요구 사항 . 컨테이너 - 1 . 태크스 역할 생성 . 2.3 ECS IAM 역할 수정 . 2.3 ALB 생성 후 TaskDefinition 기반으로 어플리케이션 배포 . ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#2-aws-ecs-cluster-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create#2-aws-ecs-cluster-생성"
  },"239": {
    "doc": "1. ECS 구축하기",
    "title": "1. ECS 구축하기",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS/ecs-cluster-create",
    
    "relUrl": "/docs/02_Tech/AWS/ECS/ecs-cluster-create"
  },"240": {
    "doc": "1. ECS",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS#color-utilities",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#color-utilities"
  },"241": {
    "doc": "1. ECS",
    "title": "Table of contents",
    "content": ". | AWS EC2에서 Docker를 사용하여 Jenkins 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS EC2 Ubuntu OS를 awscli를 통해 배포 | . | . ",
    "url": "/docs/02_Tech/AWS/ECS#table-of-contents",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#table-of-contents"
  },"242": {
    "doc": "1. ECS",
    "title": "AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "content": "AWS EC2 인스턴스에 Docker를 사용하여 Jenkins를 배포하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/ECS#aws-ec2%EC%97%90%EC%84%9C-docker%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-jenkins-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#aws-ec2에서-docker를-사용하여-jenkins-배포하기"
  },"243": {
    "doc": "1. ECS",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/02_Tech/AWS/ECS#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#목차"
  },"244": {
    "doc": "1. ECS",
    "title": "글을 쓴 배경",
    "content": "Jenkins를 AWS EC2 인스턴스에 설치하는 과정을 기록하기 위해 작성하였습니다. ",
    "url": "/docs/02_Tech/AWS/ECS#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#글을-쓴-배경"
  },"245": {
    "doc": "1. ECS",
    "title": "글 요약",
    "content": "AWS EC2 인스턴스에 userdata를 이용하여 Docker로 Jenkins를 Ubuntu OS에 배포하는 방법을 공유합니다. AWS EC2 인스턴스 생성부터 Docker 이미지를 이용한 배포 프로세스까지 스크립트를 이용해 한번에 설치할 수 있도록 구성하였습니다. ",
    "url": "/docs/02_Tech/AWS/ECS#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#글-요약"
  },"246": {
    "doc": "1. ECS",
    "title": "시작하기 전",
    "content": "AWS, Docker, Jenkins에 대한 기본적인 이해가 있으신 분들을 위해 작성되었습니다. AWS EC2 인스턴스 생성 및 설정, Docker에 대한 기본 지식이 필요합니다. Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/AWS/ECS#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#시작하기-전"
  },"247": {
    "doc": "1. ECS",
    "title": "1. AWS EC2 Ubuntu OS를 awscli를 통해 배포",
    "content": "참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/AWS/ECS#1-aws-ec2-ubuntu-os%EB%A5%BC-awscli%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#1-aws-ec2-ubuntu-os를-awscli를-통해-배포"
  },"248": {
    "doc": "1. ECS",
    "title": "1. ECS",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS",
    
    "relUrl": "/docs/02_Tech/AWS/ECS"
  },"249": {
    "doc": "5. Elastic Cache",
    "title": "Elastic Cache",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ElasticCache#elastic-cache",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#elastic-cache"
  },"250": {
    "doc": "5. Elastic Cache",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. 개요 | 2. 동작 방식 | 3. 적용 사례 | 4. Memcached와 Redis 비교 | 5. 핵심 개념 | 5. 고려 사항 | 6. 적용 방안 | . ",
    "url": "/docs/02_Tech/AWS/ElasticCache#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#목차"
  },"251": {
    "doc": "5. Elastic Cache",
    "title": "글을 쓴 배경",
    "content": "웹 어플리케이션의 성능 향상을 고민하던 중 elastic cache를 사용하게 되었습니다. ",
    "url": "/docs/02_Tech/AWS/ElasticCache#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#글을-쓴-배경"
  },"252": {
    "doc": "5. Elastic Cache",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ElasticCache#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#글-요약"
  },"253": {
    "doc": "5. Elastic Cache",
    "title": "시작하기 전",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ElasticCache#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#시작하기-전"
  },"254": {
    "doc": "5. Elastic Cache",
    "title": "1. 개요",
    "content": "Amazon ElastiCache는 Memcached와 Redis 프로토콜을 지원하는 완전 관리형 인메모리 캐싱 서비스입니다. 이 서비스는 실시간 사용 사례를 지원하며, 읽기가 많은 애플리케이션의 대량 작업 부하를 처리하거나 계산 처리가 방대한 작업 부하를 개선하는 데 사용됩니다. ",
    "url": "/docs/02_Tech/AWS/ElasticCache#1-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#1-개요"
  },"255": {
    "doc": "5. Elastic Cache",
    "title": "2. 동작 방식",
    "content": ". | Cache - ElasticCache는 애플리케이션과 데이터베이스의 성능을 향상시키기 위해, 데이터를 메모리에 저장하여 빠르게 접근할 수 있습니다. | Ephemeral data store ( 임시 데이터 저장소 ) . | 세션 스토어 : 사용자의 세션 정보를 빠르게 읽고 쓰기 위해 캐시 사용 | 게임 리더보드 : 점수 같은 데이터를 실시간으로 업데이트하고 조회하는데 사용 | 미디어 스트리밍 : 스트리밍 서비스에서 필요한 데이터를 저장하고 전달하는데 사용 | 분석 데이터 스토어 : 분석 처리를 위해 접근해야하는 대량의 데이터를 저장하는데 사용 | . | Key Service benefits . | Microsecond speed: 매우 빠른 데이터 액세스를 제공 | Fully managed: 하드웨어 프로비저닝, 소프트웨어 패치, 설정, 모니터링 등의 관리 작업을 AWS가 대신 처리합니다. | High availability: 다중 가용 영역 배포를 지원하여, 한 영역에 장애가 발생해도 서비스가 지속될 수 있도록 합니다. | Security and compliance: 데이터 전송과 저장 시 보안을 유지하며, 기업의 규정 준수 요구사항을 충족합니다. | Fully compatible with Redis and Memcached: 오픈 소스 인메모리 데이터 스토어와 호환되어, 익숙한 도구와 프로세스를 사용할 수 있습니다. | Cost optimization: 사용량에 따른 비용 책정으로, 필요한 만큼만 비용을 지불하며, 예약 인스턴스를 통해 비용을 더 절감할 수 있습니다. | . | Integrate with other AWS Services . | ElastiCache는 AWS의 여러 다른 서비스와 통합될 수 있습니다. | . | . ",
    "url": "/docs/02_Tech/AWS/ElasticCache#2-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#2-동작-방식"
  },"256": {
    "doc": "5. Elastic Cache",
    "title": "3. 적용 사례",
    "content": "읽기 중심의 애플리케이션 부하 감소: 소셜 네트워킹, 게임, 미디어 공유 등 읽기가 많은 작업에 적합합니다. 고도의 데이터 구조 지원: Redis를 이용해 데이터베이스 계층을 효과적으로 확장할 수 있으며, 복잡한 데이터 작업을 더 효율적으로 수행할 수 있습니다. | 백엔드 데이터베이스 로드 감소: 빠른 데이터 접근으로 백엔드 부하를 줄이고 총 소유 비용을 절감할 수 있습니다. | 실시간 애플리케이션 데이터 캐싱: 필요할 때 즉각적인 데이터 제공을 통해 사용자 경험을 개선합니다. | 세션 스토어: 대규모 온라인 애플리케이션에서 세션 정보 관리를 효율적으로 수행합니다. | 순위표: 게임이나 다른 경쟁적 환경에서 실시간 순위표를 관리합니다. | . 데이터 캐싱: 사용자가 자주 액세스하는 데이터를 빠르게 제공하기 위해 캐시에 저장합니다. 세션 스토어, 게임 리더보드, 스트리밍 및 분석: 이러한 사용 사례는 내구성을 요구하지 않으므로 ElastiCache를 주 데이터 저장소로 활용할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/ElasticCache#3-%EC%A0%81%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#3-적용-사례"
  },"257": {
    "doc": "5. Elastic Cache",
    "title": "4. Memcached와 Redis 비교",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ElasticCache#4-memcached%EC%99%80-redis-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#4-memcached와-redis-비교"
  },"258": {
    "doc": "5. Elastic Cache",
    "title": "5. 핵심 개념",
    "content": "노드, 샤드, 클러스터: ElastiCache 배포 시 기본 구성 요소, 샤드(키 공간의 서브셋 및 레플리카 포함), 클러스터(여러 샤드로 구성)에 대한 설명 . ",
    "url": "/docs/02_Tech/AWS/ElasticCache#5-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#5-핵심-개념"
  },"259": {
    "doc": "5. Elastic Cache",
    "title": "5. 고려 사항",
    "content": "캐시의 크기 결정, 데이터 일관성 유지, 비용 관리 등이 포함됩니다. ",
    "url": "/docs/02_Tech/AWS/ElasticCache#5-%EA%B3%A0%EB%A0%A4-%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#5-고려-사항"
  },"260": {
    "doc": "5. Elastic Cache",
    "title": "6. 적용 방안",
    "content": "서버리스 환경에서의 자동 스케일링, 캐시 노드의 세밀한 조정, 보안 설정 및 모니터링 방법 등이 포함됩니다. ",
    "url": "/docs/02_Tech/AWS/ElasticCache#6-%EC%A0%81%EC%9A%A9-%EB%B0%A9%EC%95%88",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache#6-적용-방안"
  },"261": {
    "doc": "5. Elastic Cache",
    "title": "5. Elastic Cache",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ElasticCache",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticCache"
  },"262": {
    "doc": "3. Elastic Search",
    "title": "ElasticSearch",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#elasticsearch",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#elasticsearch"
  },"263": {
    "doc": "3. Elastic Search",
    "title": "목차",
    "content": ". | AWS EC2에서 Docker를 사용하여 Jenkins 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS EC2 Ubuntu OS를 awscli를 통해 배포 | . | . ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#목차"
  },"264": {
    "doc": "3. Elastic Search",
    "title": "AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "content": "AWS EC2 인스턴스에 Docker를 사용하여 Jenkins를 배포하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#aws-ec2%EC%97%90%EC%84%9C-docker%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-jenkins-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#aws-ec2에서-docker를-사용하여-jenkins-배포하기"
  },"265": {
    "doc": "3. Elastic Search",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#%EB%AA%A9%EC%B0%A8-1",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#목차-1"
  },"266": {
    "doc": "3. Elastic Search",
    "title": "글을 쓴 배경",
    "content": "Jenkins를 AWS EC2 인스턴스에 설치하는 과정을 기록하기 위해 작성하였습니다. ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#글을-쓴-배경"
  },"267": {
    "doc": "3. Elastic Search",
    "title": "글 요약",
    "content": "AWS EC2 인스턴스에 userdata를 이용하여 Docker로 Jenkins를 Ubuntu OS에 배포하는 방법을 공유합니다. AWS EC2 인스턴스 생성부터 Docker 이미지를 이용한 배포 프로세스까지 스크립트를 이용해 한번에 설치할 수 있도록 구성하였습니다. ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#글-요약"
  },"268": {
    "doc": "3. Elastic Search",
    "title": "시작하기 전",
    "content": "AWS, Docker, Jenkins에 대한 기본적인 이해가 있으신 분들을 위해 작성되었습니다. AWS EC2 인스턴스 생성 및 설정, Docker에 대한 기본 지식이 필요합니다. Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#시작하기-전"
  },"269": {
    "doc": "3. Elastic Search",
    "title": "1. AWS EC2 Ubuntu OS를 awscli를 통해 배포",
    "content": "참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/AWS/ElasticSearch#1-aws-ec2-ubuntu-os%EB%A5%BC-awscli%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch#1-aws-ec2-ubuntu-os를-awscli를-통해-배포"
  },"270": {
    "doc": "3. Elastic Search",
    "title": "3. Elastic Search",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ElasticSearch",
    
    "relUrl": "/docs/02_Tech/AWS/ElasticSearch"
  },"271": {
    "doc": "3. EventBridge",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/AWS/EventBridge#color-utilities",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#color-utilities"
  },"272": {
    "doc": "3. EventBridge",
    "title": "Table of contents",
    "content": ". | AWS EC2에서 Docker를 사용하여 Jenkins 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS EC2 Ubuntu OS를 awscli를 통해 배포 | . | . ",
    "url": "/docs/02_Tech/AWS/EventBridge#table-of-contents",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#table-of-contents"
  },"273": {
    "doc": "3. EventBridge",
    "title": "AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "content": "AWS EC2 인스턴스에 Docker를 사용하여 Jenkins를 배포하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/EventBridge#aws-ec2%EC%97%90%EC%84%9C-docker%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-jenkins-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#aws-ec2에서-docker를-사용하여-jenkins-배포하기"
  },"274": {
    "doc": "3. EventBridge",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/02_Tech/AWS/EventBridge#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#목차"
  },"275": {
    "doc": "3. EventBridge",
    "title": "글을 쓴 배경",
    "content": "Jenkins를 AWS EC2 인스턴스에 설치하는 과정을 기록하기 위해 작성하였습니다. ",
    "url": "/docs/02_Tech/AWS/EventBridge#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#글을-쓴-배경"
  },"276": {
    "doc": "3. EventBridge",
    "title": "글 요약",
    "content": "AWS EC2 인스턴스에 userdata를 이용하여 Docker로 Jenkins를 Ubuntu OS에 배포하는 방법을 공유합니다. AWS EC2 인스턴스 생성부터 Docker 이미지를 이용한 배포 프로세스까지 스크립트를 이용해 한번에 설치할 수 있도록 구성하였습니다. ",
    "url": "/docs/02_Tech/AWS/EventBridge#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#글-요약"
  },"277": {
    "doc": "3. EventBridge",
    "title": "시작하기 전",
    "content": "AWS, Docker, Jenkins에 대한 기본적인 이해가 있으신 분들을 위해 작성되었습니다. AWS EC2 인스턴스 생성 및 설정, Docker에 대한 기본 지식이 필요합니다. Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/AWS/EventBridge#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#시작하기-전"
  },"278": {
    "doc": "3. EventBridge",
    "title": "1. AWS EC2 Ubuntu OS를 awscli를 통해 배포",
    "content": "참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/AWS/EventBridge#1-aws-ec2-ubuntu-os%EB%A5%BC-awscli%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge#1-aws-ec2-ubuntu-os를-awscli를-통해-배포"
  },"279": {
    "doc": "3. EventBridge",
    "title": "3. EventBridge",
    "content": " ",
    "url": "/docs/02_Tech/AWS/EventBridge",
    
    "relUrl": "/docs/02_Tech/AWS/EventBridge"
  },"280": {
    "doc": "6. HTTP API Gateway",
    "title": "HTTP API Gateway를 활용한 JWT 인증",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#http-api-gateway%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-jwt-%EC%9D%B8%EC%A6%9D",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#http-api-gateway를-활용한-jwt-인증"
  },"281": {
    "doc": "6. HTTP API Gateway",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. HTTP API Gateway란? | 2. HTTP API Gateway 구현 방법 | 3. Lambda 함수 생성 | 4. JWT 인증 구현 | 5. 테스트 및 검증 | . ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#목차"
  },"282": {
    "doc": "6. HTTP API Gateway",
    "title": "글을 쓴 배경",
    "content": "API Gateway를 통해 Lambda 함수를 연결하여 elastiCach에 있는 데이터를 조회하는 서비스를 구축 . 해당 과정에서 jwt 인증 절차가 필요 . 관련 문서 : . ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#글을-쓴-배경"
  },"283": {
    "doc": "6. HTTP API Gateway",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#글-요약"
  },"284": {
    "doc": "6. HTTP API Gateway",
    "title": "시작하기 전",
    "content": ". ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#시작하기-전"
  },"285": {
    "doc": "6. HTTP API Gateway",
    "title": "1. HTTP API Gateway란?",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#1-http-api-gateway%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#1-http-api-gateway란"
  },"286": {
    "doc": "6. HTTP API Gateway",
    "title": "2. HTTP API Gateway 구현 방법",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#2-http-api-gateway-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#2-http-api-gateway-구현-방법"
  },"287": {
    "doc": "6. HTTP API Gateway",
    "title": "3. Lambda 함수 생성",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#3-lambda-%ED%95%A8%EC%88%98-%EC%83%9D%EC%84%B1",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#3-lambda-함수-생성"
  },"288": {
    "doc": "6. HTTP API Gateway",
    "title": "4. JWT 인증 구현",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#4-jwt-%EC%9D%B8%EC%A6%9D-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#4-jwt-인증-구현"
  },"289": {
    "doc": "6. HTTP API Gateway",
    "title": "5. 테스트 및 검증",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#5-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B0%8F-%EA%B2%80%EC%A6%9D",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway#5-테스트-및-검증"
  },"290": {
    "doc": "6. HTTP API Gateway",
    "title": "6. HTTP API Gateway",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/HTTPAPIGateway"
  },"291": {
    "doc": "IAC",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/IAC#color-utilities",
    
    "relUrl": "/docs/02_Tech/IAC#color-utilities"
  },"292": {
    "doc": "IAC",
    "title": "Table of contents",
    "content": ". ",
    "url": "/docs/02_Tech/IAC#table-of-contents",
    
    "relUrl": "/docs/02_Tech/IAC#table-of-contents"
  },"293": {
    "doc": "IAC",
    "title": "IAC",
    "content": " ",
    "url": "/docs/02_Tech/IAC",
    
    "relUrl": "/docs/02_Tech/IAC"
  },"294": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#aws-s3-lambda-api-gateway%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-%EC%86%94%EB%A3%A8%EC%85%98",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#aws-s3-lambda-api-gateway를-활용한-실시간-이미지-리사이징-솔루션"
  },"295": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. CloudFront와 Lambda@Edge로 이미지 리사이징하기 | 2. Lambda@Edge 생성하기 . | 2.1 Viewer Request Function | 2.1 Viewer Request Function 상세 내용 | . | . ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#목차"
  },"296": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "글을 쓴 배경",
    "content": "다양한 크기의 기기들에게 그에 맞는 이미지를 제공해야 하는 필요성이 생겼습니다. 이 글에서는 특정 크기의 이미지를 요청하면 그에 맞는 이미지를 리사이징 하여 노출하는 방식을 소개합니다. 또한 클라우드 프론트를 이용하여 생성된 이미지를 저장하지 않고 캐싱하여 데이터 효율성을 높이는 방법을 고안하였습니다. 이 블로그는 현재 이미 이미지 변환 솔루션을 사용하고 있어서 query 규칙 등을 변경할 수 없는 유저들도 CloudFront와 Lambda@Edge를 이용한 이미지 변환 방식을 사용할 수 있도록 돕기 위해 작성되었습니다. 관련 문서 : Resizing Images with Amazon CloudFront &amp; Lambda@Edge . ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#글을-쓴-배경"
  },"297": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "글 요약",
    "content": ". | 사용자가 CloudFront URL을 통해 특정 크기의 이미지를 요청합니다. | CloudFront는 Lambda@Edge Viewer-Request 함수를 트리거하여 요청된 이미지의 URI를 조작하고, 캐싱된 이미지가 있는지 확인합니다. | CloudFront에 이미지 캐시에 없는 경우, Origin Response 함수가 원본 이미지를 다운로드하고, 리사이징을 수행한 후 변환된 이미지를 응답으로 반환합니다. | CloudFront는 변환된 이미지를 사용자에게 전달하고, 이를 캐시에 저장하여 이후 동일한 요청에 빠르게 응답할 수 있도록 합니다. | . ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#글-요약"
  },"298": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "시작하기 전",
    "content": ". | Lambda@Edge와 CloudFront 이벤트 트리거 설정 이해 | Node.js 20 환경에서 Lambda 함수 개발 | . ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#시작하기-전"
  },"299": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "1. CloudFront와 Lambda@Edge로 이미지 리사이징하기",
    "content": "Lambda@Edge는 AWS Lambda의 기능을 엣지로 확장하여 여러 AWS 위치에서 코드를 실행할 수 있게 해줍니다. 이를 통해 이미지 리사이징과 같은 작업을 클라우드 엣지에서 직접 수행하여 전송 시간과 네트워크 비용을 절감할 수 있습니다. CloudFront와 결합하여 다음과 같은 주요 이벤트가 발생할 때 Lambda@Edge 함수를 실행하도록 트리거를 추가할 수 있습니다. | CloudFront Viewer Request: CloudFront가 뷰어로부터 요청을 받을 때 실행됩니다. | CloudFront Origin Request: CloudFront가 원본 서버로 요청을 전달할 때 실행됩니다. 이 이벤트는 캐시된 이미지가 없는 경우에만 발생합니다. | CloudFront Origin Response: CloudFront가 원본 서버로부터 응답을 받은 후 실행됩니다. 원본 서버에서 이미지를 가져온 후, 이 이벤트에서 Lambda@Edge 함수는 이미지를 리사이징하는 등 변환 작업을 수행할 수 있습니다. 캐시된 이미지가 없는 경우에만 발생하므로, 이미지 리사이징 작업이 불필요하게 중복되지 않도록 합니다. | CloudFront Viewer Response: CloudFront가 요청된 객체를 뷰어에게 반환하기 전에 실행됩니다. 이후 동일한 요청에 대해 캐시된 이미지가 빠르게 제공됩니다. | . ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#1-cloudfront%EC%99%80-lambdaedge%EB%A1%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#1-cloudfront와-lambdaedge로-이미지-리사이징하기"
  },"300": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "2. Lambda@Edge 생성하기",
    "content": "2.1 Viewer Request Function . 기존 변환 솔루션을 사용하고 있는 query 규칙을 변경할 수 없는 유저를 위해 요청된 이미지의 URI를 response 함수가 사용할 수 있게 변환하는 작업을 수행합니다. 기존 솔루션 규칙 설명 . 크롭 - 최적화 /dims/crop/3464x1520+188+840/optimize /dims/crop/3688x2075+76+485/optimize 크롭 - 리사이즈 - 최적화 /dims/crop/3464x1520+188+840/resize/1180x518/optimize /dims/crop/2871x2473+485+87/resize/900x775/optimize 리사이즈 - 최적화 /dims/resize/96x96/optimize . 'use strict'; import querystring from 'querystring'; function makeResponse(status, statusDescription, bodyContent, contentType) { return { status, statusDescription, headers: { 'content-type': [{ key: 'Content-Type', value: contentType || 'application/json' }] }, body: bodyContent, bodyEncoding: contentType ? 'base64' : undefined, }; } export const handler = async (event) =&gt; { console.log('Received event:', JSON.stringify(event, null, 2)); try { const { request } = event.Records[0].cf; const uri = request.uri; let newUri; let transformationOptions = {}; const cropMatch = uri.match(/\\/dims\\/crop\\/(\\d+)x(\\d+)\\+(\\d+)\\+(\\d+)(\\/resize\\/(\\d+)x(\\d+))?(\\/optimize|min|max)?/); const resizeMatch = uri.match(/\\/dims\\/resize\\/(\\d+)x(\\d+)(\\/optimize|min|max)?/); if (cropMatch) { // Crop (and possibly resize and optimize) const [fullMatch, cropWidth, cropHeight, cropX, cropY, , resizeWidth, resizeHeight, option] = cropMatch; transformationOptions = { type: resizeWidth &amp;&amp; resizeHeight ? 'crop+resize' : 'crop', cropWidth: parseInt(cropWidth, 10), cropHeight: parseInt(cropHeight, 10), cropX: parseInt(cropX, 10), cropY: parseInt(cropY, 10), ...(resizeWidth &amp;&amp; { resizeWidth: parseInt(resizeWidth, 10) }), ...(resizeHeight &amp;&amp; { resizeHeight: parseInt(resizeHeight, 10) }), option: option ? option.slice(1) : undefined }; newUri = `/${cropWidth}x${cropHeight}+${cropX}+${cropY}`; if (resizeWidth &amp;&amp; resizeHeight) { newUri += `/${resizeWidth}x${resizeHeight}`; } } else if (resizeMatch) { // Resize (and possibly optimize) const [fullMatch, resizeWidth, resizeHeight, option] = resizeMatch; transformationOptions = { type: 'resize', resizeWidth: parseInt(resizeWidth, 10), resizeHeight: parseInt(resizeHeight, 10), option: option ? option.slice(1) : undefined }; newUri = `/${resizeWidth}x${resizeHeight}`; } else { console.log('Invalid URI format'); return makeResponse('400', 'Bad Request', 'Invalid URI format'); } // Construct the final URI with the transformation options const imageNameMatch = uri.match(/\\/([^\\/]+)\\.(jpg|jpeg|png)/); if (!imageNameMatch) { console.log('Invalid URI format for image name'); return makeResponse('400', 'Bad Request', 'Invalid URI format for image name'); } const [fullImageNameMatch, imageName, extension] = imageNameMatch; newUri = `/${imageName}.${extension}${newUri}`; // Add the transformation options to the query string request.querystring = querystring.stringify(transformationOptions); // Add custom headers for transform and option request.headers['x-custom-transform'] = [{ key: 'X-Custom-Transform', value: transformationOptions.type }]; if (transformationOptions.option) { request.headers['x-custom-option'] = [{ key: 'X-Custom-Option', value: transformationOptions.option }]; } // Log the final URI for debugging console.log('Modified URI:', newUri); console.log('Transformation options:', transformationOptions); console.log('Request headers:', JSON.stringify(request.headers, null, 2)); // Update the request URI request.uri = newUri; // Forward the request with the modified URI return request; } catch (err) { console.log('Error processing request:', err); return makeResponse('500', 'Internal Server Error', 'An error occurred while processing the request'); } }; . 2.1 Viewer Request Function 상세 내용 . | makeResponse 함수 | . CloudFront가 Lambda@Edge 함수로부터 받는 응답 형식이 특정한 구조를 따라야 하기 때문입니다. function makeResponse(status, statusDescription, bodyContent, contentType) { return { status, statusDescription, headers: { 'content-type': [{ key: 'Content-Type', value: contentType || 'application/json' }] }, body: bodyContent, bodyEncoding: contentType ? 'base64' : undefined, }; } . | URI 매칭 및 변환 옵션 설정 | . 기존 규칙 설명과 연결지은 코드 설명 추가 필요 . const cropMatch = uri.match(/\\/dims\\/crop\\/(\\d+)x(\\d+)\\+(\\d+)\\+(\\d+)(\\/resize\\/(\\d+)x(\\d+))?(\\/optimize|min|max)?/); const resizeMatch = uri.match(/\\/dims\\/resize\\/(\\d+)x(\\d+)(\\/optimize|min|max)?/); if (cropMatch) { // Crop (and possibly resize and optimize) const [fullMatch, cropWidth, cropHeight, cropX, cropY, , resizeWidth, resizeHeight, option] = cropMatch; transformationOptions = { type: resizeWidth &amp;&amp; resizeHeight ? 'crop+resize' : 'crop', cropWidth: parseInt(cropWidth, 10), cropHeight: parseInt(cropHeight, 10), cropX: parseInt(cropX, 10), cropY: parseInt(cropY, 10), ...(resizeWidth &amp;&amp; { resizeWidth: parseInt(resizeWidth, 10) }), ...(resizeHeight &amp;&amp; { resizeHeight: parseInt(resizeHeight, 10) }), option: option ? option.slice(1) : undefined }; newUri = `/${cropWidth}x${cropHeight}+${cropX}+${cropY}`; if (resizeWidth &amp;&amp; resizeHeight) { newUri += `/${resizeWidth}x${resizeHeight}`; } } else if (resizeMatch) { // Resize (and possibly optimize) const [fullMatch, resizeWidth, resizeHeight, option] = resizeMatch; transformationOptions = { type: 'resize', resizeWidth: parseInt(resizeWidth, 10), resizeHeight: parseInt(resizeHeight, 10), option: option ? option.slice(1) : undefined }; newUri = `/${resizeWidth}x${resizeHeight}`; } else { console.log('Invalid URI format'); return makeResponse('400', 'Bad Request', 'Invalid URI format'); } . | URI에서 이미지 이름과 확장자를 추출하여 최종 변환되어 반환할 URI구성합니다. | . const imageNameMatch = uri.match(/\\/([^\\/]+)\\.(jpg|jpeg|png)/); if (!imageNameMatch) { console.log('Invalid URI format for image name'); return makeResponse('400', 'Bad Request', 'Invalid URI format for image name'); } const [fullImageNameMatch, imageName, extension] = imageNameMatch; newUri = `/${imageName}.${extension}${newUri}`; . 옵션 값을 커스텀 헤더에 담아 전달합니다 . ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#2-lambdaedge-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf#2-lambdaedge-생성하기"
  },"301": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "content": " ",
    "url": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf",
    
    "relUrl": "/docs/02_Tech/AWS/CloudFront/Image-Resizing-S3-CF/image-resizing-s3-cf"
  },"302": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#aws-s3-lambda-api-gateway%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-%EC%86%94%EB%A3%A8%EC%85%98",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#aws-s3-lambda-api-gateway를-활용한-실시간-이미지-리사이징-솔루션"
  },"303": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. S3 버킷 생성 및 설정 . | 1.1 공용 접근 설정 | 1.2 버킷 정책 추가 | 1.3 정적 웹사이트 호스팅 설정 | 1.4 리디렉션 규칙 설정 | 1.5 리디렉션 규칙 적용 | 1.6 리디렉션 후 변화 | . | 2. Lambda와 API Gateway 생성 및 설정 . | 2.1 생성된 Lambda 함수의 Resource-based policy 설정 | 2.2 Lambda 함수 코드 | 2.3 Lambda 함수 코드 상세 설명 | . | . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#목차"
  },"304": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "글을 쓴 배경",
    "content": "다양한 크기의 기기들에게 그에 맞는 이미지를 제공해야 하는 필요성이 생겼습니다. 이 글에서는 특정 크기의 이미지를 요청하면 그에 맞는 이미지를 리사이징 하여 노출하는 방식을 소개합니다. 관련 문서 : Resize Images on the Fly with Amazon S3, AWS Lambda, and Amazon API Gateway . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#글을-쓴-배경"
  },"305": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "글 요약",
    "content": ". | 사용자가 S3 버킷의 정적 웹사이트 호스팅 엔드포인트를 통해 리사이징된 이미지를 요청합니다. | 요청된 이미지가 버킷에 없으면 API Gateway URI 로 리디렉션됩니다. | API Gateway가 Lambda 함수를 트리거하여 리사이징 요청을 처리합니다. | Lambda 함수가 원본 이미지를 S3 버킷에서 다운로드하고, 리사이징한 후 다시 특정 경로에 업로드합니다. | Lambda 함수가 리사이징 처리를 완료하면, API Gateway가 사용자에게 원래 요청한 사이즈의 이미지를 리디렉션합니다. | 이후 동일한 사이즈의 요청은 API Gateway 를 거치지 않고, S3 버킷에서 직접 제공됩니다. | . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#글-요약"
  },"306": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "시작하기 전",
    "content": ". | AWS S3 정적 웹사이트 호스팅 법 이해 | API Gateway 람다 통합 설정 이해 | nodejs 20 구현 | . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#시작하기-전"
  },"307": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "1. S3 버킷 생성 및 설정",
    "content": "우선, S3 버킷을 생성하고 공용 액세스 및 정적 웹사이트 호스팅을 설정해야 합니다. 정적 웹사이트 호스팅을 사용하려면 S3 버킷에 저장된 리소스에 대한 공용 접근을 허용해야 합니다. 1.1 공용 접근 설정 . | 생성된 버킷을 선택하고 Permissions 탭으로 이동 후 Block all public access 옵션을 해지하여 공용 접근을 허용합니다. | Block Public Access 를 해제하면 공용 접근을 허용할 수 있는 상태가 되며 아래 정책 추가를 통해 명시적으로 접근 권한을 부여할 수 있게 됩니다. | . 1.2 버킷 정책 추가 . | Bucket Policy 를 추가하여 버킷 내 객체들에 대한 접근을 허용합니다. | . { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::kkm-resize-bucket/*\" } ] } . 1.3 정적 웹사이트 호스팅 설정 . | Properties 탭에서 Static website hosting 을 설정할 수 있습니다. | . 1.4 리디렉션 규칙 설정 . | 정적 웹사이트 호스팅 섹션에서 리디렉션 규칙을 설정합니다. 유저가 요청한 이미지가 없을 경우 API Gateway URL로 리디렉션 하도록 설정합니다. | . [ { \"Condition\": { \"HttpErrorCodeReturnedEquals\": \"404\" }, \"Redirect\": { \"HostName\": \"4jbu2qpki2.execute-api.ap-northeast-2.amazonaws.com\", \"HttpRedirectCode\": \"307\", \"Protocol\": \"https\", \"ReplaceKeyPrefixWith\": \"default/resize?key=\" } } ] . 1.5 리디렉션 규칙 적용 . | 없는 이미지를 요청할 때 API Gateway가 이미지 리사이징을 동적으로 수행하고, 새로 생성된 이미지를 반환할 수 있습니다. | S3 버킷 호스팅 URL을 통해 이미지를 호출하는 방법 예시 . | . http://kkm-resize-bucket.s3-website.ap-northeast-2.amazonaws.com/300x300/blue_marble.jpg . | 만약 이미지가 존재하지 않으면 404 오류가 반환됩니다. | 리디렉션 규칙을 적용한 경우, 이미지가 존재하지 않을 때 설정된 Condition에 따라 Redirect 동작이 적용됩니다. | . [ { \"Condition\": { \"HttpErrorCodeReturnedEquals\": \"404\" }, \"Redirect\": { \"HostName\": \"4jbu2qpki2.execute-api.ap-northeast-2.amazonaws.com\", \"HttpRedirectCode\": \"307\", \"Protocol\": \"https\", \"ReplaceKeyPrefixWith\": \"default/resize?key=\" } } ] . | 이미지가 존재하지 않을 때 리디렉션된 URL 은 아래와 같습니다. | . https://4jbu2qpki2.execute-api.ap-northeast-2.amazonaws.com/default/resize?key=300x300/blue_marble.jpg . 1.6 리디렉션 후 변화 . | 호스트 이름 변경: 버킷 호스트에서 API Gateway 호스트네임으로 변경됩니다. | 프로토콜 변경: HTTP에서 HTTPS로 변경됩니다. | 경로 수정: 요청 경로의 접두사 300x300/이 default/resize?key=로 교체되어 API Gateway가 요청을 처리할 수 있도록 합니다. | . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#1-s3-%EB%B2%84%ED%82%B7-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#1-s3-버킷-생성-및-설정"
  },"308": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "2. Lambda와 API Gateway 생성 및 설정",
    "content": "2.1 생성된 Lambda 함수의 Resource-based policy 설정 . | Lambda에 필요한 권한을 부여하기 위해 Resource-based policy를 설정해야합니다. 이 정책을 통해 특정 서비스나 계정이 Lambda 함수를 호출할 수 있도록 허용할 수 있습니다. | Permission 탭에서 아래와 같은 정책을 추가하여 API Gateway가 Lambda를 호출 할 수 있도록 합니다. Lambda 함수에 충분한 권한이 있더라도, API Gateway가 해당 함수를 호출하게 하기 위해서는 이 리소스 기반 정책이 필요합니다. | . { \"Version\": \"2012-10-17\", \"Id\": \"default\", \"Statement\": [ { \"Sid\": \"6ebe2e84-6201-5452-9cfc-5df84374f243\", \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"apigateway.amazonaws.com\" }, \"Action\": \"lambda:InvokeFunction\", \"Resource\": \"arn:aws:lambda:ap-northeast-2:539666729110:function:lmd-s3-object-lambda-image-transformer\", \"Condition\": { \"ArnLike\": { \"AWS:SourceArn\": \"arn:aws:execute-api:ap-northeast-2:539666729110:4jbu2qpki2/*/*/resize\" } } } ] } . | Principal을 통해 Action 을 수행할 주체를 설정합니다. | . 2.2 Lambda 함수 코드 . | s3 버킷에서 이미지를 가져와서 리사이징한 후, 다시 S3 버킷에 업로드하는 역할을 합니다. | . 'use strict'; import { S3Client, GetObjectCommand, PutObjectCommand } from '@aws-sdk/client-s3'; import sharp from 'sharp'; import stream from 'stream'; const BUCKET = \"kkm-resize-bucket\"; const URL = \"http://kkm-resize-bucket.s3-website.ap-northeast-2.amazonaws.com\"; const ALLOWED_RESOLUTIONS = process.env.ALLOWED_RESOLUTIONS ? new Set(process.env.ALLOWED_RESOLUTIONS.split(/\\s*,\\s*/)) : new Set([]); const s3 = new S3Client({ region: 'ap-northeast-2' }); export const handler = async (event) =&gt; { console.log('Received event:', JSON.stringify(event, null, 2)); try { const key = event.queryStringParameters?.key; if (!key) { console.log('Missing key query parameter'); return { statusCode: 400, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Bad Request: Missing key query parameter' }), }; } console.log('Key:', key); const match = key.match(/((\\d+)x(\\d+))\\/(.*)/); if (!match) { console.log('Invalid key format'); return { statusCode: 400, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Bad Request: Invalid key format' }), }; } const requestedResolution = match[1]; const width = parseInt(match[2], 10); const height = parseInt(match[3], 10); const originalKey = match[4]; console.log('Requested resolution:', requestedResolution); console.log('Width:', width); console.log('Height:', height); console.log('Original key:', originalKey); // Check if requested resolution is allowed if (ALLOWED_RESOLUTIONS.size !== 0 &amp;&amp; !ALLOWED_RESOLUTIONS.has(requestedResolution)) { console.log('Resolution not allowed'); return { statusCode: 403, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Forbidden: Resolution not allowed' }), }; } // Check if the resized image already exists try { const checkObjectCommand = new GetObjectCommand({ Bucket: BUCKET, Key: key }); await s3.send(checkObjectCommand); console.log('Resized image already exists in S3'); // Redirect to the existing image return { statusCode: 307, headers: { 'Location': `${URL}/${key}`, }, }; } catch (err) { console.log('Resized image does not exist, will create a new one'); } // Get the original image from S3 const getObjectCommand = new GetObjectCommand({ Bucket: BUCKET, Key: originalKey }); const data = await s3.send(getObjectCommand); if (!data || !data.Body) { console.log('Original image not found'); return { statusCode: 404, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Not Found: Original image not found' }), }; } console.log('Got original image from S3'); const originalContentType = data.ContentType || 'image/jpeg'; console.log('Original content type:', originalContentType); const supportedFormats = ['jpeg', 'png', 'webp', 'tiff', 'gif', 'avif']; const defaultFormat = 'jpeg'; const format = originalContentType ? originalContentType.split('/')[1] : defaultFormat; // Resize the image using Sharp const resizeStream = sharp().resize(width, height).toFormat(supportedFormats.includes(format) ? format : defaultFormat); console.log('resizeStream :', resizeStream); // Buffer to hold the resized image const chunks = []; const passThrough = new stream.PassThrough(); data.Body.pipe(resizeStream).pipe(passThrough); passThrough.on('data', (chunk) =&gt; { chunks.push(chunk); }); await new Promise((resolve, reject) =&gt; { passThrough.on('end', resolve); passThrough.on('error', reject); }); const buffer = Buffer.concat(chunks); console.log('Resized image buffer created'); // Generate a new key without timestamp const newKey = `${width}x${height}/${originalKey}`; console.log('New key:', newKey); // Put the resized image back to S3 const putObjectCommand = new PutObjectCommand({ Body: buffer, Bucket: BUCKET, ContentType: originalContentType, Key: newKey, }); await s3.send(putObjectCommand); console.log('Resized image uploaded to S3'); // Return the response to redirect the user to the resized image return { statusCode: 307, headers: { 'Location': `${URL}/${newKey}`, }, }; } catch (err) { console.error('Error processing image:', err); const errorDetails = { message: err.message, stack: err.stack, name: err.name, details: err, }; const errorResponse = { statusCode: 500, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Internal Server Error', error: errorDetails }), }; console.log('Error Response:', JSON.stringify(errorResponse, null, 2)); return errorResponse; } }; . 2.3 Lambda 함수 코드 상세 설명 . | 이미지 요청 처리 . | 요청된 이미지 키를 파싱하여 리사이징할 해상도와 원본 이미지를 식별합니다. | match 함수를 통해 배열로 캡쳐된 내용을 가져온 후 해당 내용을 추 후에 사용할 수 있도록 변수로 분리합니다. | . | . const key = event.queryStringParameters?.key; if (!key) { console.log('Missing key query parameter'); return { statusCode: 400, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Bad Request: Missing key query parameter' }), }; } const match = key.match(/((\\d+)x(\\d+))\\/(.*)/); if (!match) { console.log('Invalid key format'); return { statusCode: 400, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Bad Request: Invalid key format' }), }; } const requestedResolution = match[1]; const width = parseInt(match[2], 10); const height = parseInt(match[3], 10); const originalKey = match[4]; . | 허용된 해상도 확인 . | 요청된 해상도가 환경 변수로 정의된 허용된 목록에 있는지 확인합니다. | process.env.ALLOWED_RESOLUTIONS | . | . if (ALLOWED_RESOLUTIONS.size !== 0 &amp;&amp; !ALLOWED_RESOLUTIONS.has(requestedResolution)) { console.log('Resolution not allowed'); return { statusCode: 403, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Forbidden: Resolution not allowed' }), }; } . | 이미지 리사이징 -1 . | 원본 이미지를 s3로 부터 가져옵니다. | . | . const getObjectCommand = new GetObjectCommand({ Bucket: BUCKET, Key: originalKey }); const data = await s3.send(getObjectCommand); if (!data || !data.Body) { console.log('Original image not found'); return { statusCode: 404, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'Not Found: Original image not found' }), }; } . | 이미지 리사이징 -2 . | sharp 모듈을 사용하여 이미지를 지정된 해상도로 리사이즈 합니다. | . | . const resizeStream = sharp().resize(width, height).toFormat(supportedFormats.includes(format) ? format : defaultFormat); console.log('resizeStream :', resizeStream); . | 이미지 리사이징 -3 . | pipe 메서드는 Node.js의 스트림 API에서 제공하는 메소드로, 한 스트림의 출력을 다른 스트림의 입력으로 연결합니다. | data.Body를 resizeStream으로 전달하고 리사이즈 된 데이터 자체를 PassThrough 스트림으로 전달합니다. | PassThrough 스트림에서 data이벤트가 발생할 때마다 데이터를 수집합니다. end 이벤트가 발생할 때까지 반복하고 수집된 데이터 청크는 하나의 버퍼로 결합됩니다. | . | . const chunks = []; const passThrough = new stream.PassThrough(); data.Body.pipe(resizeStream).pipe(passThrough); passThrough.on('data', (chunk) =&gt; { chunks.push(chunk); }); await new Promise((resolve, reject) =&gt; { passThrough.on('end', resolve); passThrough.on('error', reject); }); const buffer = Buffer.concat(chunks); . | 리사이징된 이미지 저장 . | 리사이징된 이미지를 s3 버킷에 저장합니다. | 저장할 때 경로는 앞서 요청 들어온 경로로 저장합니다. | . | . const newKey = `${width}x${height}/${originalKey}`; const putObjectCommand = new PutObjectCommand({ Body: buffer, Bucket: BUCKET, ContentType: originalContentType, Key: newKey, }); await s3.send(putObjectCommand); . | 리디렉션 응답 . | 사용자에게 리사이징된 이미지로 리디렉션하는 응답을 반환합니다. | 특정 상태코드와 Location 헤더를 사용하여 리디렉션을 처리합니다. | . | . return { statusCode: 307, headers: { 'Location': `${URL}/${newKey}`, }, }; . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#2-lambda%EC%99%80-api-gateway-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3#2-lambda와-api-gateway-생성-및-설정"
  },"309": {
    "doc": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "title": "2. AWS S3, Lambda, API Gateway를 활용한 실시간 이미지 리사이징 솔루션",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway/Image-Resizing-S3"
  },"310": {
    "doc": "Kimkm's 02_Tech Blog",
    "title": "Kimkm's 02_Tech Blog",
    "content": "SERVER POSITION . | 다양한 언어 ‘생활코딩’ 배포에 기반한 100% 활용 (Apple Store 다운로드 가능) | 한국과학기술원 클라우드 서비스 제작 | 최적화 컨설턴트 공공정책에 앞장 (공공 데이터 활용 부분, 웹 콘텐츠 제작 담당) | 공동번역자로서 번역에 열정적인 업무 수행 | . SKILLS . | JavaScript ★★★★★ | Python, C ★★★★☆ | MySQL ★★★★☆ | JAVA, AWS ★★★☆☆ | GraphQL ★★★☆☆ | . PROFILE / CONTACT . 자세한 정보와 연락처 정보를 여기에 기재하세요. COMMENT . 타인과 소통하는 것을 바탕으로 전문성과 열정을 발휘하세요. ",
    "url": "/",
    
    "relUrl": "/"
  },"311": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "content": " ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#aws-sam%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-lambda%EB%A1%9C-java-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#aws-sam을-이용해-lambda로-java-어플리케이션-배포하기"
  },"312": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "목차",
    "content": ". | AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS SAM과 AWS Lambda 소개 | 2. 서버리스 어플리케이션 예제 . | 2.1 function code | 2.2 function code 상세 설명 | . | 3. AWS SAM을 이용한 Java Application 빌드 및 배포 . | 3.1 template code | 3.2 SAM Template의 기본 구성 . | 3.2.1 표준 빌드 방식 | 3.2.2 Makefile을 이용한 커스텀 빌드 설정 | 3.3 Lambda Layer를 통한 의존성 관리 | 3.4 pom.xml . | 3.4.1 function/pom.xml | 3.4.3 layer/pom.xml | 3.4.4 pom.xml 주요 부분 상세 설명 | . | . | . | 5. CodeBuild 이용한 CI/CD 구성 . | 5.1 buildspec.yml | . | 5. Lambda 배포 확인 | . | . ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#목차"
  },"313": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "글을 쓴 배경",
    "content": "이 글에서는 AWS SAM(Serverless Application Model)을 이용하여 Lambda로 Java 어플리케이션을 배포하는 과정을 설명합니다. ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#글을-쓴-배경"
  },"314": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "글 요약",
    "content": "AWS SAM과 AWS CodeBuild 를 이용해 Java Application을 Lambda에 배포하고 API Gateway를 통해 Lambda를 호출하는 과정을 설명합니다. ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#글-요약"
  },"315": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "시작하기 전",
    "content": ". | CodeBuild 빌드 환경 사용: public.ecr.aws/sam/build-java21:1.115.0-20240411212300-x86_64 (ECR Public Gallery) | Java 버전: Java 21 | sam 버전: SAM CLI, version 1.108.0 | . ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#시작하기-전"
  },"316": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "1. AWS SAM과 AWS Lambda 소개",
    "content": "AWS SAM . AWS SAM은 AWS CloudFormation의 확장 프레임워크입니다. 개발자는 YAML 혹은 JSON 템플릿으로 리소스를 정의할 수 있으며, 이 템플릿은 AWS CloudFormation으로 자동 변환되어 리소스가 프로비저닝됩니다. SAM을 사용함으로써 개발자는 Lambda 코드의 버전 관리를 Git과 같은 형상관리 도구를 사용하여 수행할 수 있으며, Lambda 배포를 Git 레포지토리에 코드를 푸시하는 과정으로 수행할 수 있습니다. 관련 문서 : AWS Serverless Application Model (AWS SAM) 란 무엇입니까? . AWS Lambda . AWS Lambda는 코드를 서버 없이 실행할 수 있게 해주는 서비스입니다. 관련 문서 : AWS Lambda이란 무엇인가요? . ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#1-aws-sam%EA%B3%BC-aws-lambda-%EC%86%8C%EA%B0%9C",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#1-aws-sam과-aws-lambda-소개"
  },"317": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "2. 서버리스 어플리케이션 예제",
    "content": "다음은 Lambda에서 사용되는 Java 함수 코드입니다 . 2.1 function code . package example; import com.amazonaws.services.lambda.runtime.Context; import com.amazonaws.services.lambda.runtime.LambdaLogger; import com.amazonaws.services.lambda.runtime.RequestHandler; import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent; import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent; import software.amazon.lambda.powertools.metrics.Metrics; import software.amazon.lambda.powertools.tracing.Tracing; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import java.util.HashMap; import java.util.Map; import java.util.stream.Collectors; import static software.amazon.lambda.powertools.tracing.CaptureMode.DISABLED; public class Handler implements RequestHandler&lt;APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent&gt; { @Tracing(captureMode = DISABLED) @Metrics(captureColdStart = true) @Override public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) { LambdaLogger logger = context.getLogger(); logger.log(\"Received request: \" + input.toString()); Map&lt;String, String&gt; headers = new HashMap&lt;&gt;(); headers.put(\"Content-Type\", \"application/json\"); headers.put(\"X-Custom-Header\", \"application/json\"); APIGatewayProxyResponseEvent response = new APIGatewayProxyResponseEvent() .withHeaders(headers); try { final String pageContents = this.getPageContents(\"https://checkip.amazonaws.com\"); String output = String.format(\"{ \\\"message\\\": \\\"hello world\\\", \\\"location\\\": \\\"%s\\\" }\", pageContents); logger.log(\"Response body: \" + output); return response .withStatusCode(200) .withBody(output); } catch (IOException e) { logger.log(\"Error: \" + e.getMessage()); return response .withBody(\"{}\") .withStatusCode(500); } } @Tracing(namespace = \"getPageContents\") private String getPageContents(String address) throws IOException { URL url = new URL(address); try (BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()))) { return br.lines().collect(Collectors.joining(System.lineSeparator())); } } } . 2.2 function code 상세 설명 . 이 AWS Lambda 함수는 API Gateway로부터 오는 HTTP 요청을 처리합니다. Handler 클래스에 정의된 handleRequest 메소드를 통해 이벤트를 수신하고 처리 결과를 반환합니다. 클래스 및 인터페이스 선언 . Handler 클래스는 RequestHandler 인터페이스를 구현합니다. 이 인터페이스는 두 개의 제네릭 파라미터를 받으며, AWS Lambda에서 이벤트를 처리할 수 있도록 합니다. | RequestHandler : Lambda 함수의 로직을 구현하는 핸들러입니다. | APIGatewayProxyRequestEvent : API Gateway로부터 받은 HTTP 요청 데이터를 담고 있습니다. | APIGatewayProxyResponseEvent : 처리 결과를 API Gateway로 반환할 때 사용하는 객체입니다. | . 어노테이션 활용 . | @Tracing: AWS X-Ray와 통합하여 Lambda 애플리케이션의 추적, 디버깅 및 최적화를 지원합니다. captureMode = DISABLED 설정은 자동 추적을 비활성화합니다. | @Metrics: 성능 메트릭을 수집하는 데 사용됩니다. captureColdStart = true 옵션으로 콜드 스타트 시 발생하는 지연 시간과 관련 데이터를 캡처합니다. | . 콜드 스타트란? . 배포 후 일정 기간동안 사용되지 않아 함수가 내려간 후 다시 시작될 때 혹은 새 인스턴스로 처음 시작될 때 때 주로 발생됩니다. 이 때 지연이 발생될 수 있으며 captureColdStart 옵션은 이 지연시간을 포함한 세부정보를 기록합니다. 핸들러 메인 메소드 . handleRequest 메소드는 API Gateway로부터 받은 HTTP 요청을 처리하고 응답을 반환합니다. 메소드는 APIGatewayProxyRequestEvent와 Context 객체를 매개변수로 받아 실행됩니다. | Context 객체: Lambda 실행 환경에 대한 정보를 제공하며, 로깅 등의 기능에 접근할 수 있습니다. | LambdaLogger: 요청을 로깅하여 CloudWatch에서 확인할 수 있게 합니다. | 응답 헤더 설정: 응답에 Content-Type과 X-Custom-Header를 설정하여 응답이 JSON 형식임을 명시합니다. | . 외부 리소스 접근 . getPageContents 메소드: 외부 URL에서 데이터를 가져오는 기능을 수행합니다. 이 메소드는 https://checkip.amazonaws.com에서 IP 주소를 조회하며, 이 정보를 응답에 포함시킵니다. ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#2-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%98%88%EC%A0%9C",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#2-서버리스-어플리케이션-예제"
  },"318": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "3. AWS SAM을 이용한 Java Application 빌드 및 배포",
    "content": "AWS SAM은 Java 언어를 사용할 때 Maven이나 Gradle과 같은 표준 Java 빌드 도구를 자동으로 활용하여 프로젝트를 배포합니다. 3.1 template code . 다음은 SAM 에서 Lambda 함수를 배포 할 때 사용하는 template.yaml 파일입니다. AWSTemplateFormatVersion: '2010-09-09' Transform: AWS::Serverless-2016-10-31 Description: A simple AWS Lambda application using Java with a Layer. Globals: Function: Runtime: java21 Timeout: 10 # Timeout in seconds MemorySize: 512 Architectures: - x86_64 Parameters: LambdaFunctionName: Type: String Default: lmd-java-sample Description: The name of the Lambda function. Resources: JavaFunction: Type: AWS::Serverless::Function Properties: FunctionName: !Ref LambdaFunctionName Handler: example.Handler::handleRequest CodeUri: function/ SnapStart: ApplyOn: PublishedVersions Role: arn:aws:iam::539666729110:role/kimkm-lambda-role Layers: - !Ref JavaLayer Metadata: BuildMethod: makefile JavaLayer: Type: AWS::Serverless::LayerVersion Properties: LayerName: \"java-dependencies\" Description: \"Java libraries required for the lambda function\" ContentUri: layer/ RetentionPolicy: 'Delete' Metadata: BuildMethod: java21 Outputs: JavaFunction: Description: \"Lambda Function ARN\" Value: !GetAtt JavaFunction.Arn JavaLayer: Description: \"Lambda Layer ARN\" Value: !Ref JavaLayer . 3.2 SAM Template의 기본 구성 . AWS SAM은 template.yaml 파일을 통해 실행되며, 본 예제 파일에서는 Lambda 함수와 관련된 설정을 정의합니다. 3.2.1 표준 빌드 방식 . AWS SAM CLI는 sam build 명령어를 실행할 때, 자동으로 template.yaml 파일에서 지정된 CodeUri 경로에서 Java 프로젝트의 pom.xml 혹은 build.gradle 파일을 찾아 빌드 과정을 진행합니다. | Maven 사용 시: mvn clean install 명령을 사용하여 의존성을 해결하고, 실행 가능한 jar 파일을 컴파일합니다. | Gradle 사용 시: gradle build 명령을 사용하여 동일한 작업을 수행합니다. | . 이러한 빌드 과정은 template.yaml 파일내 있는 BuildMethod: java21 옵션을 통해 AWS SAM이 자동으로 처리합니다. 3.2.2 Makefile을 이용한 커스텀 빌드 설정 . Java 애플리케이션의 경우, 특히 AWS Lambda에 배포될 때, 종종 추가적인 빌드 설정이 필요합니다. Makefile을 통해 사용자가 직접 빌드 과정을 정의할 수 있습니다. build-JavaFunction: mkdir -p \"$(ARTIFACTS_DIR)/lib\" mvn clean package cp -rf ./target/*.jar \"$(ARTIFACTS_DIR)/lib/\" rm -rf ./target . 위 Makefile 스크립트는 아티팩트를 정리하고, jar 파일을 컴파일 한다음, lambda 배포를 위해 지정된 위치에 복사합니다. 명령어에서 사용된 ARTIFACTS_DIR는 AWS SAM이 빌드 중에 사용하는 환경 변수로, 빌드된 파일들을 저장할 경로를 지정합니다. lib 폴더는 Lambda에서 지정한 Java 용 라이브러리를 저장하는데 사용하는 디렉토리 명칭입니다. 폴더 명을 바꾸면 안됩니다. 3.3 Lambda Layer를 통한 의존성 관리 . AWS::Serverless::LayerVersion선언은 Lambda 함수가 실행 시 필요한 의존성을 제공합니다. 이는 Lambda 환경에서 공통 의존성을 제공하여 각 함수의 패키지 크기를 줄이는 데 사용됩니다. 3.4 pom.xml . Java 빌드 과정에서 모든 소스 코드와 의존성은 하나의 jar 파일 안에 포함되어 Lambda에 배포됩니다. AWS Lambda에서 Maven을 이용하여 Java 함수를 구현할 때, pom.xml 파일은 Java 프로젝트의 구성을 정의하고, 필요한 라이브러리들을 관리합니다. 3.4.1 function/pom.xml . &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;java-function&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;java-function&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt; &lt;aws.java.sdk.version&gt;2.25.16&lt;/aws.java.sdk.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt; &lt;artifactId&gt;bom&lt;/artifactId&gt; &lt;version&gt;${aws.java.sdk.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;java-layer&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; . 3.4.3 layer/pom.xml . &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;java-layer&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;java-layer&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; &lt;artifactId&gt;aws-lambda-java-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy&lt;/artifactId&gt; &lt;version&gt;4.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; &lt;artifactId&gt;aws-lambda-java-events&lt;/artifactId&gt; &lt;version&gt;3.11.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt; &lt;artifactId&gt;powertools-tracing&lt;/artifactId&gt; &lt;version&gt;1.12.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;software.amazon.lambda&lt;/groupId&gt; &lt;artifactId&gt;powertools-metrics&lt;/artifactId&gt; &lt;version&gt;1.12.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.13.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;21&lt;/source&gt; &lt;target&gt;21&lt;/target&gt; &lt;release&gt;21&lt;/release&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;configuration&gt; &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; . 3.4.4 pom.xml 주요 부분 상세 설명 . | provided scope | . &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;java-layer&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; . | 역할: 람다 호출 시 런타임이 람다 layer에서 의존성을 제공받기 때문에 람다에 배포할 패키지에 포함시키지 않습니다. | 중요성: 이 설정은 배포 패키지의 크기를 줄이는 데 큰 도움을 주어, 배포 시간과 리소스 사용을 최소화하며, Lambda 함수의 cold start 시간을 개선할 수 있습니다. 또한, 의존성 충돌을 피하는데도 도움이 됩니다. | . | Maven Shade Plugin ```xml | . org.apache.maven.plugins maven-shade-plugin 3.5.2 false package . shade . * **역할**: Maven 프로젝트에서 하나의 실행 가능한 jar 파일을 생성하는 데 사용됩니다. 람다 배포시 단일 실행 파일로 배포해야합니다. ## 4. samconfig.toml SAM 프로젝트를 배포할 때 사용되는 설정 정보를 포함하는 파일입니다. ```toml version=0.1 [default.global.parameters] stack_name = \"common-stack\" [default.deploy.parameters] stack_name = \"stack-lmd-java-sample\" s3_bucket = \"kimkmari-s3\" s3_prefix = \"template/lmd-java-sample\" region = \"ap-northeast-2\" confirm_changeset = false capabilities = \"CAPABILITY_IAM\" [default.build.parameters] no_beta_features = true . ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#3-aws-sam%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-java-application-%EB%B9%8C%EB%93%9C-%EB%B0%8F-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#3-aws-sam을-이용한-java-application-빌드-및-배포"
  },"319": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "5. CodeBuild 이용한 CI/CD 구성",
    "content": "codebuild를 이용해 SAM CLI를 통해 Lambda를 배포할 수 있습니다. 5.1 buildspec.yml . version: 0.2 env: shell: bash phases: install: commands: - java -version - cat /etc/os-release - sam --version build: commands: - echo Build started on `date` - ls -alh ./ - sam build - sam deploy --no-progressbar --no-fail-on-empty-changeset . ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#5-codebuild-%EC%9D%B4%EC%9A%A9%ED%95%9C-cicd-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#5-codebuild-이용한-cicd-구성"
  },"320": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "5. Lambda 배포 확인",
    "content": "codebuild project 수행 확인 . api gateway를 이용한 lambda 호출 . ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda#5-lambda-%EB%B0%B0%ED%8F%AC-%ED%99%95%EC%9D%B8",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda#5-lambda-배포-확인"
  },"321": {
    "doc": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "title": "2-1. AWS SAM을 이용해 Lambda로 JAVA 어플리케이션 배포하기",
    "content": " ",
    "url": "/docs/02_Tech/CICD/SAM/java-sam-lambda",
    
    "relUrl": "/docs/02_Tech/CICD/SAM/java-sam-lambda"
  },"322": {
    "doc": "1. Java",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/InteliJ/Java#color-utilities",
    
    "relUrl": "/docs/02_Tech/InteliJ/Java#color-utilities"
  },"323": {
    "doc": "1. Java",
    "title": "Table of contents",
    "content": ". | 1. InteliJ IDEA 에서 Java 설정하기 . | 1.1 JDK 설정 | 1.2 빌드 구성 | 1.3 디버깅 | 1.4 코드 스타일 | 1.5 프로젝트 구조 | . | 2. 유용한 플러그인 | . 이 블로그 포스트는 IntelliJ IDEA에서 Java 개발 환경을 구성하는 방법에 대해 설명합니다. IntelliJ IDEA는 Java 개발자들 사이에서 매우 인기 있는 통합 개발 환경(IDE) 중 하나로, 다양한 편의 기능과 강력한 개발 도구를 제공합니다. 이 글에서는 IntelliJ IDEA를 사용하여 Java 개발 환경을 설정하는 여러 가지 주요 구성 요소들을 살펴보겠습니다. ",
    "url": "/docs/02_Tech/InteliJ/Java#table-of-contents",
    
    "relUrl": "/docs/02_Tech/InteliJ/Java#table-of-contents"
  },"324": {
    "doc": "1. Java",
    "title": "1. InteliJ IDEA 에서 Java 설정하기",
    "content": "1.1 JDK 설정 . 1.2 빌드 구성 . 1.3 디버깅 . 1.4 코드 스타일 . 1.5 프로젝트 구조 . 설정 빌드, 실행, 배포 빌드 도구 Maven 가져오기 . 자동 다운로드ㅡ 소스, 문서 체크 활성화 . intelij 파일 - 프로젝트 구조 . ",
    "url": "/docs/02_Tech/InteliJ/Java#1-intelij-idea-%EC%97%90%EC%84%9C-java-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/InteliJ/Java#1-intelij-idea-에서-java-설정하기"
  },"325": {
    "doc": "1. Java",
    "title": "2. 유용한 플러그인",
    "content": " ",
    "url": "/docs/02_Tech/InteliJ/Java#2-%EC%9C%A0%EC%9A%A9%ED%95%9C-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8",
    
    "relUrl": "/docs/02_Tech/InteliJ/Java#2-유용한-플러그인"
  },"326": {
    "doc": "1. Java",
    "title": "1. Java",
    "content": " ",
    "url": "/docs/02_Tech/InteliJ/Java",
    
    "relUrl": "/docs/02_Tech/InteliJ/Java"
  },"327": {
    "doc": "Java",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/01_languages/Java#color-utilities",
    
    "relUrl": "/docs/01_languages/Java#color-utilities"
  },"328": {
    "doc": "Java",
    "title": "Table of contents",
    "content": ". | Light Greys | Jenkins를 이용한 파이프라인 구축 | GitHub Actions를 이용한 파이프라인 구축 | GitHub Actions를 이용한 파이프라인 구축 | GitHub Actions를 이용한 파이프라인 구축 | . All the colors used in Just the Docs have been systematized into a series of variables that have been extended to both font color and background color utility classes. ",
    "url": "/docs/01_languages/Java#table-of-contents",
    
    "relUrl": "/docs/01_languages/Java#table-of-contents"
  },"329": {
    "doc": "Java",
    "title": "Light Greys",
    "content": "| Color value | Font color utility | Background color utility | . | grey-lt-000 | .text-grey-lt-000 | .bg-grey-lt-000 | . | grey-lt-100 | .text-grey-lt-100 | .bg-grey-lt-100 | . | grey-lt-200 | .text-grey-lt-200 | .bg-grey-lt-200 | . | grey-lt-300 | .text-grey-lt-300 | .bg-grey-lt-300 | . ",
    "url": "/docs/01_languages/Java#light-greys",
    
    "relUrl": "/docs/01_languages/Java#light-greys"
  },"330": {
    "doc": "Java",
    "title": "Jenkins를 이용한 파이프라인 구축",
    "content": " ",
    "url": "/docs/01_languages/Java#jenkins%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%B6%95",
    
    "relUrl": "/docs/01_languages/Java#jenkins를-이용한-파이프라인-구축"
  },"331": {
    "doc": "Java",
    "title": "GitHub Actions를 이용한 파이프라인 구축",
    "content": " ",
    "url": "/docs/01_languages/Java#github-actions%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%B6%95",
    
    "relUrl": "/docs/01_languages/Java#github-actions를-이용한-파이프라인-구축"
  },"332": {
    "doc": "Java",
    "title": "GitHub Actions를 이용한 파이프라인 구축",
    "content": " ",
    "url": "/docs/01_languages/Java#github-actions%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%B6%95-1",
    
    "relUrl": "/docs/01_languages/Java#github-actions를-이용한-파이프라인-구축-1"
  },"333": {
    "doc": "Java",
    "title": "GitHub Actions를 이용한 파이프라인 구축",
    "content": " ",
    "url": "/docs/01_languages/Java#github-actions%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%B6%95-2",
    
    "relUrl": "/docs/01_languages/Java#github-actions를-이용한-파이프라인-구축-2"
  },"334": {
    "doc": "Java",
    "title": "Java",
    "content": " ",
    "url": "/docs/01_languages/Java",
    
    "relUrl": "/docs/01_languages/Java"
  },"335": {
    "doc": "1-3. jenkins checkout",
    "title": "jenkins pipeline에서 scm 사용하기",
    "content": "Jenkins 파이프라인에서 소스 코드 버전 관리(SCM) 시스템을 사용하는 법 가이드 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline%EC%97%90%EC%84%9C-scm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline에서-scm-사용하기"
  },"336": {
    "doc": "1-3. jenkins checkout",
    "title": "목차",
    "content": ". | jenkins pipeline에서 scm 사용하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. jenkins 파이프라인에서 SCM 체크아웃 설정하기 . | 1.1 jenkins pipeline script code snippet | 1.2 코드 상세 설명 | 1.3 적용 이유 | . | 2. 별첨 | 2.1 changelog 옵션 활성화 | 2.2 폴링 옵션 활성화 | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#목차"
  },"337": {
    "doc": "1-3. jenkins checkout",
    "title": "글을 쓴 배경",
    "content": "하나의 Jenkins 파이프라인에서 두 개 이상의 리포지토리를 참조해야 할 필요성이 발생했습니다. 소스 코드와 CI/CD 관련 코드를 분리하여 관리하고 특정 태그값을 지정해 배포해 달라는 요청을 받았습니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글을-쓴-배경"
  },"338": {
    "doc": "1-3. jenkins checkout",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글-요약"
  },"339": {
    "doc": "1-3. jenkins checkout",
    "title": "시작하기 전",
    "content": "Ubuntu 버전: 22.04 LTS 사용한 Docker 이미지: jenkins/jenkins:jdk17 Jenkins 버전: 2.449 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#시작하기-전"
  },"340": {
    "doc": "1-3. jenkins checkout",
    "title": "1. jenkins 파이프라인에서 SCM 체크아웃 설정하기",
    "content": "1.1 jenkins pipeline script code snippet . checkout scmGit( userRemoteConfigs: [ [ url: 'https://github.com/kimkmari/kimkmariRepo.git'] ], branches: [[name: '*/master']] ) . 1.2 코드 상세 설명 . userRemoteConfigs: 리포지토리의 URL을 지정합니다. branches: 체크아웃할 브랜치를 지정합니다. */main은 레포지토리의 main 브랜치에서 코드를 체크아웃한다는 의미입니다. 1.3 적용 이유 . pipeline code에서 userRemoteConfigs 부분을 명시적으로 지정하지 않고, Jenkins UI를 통해 구성 단계에서 아래와 같이 직접 지정할 수 있습니다. 하지만, CI/CD 코드와 소스 코드를 분리하여 관리하고자 할 때, 소스 코드 리포지토리에는 Jenkinsfile이 존재하지 않을 수 있습니다. 이 경우, SCM 체크아웃 기능을 활용하여 Jenkins 워크스페이스에 원하는 소스 코드를 직접 체크아웃할 수 있습니다. SCM 체크아웃을 사용하면, Jenkins는 지정된 리포지토리에서 소스 코드를 가져와 현재 Jenkins 워크스페이스에 저장합니다. 이 과정에서 워크스페이스 내의 기존 내용은 새로운 소스 코드로 대체되거나 업데이트됩니다. Jenkins 워크스페이스는 Jenkins 빌드 프로세스가 실행되는 디렉토리입니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%97%90%EC%84%9C-scm-%EC%B2%B4%ED%81%AC%EC%95%84%EC%9B%83-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-파이프라인에서-scm-체크아웃-설정하기"
  },"341": {
    "doc": "1-3. jenkins checkout",
    "title": "2. 별첨",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#2-%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#2-별첨"
  },"342": {
    "doc": "1-3. jenkins checkout",
    "title": "2.1 changelog 옵션 활성화",
    "content": "Jenkins 파이프라인에서 코드를 체크아웃할 때 변경 로그를 생성할지 여부를 결정할 수 있습니다. 기본적으로 이 옵션은 활성화되어 있습니다. checkout scmGit( changelog: false, userRemoteConfigs: [ [url: 'https://github.com/jenkinsci/your-plugin.git'] ] ) . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#21-changelog-%EC%98%B5%EC%85%98-%ED%99%9C%EC%84%B1%ED%99%94",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#21-changelog-옵션-활성화"
  },"343": {
    "doc": "1-3. jenkins checkout",
    "title": "2.2 폴링 옵션 활성화",
    "content": "SCM에서 소스 코드 변경이 감지될 때마다 자동으로 빌드를 트리거하는 방식입니다. 폴링을 사용하면 지속적인 통합 프로세스를 자동화할 수 있습니다. checkout scmGit( poll: true, userRemoteConfigs: [ [url: 'https://github.com/jenkinsci/your-plugin.git'] ] ) . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#22-%ED%8F%B4%EB%A7%81-%EC%98%B5%EC%85%98-%ED%99%9C%EC%84%B1%ED%99%94",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#22-폴링-옵션-활성화"
  },"344": {
    "doc": "1-3. jenkins checkout",
    "title": "1-3. jenkins checkout",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm"
  },"345": {
    "doc": "1-3. jenkins checkout",
    "title": "jenkins pipeline에서 scm 사용하기",
    "content": "scm 사용하기 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline%EC%97%90%EC%84%9C-scm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline에서-scm-사용하기"
  },"346": {
    "doc": "1-3. jenkins checkout",
    "title": "목차",
    "content": ". | jenkins pipeline에서 scm 사용하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. jenkins checkout scm . | awscli를 활용한 EC2 Ubuntu OS 배포 . | piepline code snippet | . | 코드 상세 설명 | . | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#목차"
  },"347": {
    "doc": "1-3. jenkins checkout",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글을-쓴-배경"
  },"348": {
    "doc": "1-3. jenkins checkout",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글-요약"
  },"349": {
    "doc": "1-3. jenkins checkout",
    "title": "시작하기 전",
    "content": "Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#시작하기-전"
  },"350": {
    "doc": "1-3. jenkins checkout",
    "title": "1. jenkins checkout scm",
    "content": "awscli를 활용한 EC2 Ubuntu OS 배포 . piepline code snippet . checkout scmGit( userRemoteConfigs: [ [ url: 'https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/portal-int-api-cloud'] ], branches: [[name: '*/master']] ) . 코드 상세 설명 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm"
  },"351": {
    "doc": "1-3. jenkins checkout",
    "title": "별첨",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#별첨"
  },"352": {
    "doc": "1-3. jenkins checkout",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq"
  },"353": {
    "doc": "1-3. jenkins checkout",
    "title": "1-3. jenkins checkout",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm"
  },"354": {
    "doc": "1-3. jenkins checkout",
    "title": "jenkins pipeline에서 scm 사용하기",
    "content": "scm 사용하기 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline%EC%97%90%EC%84%9C-scm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline에서-scm-사용하기"
  },"355": {
    "doc": "1-3. jenkins checkout",
    "title": "목차",
    "content": ". | jenkins pipeline에서 scm 사용하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. jenkins checkout scm . | awscli를 활용한 EC2 Ubuntu OS 배포 . | piepline code snippet | . | 코드 상세 설명 | . | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#목차"
  },"356": {
    "doc": "1-3. jenkins checkout",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글을-쓴-배경"
  },"357": {
    "doc": "1-3. jenkins checkout",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글-요약"
  },"358": {
    "doc": "1-3. jenkins checkout",
    "title": "시작하기 전",
    "content": "Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#시작하기-전"
  },"359": {
    "doc": "1-3. jenkins checkout",
    "title": "1. jenkins checkout scm",
    "content": "awscli를 활용한 EC2 Ubuntu OS 배포 . piepline code snippet . checkout scmGit( userRemoteConfigs: [ [ url: 'https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/portal-int-api-cloud'] ], branches: [[name: '*/master']] ) . 코드 상세 설명 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm"
  },"360": {
    "doc": "1-3. jenkins checkout",
    "title": "별첨",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#별첨"
  },"361": {
    "doc": "1-3. jenkins checkout",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq"
  },"362": {
    "doc": "1-3. jenkins checkout",
    "title": "1-3. jenkins checkout",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm"
  },"363": {
    "doc": "1-3. jenkins checkout",
    "title": "jenkins pipeline에서 scm 사용하기",
    "content": "scm 사용하기 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline%EC%97%90%EC%84%9C-scm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline에서-scm-사용하기"
  },"364": {
    "doc": "1-3. jenkins checkout",
    "title": "목차",
    "content": ". | jenkins pipeline에서 scm 사용하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. jenkins checkout scm . | awscli를 활용한 EC2 Ubuntu OS 배포 . | piepline code snippet | . | 코드 상세 설명 | . | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#목차"
  },"365": {
    "doc": "1-3. jenkins checkout",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글을-쓴-배경"
  },"366": {
    "doc": "1-3. jenkins checkout",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글-요약"
  },"367": {
    "doc": "1-3. jenkins checkout",
    "title": "시작하기 전",
    "content": "Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#시작하기-전"
  },"368": {
    "doc": "1-3. jenkins checkout",
    "title": "1. jenkins checkout scm",
    "content": "awscli를 활용한 EC2 Ubuntu OS 배포 . piepline code snippet . checkout scmGit( userRemoteConfigs: [ [ url: 'https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/portal-int-api-cloud'] ], branches: [[name: '*/master']] ) . 코드 상세 설명 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm"
  },"369": {
    "doc": "1-3. jenkins checkout",
    "title": "별첨",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#별첨"
  },"370": {
    "doc": "1-3. jenkins checkout",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq"
  },"371": {
    "doc": "1-3. jenkins checkout",
    "title": "1-3. jenkins checkout",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm"
  },"372": {
    "doc": "1-3. jenkins checkout",
    "title": "jenkins pipeline에서 scm 사용하기",
    "content": "scm 사용하기 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline%EC%97%90%EC%84%9C-scm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline에서-scm-사용하기"
  },"373": {
    "doc": "1-3. jenkins checkout",
    "title": "목차",
    "content": ". | jenkins pipeline에서 scm 사용하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. jenkins checkout scm . | awscli를 활용한 EC2 Ubuntu OS 배포 . | piepline code snippet | . | 코드 상세 설명 | . | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#목차"
  },"374": {
    "doc": "1-3. jenkins checkout",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글을-쓴-배경"
  },"375": {
    "doc": "1-3. jenkins checkout",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글-요약"
  },"376": {
    "doc": "1-3. jenkins checkout",
    "title": "시작하기 전",
    "content": "Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#시작하기-전"
  },"377": {
    "doc": "1-3. jenkins checkout",
    "title": "1. jenkins checkout scm",
    "content": "awscli를 활용한 EC2 Ubuntu OS 배포 . piepline code snippet . checkout scmGit( userRemoteConfigs: [ [ url: 'https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/portal-int-api-cloud'] ], branches: [[name: '*/master']] ) . 코드 상세 설명 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm"
  },"378": {
    "doc": "1-3. jenkins checkout",
    "title": "별첨",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#별첨"
  },"379": {
    "doc": "1-3. jenkins checkout",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq"
  },"380": {
    "doc": "1-3. jenkins checkout",
    "title": "1-3. jenkins checkout",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm"
  },"381": {
    "doc": "1-3. jenkins checkout",
    "title": "jenkins pipeline에서 scm 사용하기",
    "content": "scm 사용하기 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline%EC%97%90%EC%84%9C-scm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline에서-scm-사용하기"
  },"382": {
    "doc": "1-3. jenkins checkout",
    "title": "목차",
    "content": ". | jenkins pipeline에서 scm 사용하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. jenkins checkout scm . | awscli를 활용한 EC2 Ubuntu OS 배포 . | piepline code snippet | . | 코드 상세 설명 | . | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#목차"
  },"383": {
    "doc": "1-3. jenkins checkout",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글을-쓴-배경"
  },"384": {
    "doc": "1-3. jenkins checkout",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글-요약"
  },"385": {
    "doc": "1-3. jenkins checkout",
    "title": "시작하기 전",
    "content": "Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#시작하기-전"
  },"386": {
    "doc": "1-3. jenkins checkout",
    "title": "1. jenkins checkout scm",
    "content": "awscli를 활용한 EC2 Ubuntu OS 배포 . piepline code snippet . checkout scmGit( userRemoteConfigs: [ [ url: 'https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/portal-int-api-cloud'] ], branches: [[name: '*/master']] ) . 코드 상세 설명 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm"
  },"387": {
    "doc": "1-3. jenkins checkout",
    "title": "별첨",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#별첨"
  },"388": {
    "doc": "1-3. jenkins checkout",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq"
  },"389": {
    "doc": "1-3. jenkins checkout",
    "title": "1-3. jenkins checkout",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm"
  },"390": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "content": "AWS EC2 인스턴스에 Docker를 사용하여 Jenkins를 배포하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#aws-ec2%EC%97%90%EC%84%9C-docker%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-jenkins-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#aws-ec2에서-docker를-사용하여-jenkins-배포하기"
  },"391": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "목차",
    "content": ". | AWS EC2에서 Docker를 사용하여 Jenkins 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS EC2 Ubuntu OS를 awscli를 통해 배포 . | awscli를 활용한 EC2 Ubuntu OS 배포 | . | 2. userdata를 이용한 Jenkins 배포 자동화 . | 2.1 userdata.txt | 2.2 userdata.txt 상세 설명 | . | jenkins 접속하기 | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#목차"
  },"392": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "글을 쓴 배경",
    "content": "Jenkins를 AWS EC2 인스턴스에 설치하는 과정을 기록하기 위해 작성하였습니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#글을-쓴-배경"
  },"393": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "글 요약",
    "content": "AWS EC2 인스턴스에 userdata를 이용하여 Docker로 Jenkins를 Ubuntu OS에 배포하는 방법을 공유합니다. AWS EC2 인스턴스 생성부터 Docker 이미지를 이용한 배포 프로세스까지 스크립트를 이용해 한번에 설치할 수 있도록 구성하였습니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#글-요약"
  },"394": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "시작하기 전",
    "content": "AWS, Docker, Jenkins에 대한 기본적인 이해가 있으신 분들을 위해 작성되었습니다. AWS EC2 인스턴스 생성 및 설정, Docker에 대한 기본 지식이 필요합니다. Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#시작하기-전"
  },"395": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "1. AWS EC2 Ubuntu OS를 awscli를 통해 배포",
    "content": "EC2 인스턴스 생성시, userdata 스크립트를 포함하여 인스턴스가 시작될 때 userdata에 정의된 command를 자동으로 수행하도록 합니다. awscli를 이용하여 배포합니다. 보안그룹은 웹 서버에 필요한 80(HTTP) 포트와 443(HTTPS) 포트를 열어 외부의 접근을 허용합니다. awscli를 활용한 EC2 Ubuntu OS 배포 . aws ec2 run-instances \\ --image-id ${UBUNTU_AMI_ID} \\ --count 1 \\ --instance-type t3.large \\ --key-name ${KEY_NAME} \\ --iam-instance-profile Name=${INSTANCE_PROFILE_ROLE} \\ --subnet-id ${SUBNET_ID} \\ --security-group-ids ${JENKINS_SG} \\ --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=jenkins-aws-cli-generate}]' \\ --block-device-mappings 'DeviceName=/dev/sda1,Ebs={VolumeSize=100}' \\ --user-data file://userdata.txt . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#1-aws-ec2-ubuntu-os%EB%A5%BC-awscli%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#1-aws-ec2-ubuntu-os를-awscli를-통해-배포"
  },"396": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "2. userdata를 이용한 Jenkins 배포 자동화",
    "content": "2.1 userdata.txt . 아래 스크립트는 EC2 인스턴스 생성 시 실행되며 Jenkins을 설치하기 위한 환경을 구축합니다. Jenkins 디렉토리 생성, Docker 설치 및 설정, Jenkins Docker 컨테이너 실행 등으로 구성되었습니다. #!/bin/bash # 사용자 변수 설정 USER_NAME=ubuntu # Jenkins 디렉토리 생성 및 디렉토리 소유권변경 mkdir -p /home/ubuntu/jenkins/jenkins_home chown -R ubuntu:ubuntu /home/ubuntu/jenkins # Docker 설치 echo \"1. [docker program installation] start\" apt-get update -y curl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh usermod -aG docker ${USER_NAME} # Docker 서비스 활성화 및 시작 systemctl enable docker systemctl start docker # Jenkins Docker 컨테이너 실행 docker run -d -p 80:8080 -p 50000:50000 \\ --name jenkins \\ -v /home/ubuntu/jenkins/jenkins_home:/var/jenkins_home \\ jenkins/jenkins:jdk17 # Jenkins 초기 관리자 비밀번호 저장 echo \"Waiting for Jenkins to initialize...\" sleep 30 # Jenkins 초기화를 기다림 docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword &gt; /home/ubuntu/jenkins/initialAdminPassword.txt chown ubuntu:ubuntu /home/ubuntu/jenkins/initialAdminPassword.txt . 2.2 userdata.txt 상세 설명 . 사용자 변수 지정 . | Jenkins과 Docker를 실행할 사용자 이름을 설정합니다. USER_NAME=ubuntu . | . Jenkins 디렉토리 생성 및 디렉토리 소유권변경 . mkdir -p /home/ubuntu/jenkins/jenkins_home chown -R ubuntu:ubuntu /home/ubuntu/jenkins . Docker 설치 . | 공식 Docker 설치 스크립트를 다운받아 실행합니다. 설정한 USER_NAME에 해당하는 사용자를 Docker 그룹에 추가합니다. | 기본적으로 도커 실행 권한은 root에만 있습니다. ${USER_NAME} 사용자를 Docker 그룹에 추가하여, sudo 없이 Docker 명령을 실행할 수 있도록 합니다. | . echo \"1. [docker program installation] start\" apt-get update -y curl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh usermod -aG docker ${USER_NAME} . Docker 서비스 활성화 및 시작 . systemctl enable docker systemctl start docker . Jenkins Docker 컨테이너 실행 . | -d 컨테이너 백그라운드 실행 | -p 8080:8080 젠킨슨은 기본적으로 8080 포트에서 웹 인터페이스를 제공합니다. 호스트 포트를 변경하여 외부에서 Jenkins 웹 인터페이스에 접근하는 포트를 변경할 수 있습니다. | -p 50000:50000 젠킨슨 에이전트가 실행되기 위한 포트도 컨테이너에 연결해 줍니다. | –name 컨테이너 이름을 지정합니다. | -v Jenkins 데이터를 호스트 서버에 마운트하기 위한 설정입니다. Jenkins 설정 및 빌드데이터가 컨테이너 재시작 후에도 유지됩니다. | . # Jenkins Docker 컨테이너 실행 docker run -d -p 8080:8080 -p 50000:50000 \\ --name jenkins \\ -v /home/ubuntu/jenkins/jenkins_home:/var/jenkins_home \\ jenkins/jenkins:jdk17 . Jenkins 초기 관리자 비밀번호 저장 . | 컨테이너 내부에 있는 var/jenkins_home/secrets 디렉토리내에 있는 비밀번호를 확인합니다. | echo \"Waiting for Jenkins to initialize...\" sleep 30 # Jenkins 초기화를 기다림 docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword &gt; /home/ubuntu/jenkins/initialAdminPassword.txt chown ubuntu:ubuntu /home/ubuntu/jenkins/initialAdminPassword.txt . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#2-userdata%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-jenkins-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#2-userdata를-이용한-jenkins-배포-자동화"
  },"397": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "jenkins 접속하기",
    "content": "http://:8080 에 접속합니다. 서버에 접속한 후 Administrator password를 확인합니다. /home/ubuntu/jenkins/initialAdminPassword.txt 해당 경로에서 확인 가능합니다. 컨테이너를 배포할 때 확인했던 비밀번호를 입력해줍니다. install suggested plugins를 클릭하고 젠킨슨을 설치해줍니다. | 이미 jenkins/jenkins:jdk17을 이용해서 젠킨슨을 설치했기 때문에 Oracle Java SE Development Kit Installer 해당 플러그인은 삭제하여도 무방합니다. | . 접속 성공 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#jenkins-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#jenkins-접속하기"
  },"398": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "별첨",
    "content": "설치된 플러그인에대한 간략한 설명 . Pipeline: REST API: 파이프라인 상태, 결과 등을 조회할 수 있습니다. Pipeline: Stage View: 파이프라인의 각 스테이지를 시각적으로 표현해주는 UI를 제공합니다. Oracle Java SE Development Kit Installer: Oracle의 웹사이트에서 Java SE Development Kit(JDK)를 다운로드하여 설치할 수 있게 해주는 플러그인입니다. Command Agent Launcher: 지정된 명령어를 사용하여 에이전트를 실행할 수 있게 해주는 에이전트 관리 플러그인입니다. SSH server: Jenkins에 SSH 서버 기능을 추가하여, CLI 명령을 통해 Jenkins를 원격으로 조작할 수 있게 해주는 플러그인입니다. Authentication Tokens API: 자격증명을 인증 토큰으로 변환하는 API를 제공합니다. Jenkins에서 보다 안전한 인증 방법을 구현할 때 사용됩니다. Docker Pipeline: Jenkins 파이프라인에서 Docker 컨테이너를 빌드하고 사용할 수 있게 해주는 플러그인입니다. Lockable Resources: 복수의 작업이 동일한 외부 자원에 의존하는 복잡한 CI/CD 파이프라인을 구성할 때 유용합니다. 이 플러그인을 사용함으로써 자원 충돌을 방지하고, 빌드 프로세스의 안정성과 효율성을 높일 수 있습니다. Role-based Authorization Strategy: 사용자 권한을 역할 기반으로 관리할 수 있게 해주는 보안 플러그인입니다. JSch dependency: SSH 연결을 위한 Java 라이브러리인 JSch를 Jenkins 플러그인으로 제공합니다. Maven Integration: Maven 프로젝트와 Jenkins 사이의 통합을 제공합니다. Docker Commons: 다양한 Docker 관련 플러그인에서 사용할 수 있는 공통 기능을 제공합니다. HTML Publisher: 빌드 후 생성된 HTML 보고서를 Jenkins에서 직접 볼 수 있게 해주는 플러그인입니다. Role-based Authorization Strategy: 사용자와 그룹에 역할 기반의 접근 제어를 허용하는 보안 플러그인입니다. Subversion: Jenkins에서 Apache Subversion 지원을 추가합니다. SVNKit을 통해 Subversion 저장소와의 상호 작용을 가능하게 합니다. Favorite: 사용자가 특정 작업을 ‘즐겨찾기’로 설정할 수 있게 해주는 플러그인입니다. Parameterized Trigger: 한 빌드가 완료된 후 다양한 방법으로 새 빌드를 트리거할 수 있게 해주는 플러그인입니다. 새 빌드에 파라미터를 전달하는 것도 가능합니다. Bitbucket Branch Source: Bitbucket Cloud 및 Bitbucket Server를 사용하여 프로젝트의 소스로 활용할 수 있게 해주는 플러그인입니다. Blue Ocean: 이들 모두 Blue Ocean UI와 관련된 플러그인으로, Jenkins의 사용자 경험을 현대화하고, 파이프라인 관리 및 시각화를 향상시키기 위해 설계되었습니다. DataTables.net API: jQuery DataTables를 Jenkins 플러그인에 제공합니다. 이를 통해 HTML 테이블에 고급 기능을 쉽게 추가할 수 있습니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#별첨"
  },"399": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "FAQ",
    "content": "Q: 설치된 젠킨슨에서 플러그인을 재대로 다운받지 못하면 어떻게 해야 하나요? . A: 보안 그룹 설정에 플러그인을 다운받기위한 HTTP, HTTPS 포트가 열려 있는지 확인합니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation#faq"
  },"400": {
    "doc": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "title": "1-1. AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-installation",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-installation"
  },"401": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "Jenkins Configuration as Code 플러그인을 사용하여 사용자 정의 구성이 적용된 Jenkins Docker 서비스 배포하기",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#jenkins-configuration-as-code-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%9C-jenkins-docker-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#jenkins-configuration-as-code-플러그인을-사용하여-사용자-정의-구성이-적용된-jenkins-docker-서비스-배포하기"
  },"402": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "목차",
    "content": ". | Jenkins Configuration as Code 플러그인을 사용하여 사용자 정의 구성이 적용된 Jenkins Docker 서비스 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | EC2 인스턴스에 사용자 정의 구성내용을 포한한 Jenkins 인스턴스 배포 . | awscli를 활용한 EC2 배포 | userdata를 이용한 Jenkins 자동배포 | 2.1 userdata.txt | 2.2 userdata.txt 상세 설명 | . | . | Docker 설치 | Docker 서비스 활성화 및 시작 . | jenkins 접속하기 | Advanced Jenkins Configuration as Code . | 1. 세분화된 Role-Based Access Control ( RBAC ) 설정 . | Agent roles | . | . | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#목차"
  },"403": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "글을 쓴 배경",
    "content": "단순한 Jenkins 배포가 아닌 유저 프로비저닝 등 다양한 젠킨슨 설정을 자동으로 구성할 필요성을 느끼게 되었습니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#글을-쓴-배경"
  },"404": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "글 요약",
    "content": "사용된 플러그인 . | Jenkins Configuration as Code: | Role-based-Authorization Strategy: | . 프로세스 요약 . | userdata를 포함한 ec2 생성 하위는 userdata에 포함된 내용 | 역할 기반 설정과 관리자 사용자의 자격 증명을 포함하는 jenkins.yml 파일을 생성합니다. | 환경 변수 CASC_JENKINS_CONFIG를 설정하여 첫 번째 단계에서 생성한 jenkins.yml 파일을 배치할 위치를 지정합니다. | jenkins.yml 파일을 CASC_JENKINS_CONFIG의 위치에 바인드 마운트합니다. Jenkins 설정을 YAML 파일로 정의함으로써 사용자 지정 젠킨슨 구성을 자동화 합니다. | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#글-요약"
  },"405": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "시작하기 전",
    "content": "Jenkins와 AWS에 대한 기본적인 사용 경험을 가진 DevOps 엔지니어를 대상으로 합니다. Jenkins에 대한 기본적인 이해가 필요합니다. 사용한 레포지토리 주소 Jenkins-repo . https://github.com/jenkinsci/configuration-as-code-plugin/tree/master/demos . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#시작하기-전"
  },"406": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "EC2 인스턴스에 사용자 정의 구성내용을 포한한 Jenkins 인스턴스 배포",
    "content": "awscli를 활용한 ec2 배포 부분은 앞에서 설명한 방식과 동일합니다. 본 내용에서는 최초 젠킨슨 이미지를 배포할 때 유저 프로비저닝 등 다양한 환경구성을 함께 적용하여 배포하는 방식을 공유합니다. awscli를 활용한 EC2 배포 . aws ec2 run-instances \\ --image-id ${UBUNTU_AMI_ID} \\ --count 1 \\ --instance-type t3.large \\ --key-name ${KEY_NAME} \\ --iam-instance-profile Name=${INSTANCE_PROFILE_ROLE} \\ --subnet-id ${SUBNET_ID} \\ --security-group-ids ${JENKINS_SG} \\ --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=jenkins-aws-cli-generate}]' \\ --block-device-mappings 'DeviceName=/dev/sda1,Ebs={VolumeSize=100}' \\ --user-data file://userdata.txt . userdata를 이용한 Jenkins 자동배포 . 2.1 userdata.txt . 아래 스크립트는 EC2 인스턴스 생성 시 실행되며 Jenkins을 설치하기 위한 환경을 구축합니다. ~ 등으로 구성되었습니다. #!/bin/bash # 사용자 변수 설정 USER_NAME=ubuntu # 사용자 디렉토리 생성 및 디렉토리 소유권변경 mkdir -p /home/ubuntu/jenkins/jenkins_home mkdir -p /home/ubuntu/jenkins/data chown -R ${USER_NAME}:${USER_NAME} /home/ubuntu/jenkins # Docker 설치 echo \"1. [docker program installation] start\" apt-get update -y curl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh usermod -aG docker ${USER_NAME} newgrp docker # Docker 서비스 활성화 및 시작 systemctl enable docker systemctl start docker # Docker Compose 설치 apt list docker docker-compose apt install docker-compose -y cd ~/jenkins/data # Jenkins Plugin 설치 su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/plugins.txt &lt;&lt;EOF configuration-as-code:1775.v810dc950b_514 role-strategy:713.vb_3837801b_8cc EOF\" ## Jenkins Configuration as Code (JCasC) 정의 su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/jenkins.yaml &lt;&lt;EOF jenkins: authorizationStrategy: roleBased: roles: global: - name: \"admin\" permissions: - \"Overall/Administer\" entries: - user: \"user1\" - user: \"admin\" - name: \"readonly\" permissions: - \"Overall/Read\" entries: - group: \"authenticated\" - user: \"anonymous\" securityRealm: local: allowsSignup: false users: - id: \"admin\" password: \"1234\" - id: \"user1\" password: \"1234\" EOF\" # Dockerfile 생성 su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/Dockerfile &lt;&lt;EOF FROM jenkins/jenkins:jdk17 USER root RUN apt-get update -y &amp;&amp; apt-get upgrade -y USER jenkins COPY ./plugins.txt /usr/share/jenkins/plugins.txt RUN jenkins-plugin-cli -f /usr/share/jenkins/plugins.txt COPY ./jenkins.yaml /usr/share/jenkins/jenkins.yaml EOF\" # Docker-compose 파일 생성 su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/docker-compose.yml &lt;&lt;EOF version: '3.9' services: jenkins: build: ~/jenkins/data container_name: jenkins user: jenkins environment: JAVA_OPTS: -Djenkins.install.runSetupWizard=false -Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Seoul CASC_JENKINS_CONFIG: /usr/share/jenkins/jenkins.yaml restart: always ports: - \\\"80:8080\\\" - \\\"50000:50000\\\" volumes: - /home/ubuntu/jenkins/jenkins_home:/var/jenkins_home EOF\" su - ${USER_NAME} -c \"cd ~/jenkins/data; docker-compose up -d\" . 2.2 userdata.txt 상세 설명 . 사용자 변수 지정 . | Jenkins과 Docker를 실행할 사용자 이름을 설정합니다. USER_NAME=ubuntu . | . 사용자 디렉토리 생성 및 디렉토리 소유권변경 . | jenkins_home 디렉토리 : Jenkins 어플리케이션 중요 데이터 저장소입니다. 컨테이너 내부의 핵심 데이터를 외부에 저장하여 컨테이너 재시작 시 데이터 손실 없이 재 가동할 수 있도록 합니다. | data 디렉토리 : Jenkins 설치에 필요한 추가 파일을 보관합니다. | 디렉토리 소유권 변경: 생성한 디렉토리와 하위 모든 파일의 소유권을 ${USER_NAME}로 설정합니다. mkdir -p /home/ubuntu/jenkins/jenkins_home mkdir -p /home/ubuntu/jenkins/data chown -R ${USER_NAME}:${USER_NAME} /home/ubuntu/jenkins . | . Docker 설치 및 시작 . | 공식 Docker 설치 스크립트를 다운받아 실행합니다. 설정한 USER_NAME에 해당하는 사용자를 Docker 그룹에 추가합니다. | 기본적으로 도커 실행 권한은 root에만 있습니다. ${USER_NAME} 사용자를 Docker 그룹에 추가하여, sudo 없이 Docker 명령을 실행할 수 있도록 합니다. | systemctl을 사용하여 Docker 서비스를 시스템 부팅 시 자동으로 시작되도록 설정합니다. ```bash ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#ec2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%97%90-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EA%B5%AC%EC%84%B1%EB%82%B4%EC%9A%A9%EC%9D%84-%ED%8F%AC%ED%95%9C%ED%95%9C-jenkins-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#ec2-인스턴스에-사용자-정의-구성내용을-포한한-jenkins-인스턴스-배포"
  },"407": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "Docker 설치",
    "content": "echo “1. [docker program installation] start” apt-get update -y curl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh usermod -aG docker ${USER_NAME} newgrp docker . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#docker-%EC%84%A4%EC%B9%98",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#docker-설치"
  },"408": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "Docker 서비스 활성화 및 시작",
    "content": "systemctl enable docker systemctl start docker . **Docker Compose 설치** * docker-compse는 yml 파일에 Jenkins 설치 시 필요한 환경 변수와 볼륨 등 다양한 설정을 담음으로써, 간단한 명령으로 docker를 실행시킬 수 있도록 합니다. ```bash apt list docker docker-compose apt install docker-compose -y . Jenkins Plugin 설치 . | configuration-as-code:1775.v810dc950b_514 : jenkins.yml 파일을 사용하여 Jenkins 구성을 코드 형태로 자동화하고 관리할 수 있게 해줍니다. | role-strategy:713.vb_3837801b_8cc: 사용자에게 역할 및 권한 부여를 통해 사용자의 접근 수준을 설정하여 Jenkins의 보안을 강화할 수 있습니다. | 설치 후 아래와 같은 항목이 새롭게 생겨나게 됩니다. | . cd ~/jenkins/data su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/plugins.txt &lt;&lt;EOF configuration-as-code:1775.v810dc950b_514 role-strategy:713.vb_3837801b_8cc EOF\" . Jenkins Configuration as Code (JCasC) jenkins.yaml 파일 정의 . 설치된 플러그인을 활용하여, Jenkins의 구성을 jenkins.yaml 파일로 자동화합니다. 설정내용 . | 역할 기반 권한 부여: admin 역할에는 Jenkins의 전반적인 관리 권한(Overall/Administer)을 부여하고, readonly 역할에는 읽기 권한(Overall/Read)만 부여합니다. | 사용자 관리: securityRealm 설정을 통해 Jenkins 로그인에 필요한 사용자 계정을 생성합니다. | jenkins.yaml 적용전 . | 최초 플러그인을 실행시 현재 접속해 있는 admin 유저만 권한을 가지게 설정되어있습니다. | . | jenkins.yaml 적용 후 . | 새롭게 readonly 역할을 만들어 admin 유저가 아니더라도 로그인 된 인증된 유저가 젠킨슨 view 권한을 갖도록 | admin 권한에 생성한 유저를 추가할 수 있습니다. | readonly 역할에 anonymous | . | . su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/jenkins.yaml &lt;&lt;EOF jenkins: authorizationStrategy: roleBased: roles: global: - name: \"admin\" permissions: - \"Overall/Administer\" entries: - user: \"user1\" - user: \"admin\" - name: \"readonly\" permissions: - \"Overall/Read\" entries: - group: \"authenticated\" - user: \"anonymous\" securityRealm: local: allowsSignup: false users: - id: \"admin\" password: \"1234\" - id: \"user1\" password: \"1234\" EOF\" . Docker File 생성 . 이 파일은 Jenkins 서버의 이미지를 생성하고, 앞서 정의한 플러그인을 설치하며, jenkins.yaml 파일을 Jenkins Configuration as Code 플러그인이 파일을 수행할 수 있는 위치에 복사하는 역할을 합니다. | 패키지 업데이트 및 업그레이드를 위해 root 사용자로 전환하여 이미지 내의 패키지를 최신 상태로 유지합니다. | USER jenkins 명령어를 통해, 플러그인 설치와 관련된 작업을 root 가 아닌 Jenkins 사용자로 전환하여 실행합니다. | jenkins-plugin-cli 를 통해 정의된 플러그인들을 설치합니다. | Jenkins 이 정의된 jenkins.yaml 구성파일을 로드할 수 있도록 구성합니다. | . su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/Dockerfile &lt;&lt;EOF FROM jenkins/jenkins:jdk17 USER root RUN apt-get update -y &amp;&amp; apt-get upgrade -y USER jenkins COPY ./plugins.txt /usr/share/jenkins/plugins.txt RUN jenkins-plugin-cli -f /usr/share/jenkins/plugins.txt COPY ./jenkins.yaml /usr/share/jenkins/jenkins.yaml EOF\" . Docker Compose 파일 생성 및 실행 . | 컨테이너 빌드 및 설정: build: ~/jenkins/data: Dockerfile이 위치한 디렉토리 경로를 지정하여 Jenkins 이미지를 빌드합니다. | container_name: 생성될 컨테이너의 이름을 jenkins로 설정합니다. | user: 컨테이너 내에서 jenkins 유저로 프로세스를 실행합니다. | 환경 변수 설정: . | JAVA_OPTS: Jenkins 설치 마법사를 건너뛰고, 시간대를 설정합니다. | CASC_JENKINS_CONFIG: JCasC 플러그인이 jenkins.yaml 파일을 찾을 경로를 지정합니다. | . | restart: Docker 호스트가 재부팅되거나 컨테이너가 멈췄을 때 자동으로 컨테이너를 재시작하도록 설정합니다. | 포트 매핑: 호스트와 컨테이너 간의 포트를 매핑하여, 외부에서 Jenkins에 접근할 수 있도록 합니다. | 볼륨 마운트: - /home/ubuntu/jenkins/jenkins_home:/var/jenkins_home 옵션은 호스트의 jenkins_home 디렉토리를 컨테이너의 /var/jenkins_home에 마운트하여, Jenkins 데이터를 영구적으로 보존합니다. | . # Docker-compose 파일 생성 su - ${USER_NAME} -c \"cat &gt; ~/jenkins/data/docker-compose.yml &lt;&lt;EOF version: '3.9' services: jenkins: build: ~/jenkins/data container_name: jenkins user: jenkins environment: JAVA_OPTS: -Djenkins.install.runSetupWizard=false -Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Seoul CASC_JENKINS_CONFIG: /usr/share/jenkins/jenkins.yaml restart: always ports: - \\\"80:8080\\\" - \\\"50000:50000\\\" volumes: - /home/ubuntu/jenkins/jenkins_home:/var/jenkins_home EOF\" su - ${USER_NAME} -c \"cd ~/jenkins/data; docker-compose up -d\" . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#docker-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%99%9C%EC%84%B1%ED%99%94-%EB%B0%8F-%EC%8B%9C%EC%9E%91",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#docker-서비스-활성화-및-시작"
  },"409": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "jenkins 접속하기",
    "content": "http://:8080 에 접속합니다. 앞서 설치한 플러그인으로 새롭게 생겨난 아래 두 섹션을 확인할 수 있습니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#jenkins-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#jenkins-접속하기"
  },"410": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "Advanced Jenkins Configuration as Code",
    "content": "1. 세분화된 Role-Based Access Control ( RBAC ) 설정 . Global roles 적용 범위: Jenkins 어플리케이션 전체에 대한 Role을 정의합니다. 예를 들어 “Administer” 권한을 가진 admin Role은 Jenkins 설정을 변경할 수 있습니다. Item roles 목적: 특정 Jenkins 항목(예: 작업, 뷰, 폴더)에 대한 접근 권한을 세분화하여 정의합니다. 적용 범위: 특정 패턴이나 경로에 일치하는 항목에 대한 권한을 제어합니다. 이는 폴더 구조 내에서 미세한 접근 제어를 가능하게 하여, 특정 프로젝트 또는 팀의 작업에 대한 접근을 제한할 수 있습니다. 예시: ‘FolderA’ 역할은 “A/.” 패턴에 일치하는 모든 항목에 대한 특정 권한을 가지며, ‘FolderB’ 역할은 “B.” 패턴에 일치하는 항목에 대해 다른 권한 세트를 가집니다. Agent roles . Jenkins에서 “Manage Roles” 페이지는 역할 기반 접근 제어(Role-Based Access Control, RBAC)를 설정하는 중요한 부분입니다. 여기서 관리자는 세 가지 유형의 역할을 정의할 수 있습니다: “Global roles”, “Item roles”, 그리고 “Agent roles”. 이 역할들은 Jenkins 내에서 다양한 자원과 작업에 대한 접근 권한을 세밀하게 제어할 수 있게 합니다. 각 역할 유형의 차이점을 이해하는 것은 권한 관리와 보안 정책을 효과적으로 적용하는 데 중요합니다. Global Roles 목적: Jenkins 인스턴스 전체에 대한 권한을 정의합니다. 적용 범위: Jenkins의 모든 부분에 걸쳐 일반적인 권한을 제공합니다. 예를 들어, “Administer” 권한을 가진 사용자는 Jenkins 설정을 변경할 수 있는 반면, “Read” 권한을 가진 사용자는 정보를 볼 수만 있습니다. 예시: ‘admin’ 역할에는 시스템 전체를 관리할 수 있는 권한이 부여될 수 있으며, ‘readonly’ 역할에는 시스템 전체를 볼 수 있는 권한만 부여됩니다. Item Roles 목적: 특정 Jenkins 항목(예: 작업, 뷰, 폴더)에 대한 접근 권한을 세분화하여 정의합니다. 적용 범위: 특정 패턴이나 경로에 일치하는 항목에 대한 권한을 제어합니다. 이는 폴더 구조 내에서 미세한 접근 제어를 가능하게 하여, 특정 프로젝트 또는 팀의 작업에 대한 접근을 제한할 수 있습니다. 예시: ‘FolderA’ 역할은 “A/.” 패턴에 일치하는 모든 항목에 대한 특정 권한을 가지며, ‘FolderB’ 역할은 “B.” 패턴에 일치하는 항목에 대해 다른 권한 세트를 가집니다. Agent Roles 목적: Jenkins 에이전트에 대한 접근 권한을 정의합니다. Jenkins 에이전트는 빌드와 관련 작업을 실행하는 데 사용되는 시스템입니다. 적용 범위: 특정 에이전트 또는 에이전트 그룹에 대한 접근 권한을 제어합니다. 이를 통해 어떤 사용자가 에이전트를 구성하거나 조작할 수 있는지 결정할 수 있습니다. 예시: ‘Agent1’ 역할은 “agent1” 패턴에 일치하는 특정 에이전트에 대한 권한을 제어합니다. 각 역할 유형은 Jenkins 내에서 특정 자원에 대한 접근과 관리를 세밀하게 조절할 수 있는 유연성을 제공합니다. 이를 통해 조직은 필요에 따라 보안 정책을 세분화하고 엄격하게 적용할 수 있습니다. jenkins: authorizationStrategy: roleBased: roles: global: - name: \"admin\" permissions: - \"Overall/Administer\" entries: - user: \"admin\" - name: \"readonly\" permissions: - \"Overall/Read\" - \"Job/Read\" entries: - user: \"authenticated\" items: - name: \"FolderA\" pattern: \"A/.*\" permissions: - \"Job/Configure\" - \"Job/Build\" - \"Job/Delete\" entries: - user: \"user1\" - user: \"user2\" - name: \"FolderB\" pattern: \"B.*\" permissions: - \"Job/Configure\" - \"Job/Build\" entries: - user: \"user2\" agents: - name: \"Agent1\" description: \"Agent 1\" pattern: \"agent1\" permissions: - \"Agent/Build\" entries: - user: \"user1\" securityRealm: local: allowsSignup: false users: - id: \"admin\" password: \"1234\" - id: \"user1\" password: \"\" - id: \"user_hashed\" # password is password password: \"#jbcrypt:$2a$10$3bnAsorIxhl9kTYvNHa2hOJQwPzwT4bv9Vs.9KdXkh9ySANjJKm5u\" . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#advanced-jenkins-configuration-as-code",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#advanced-jenkins-configuration-as-code"
  },"411": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "FAQ",
    "content": "Q: 설치된 젠킨슨에서 플러그인을 재대로 다운받지 못하면 어떻게 해야 하나요? . A: 보안 그룹 설정에 플러그인을 다운받기위한 HTTP, HTTPS 포트가 열려 있는지 확인합니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation#faq"
  },"412": {
    "doc": "1-2 Jenkins 설치하기 with JCASC",
    "title": "1-2 Jenkins 설치하기 with JCASC",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-jcasc-installation"
  },"413": {
    "doc": "1-3. jenkins checkout",
    "title": "jenkins pipeline에서 scm 사용하기",
    "content": "scm 사용하기 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline%EC%97%90%EC%84%9C-scm-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#jenkins-pipeline에서-scm-사용하기"
  },"414": {
    "doc": "1-3. jenkins checkout",
    "title": "목차",
    "content": ". | jenkins pipeline에서 scm 사용하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. jenkins checkout scm . | awscli를 활용한 EC2 Ubuntu OS 배포 . | piepline code snippet | . | 코드 상세 설명 | . | 별첨 | FAQ | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#목차"
  },"415": {
    "doc": "1-3. jenkins checkout",
    "title": "글을 쓴 배경",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글을-쓴-배경"
  },"416": {
    "doc": "1-3. jenkins checkout",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#글-요약"
  },"417": {
    "doc": "1-3. jenkins checkout",
    "title": "시작하기 전",
    "content": "Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#시작하기-전"
  },"418": {
    "doc": "1-3. jenkins checkout",
    "title": "1. jenkins checkout scm",
    "content": "awscli를 활용한 EC2 Ubuntu OS 배포 . piepline code snippet . checkout scmGit( userRemoteConfigs: [ [ url: 'https://git-codecommit.ap-northeast-2.amazonaws.com/v1/repos/portal-int-api-cloud'] ], branches: [[name: '*/master']] ) . 코드 상세 설명 . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#1-jenkins-checkout-scm"
  },"419": {
    "doc": "1-3. jenkins checkout",
    "title": "별첨",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#%EB%B3%84%EC%B2%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#별첨"
  },"420": {
    "doc": "1-3. jenkins checkout",
    "title": "FAQ",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm#faq"
  },"421": {
    "doc": "1-3. jenkins checkout",
    "title": "1-3. jenkins checkout",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-checkout-scm"
  },"422": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "Microsoft Teams에 Jenkins Pipeline 배포 알림 및 승인 메세지 전송하기",
    "content": "젠킨슨 파이프라인을 통한 자동화된 배포 프로세스에서 관리자의 직접적인 승인이 필요할 때, Microsoft Teams를 통해 알림 및 승인 요청을 구현하는 방법에 대해 소개합니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#microsoft-teams%EC%97%90-jenkins-pipeline-%EB%B0%B0%ED%8F%AC-%EC%95%8C%EB%A6%BC-%EB%B0%8F-%EC%8A%B9%EC%9D%B8-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%A0%84%EC%86%A1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#microsoft-teams에-jenkins-pipeline-배포-알림-및-승인-메세지-전송하기"
  },"423": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. Teams 설정 . | 1.1 Incoming webhooks 생성 | 1.2 Incoming Webhooks 이용 방법 | . | 2. Lambda 설정 | 2.1 Lambda 함수 코드 | 2.2 Lambda 함수 상세 설명 . | 2.2.1 이벤트 데이터 처리 | 2.2.2 메시지 제목 생성 | 2.2.3 Teams 메시지 페이로드 구성 | 2.2.4 메세지 전송 | 2.2.5 응답 처리 | . | 3. Jenkins 구성 . | 3.1 플러그인을 활용하여 파이프라인 알림 메세지 보내기 . | 3.1.1 Office 365 Connector Plugin 설치하기 | 3.1.2 Office 365 Connector 구성하기 | . | 3.2 람다를 통해 커스텀 알림 메세지 구성하기 . | 3.2.1 Teams 젠킨슨 파이프라인 파일을 만들어 줍니다. | 3.2.2 Teams 젠킨슨 파이프라인 코드 상세 설명 . | 3.2.2.1 Git Commit ID 추출 | 3.2.2.2 사용자 정보 추출 | 3.2.2.3 AWS Lambda 함수 호출 | 3.2.2.4 사용자 입력 요청 | . | . | . | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#목차"
  },"424": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "글을 쓴 배경",
    "content": "단순 자동화된 프로세스를 이용하는 것이 아닌 중요한 운영환경 배포 프로세스에서 관리자의 승인이 필요한 경우가 발생하였습니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#글을-쓴-배경"
  },"425": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "글 요약",
    "content": "이 글에서는 Jenkins, Microsoft Teams, 그리고 AWS Lambda를 사용하여 배포 프로세스 중 승인 메커니즘을 구현하는 방법에 대해 설명합니다. | Microsoft Teams: 알림을 수신할 채널 및 연결 설정 방법 | AWS Lambda: Node.js 20x 를 사용하여 Teams 채널로 메세지를 보내는 lambda 함수 구성 방법 | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#글-요약"
  },"426": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "시작하기 전",
    "content": "Jenkins와 AWS에 대한 사용 경험을 가진 DevOps 엔지니어를 대상으로 합니다. AWS Lambda에서 Node.js 20x를 사용하여 Teams 채널로 메시지를 보내는 프로세스에 대한 전반적인 이해가 필요합니다. 참고 문헌 : Create Incoming Webhooks . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#시작하기-전"
  },"427": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "1. Teams 설정",
    "content": "1.1 Incoming webhooks 생성 . Teams 채널에 콘텐츠를 공유할 수 있게 하기 위해 Incoming Webhooks를 생성합니다. 이 기능을 활용해 Jenkins로부터의 배포 알림 및 승인 요청을 Teams 채널로 직접 보낼 수 있습니다. | Teams에 접속하여 Incoming Webhook을 생성하고자 하는 채널로 이동합니다. | 채널 이름 오른쪽에 있는 ‘더 보기 옵션 •••’을 선택합니다. | . | Manage channel을 선택합니다. | . | Edit을 선택한 후, Incoming Webhook을 찾아서 구성합니다. 이미 한번 추가하셨다면 Add가 아닌 Configure로 보여지게 됩니다. | . . | Webhook에 Jenkins라고 이름을 지정하고 Create를 클릭합니다. | . | Done을 클릭하면 이제 Webhook Url을 받아 사용할 수 있게 됩니다. | . 1.2 Incoming Webhooks 이용 방법 . Incoming Webhooks를 통해 Teams 채널에 다음 기능을 포함한 메시지를 보낼 수 있습니다. | Adaptive Cards: 복잡한 메시지 콘텐츠를 구성하며, 텍스트, 이미지, 버튼, 입력 필드 등 다양한 컴포넌트를 사용할 수 있습니다. | HTTPS 통신: HTTPS POST 요청을 통해 메시지를 전송합니다. | Markdown 지원: 기본 Markdown 문법을 지원합니다. | 적용 범위 제한: 특정 Teams 채널에 대해서만 구성되며, 메시지 전송도 해당 채널로 한정됩니다. | 리소스 정의 형식: 메시지는 JSON 형식으로 전송됩니다. | . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#1-teams-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#1-teams-설정"
  },"428": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "2. Lambda 설정",
    "content": "AWS Lambda를 사용하여 Adaptive Card를 활용한 메시지를 Teams 채널로 보내는 함수를 구성합니다. 이 Lambda 함수는 Jenkins로부터 호출되어, Teams에 메시지를 전송하는 역할을 합니다. ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#2-lambda-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#2-lambda-설정"
  },"429": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "2.1 Lambda 함수 코드",
    "content": "아래 코드는 Node.js 20x를 사용한 Lambda함수입니다. import https from 'https'; export const handler = async (event) =&gt; { console.log(\"EVENT\", event); const { jobName, jenkinsUrl, buildNumber, startTime, deployExecutor, gitRevision, environment, gitTagName } = event; let messageTitle = jobName.substring(jobName.lastIndexOf(\"-\") + 1).charAt(0).toUpperCase() + jobName.substring(jobName.lastIndexOf(\"-\") + 1).slice(1).toLowerCase(); // 변환된 문자열을 메시지 제목에 포함 messageTitle = `${messageTitle} API - Jenkins 배포 승인 알림 메세지`; // Teams Webhook URL const teamsWebhookUrl = process.env.TEAMS_WEBHOOK_URL; // Construct the JSON payload for Teams const teamsPayload = JSON.stringify( { \"type\":\"message\", \"attachmentLayout\": \"list\", \"attachments\":[ { \"contentType\": \"application/vnd.microsoft.card.adaptive\", \"content\": { \"type\": \"AdaptiveCard\", \"body\": [ { \"type\": \"Container\", \"style\": \"emphasis\", \"items\": [ { \"type\": \"ColumnSet\", \"columns\": [ { \"type\": \"Column\", \"items\": [ { \"type\": \"TextBlock\", \"size\": \"large\", \"weight\": \"bolder\", \"text\": `${messageTitle}`, \"wrap\": true, \"style\": \"heading\" } ], \"width\": \"stretch\" } ] } ], \"bleed\": true }, { \"type\": \"ActionSet\", \"actions\": [ { \"type\": \"Action.OpenUrl\", \"spacing\": \"extraLarge\", \"title\": \"View Approval Page\", \"url\": `${jenkinsUrl}input/` } ] }, { \"type\": \"Container\", \"items\": [ { \"type\": \"FactSet\", \"spacing\": \"exlarge\", \"facts\": [ { \"title\": \"Job name\", \"value\": `${jobName}` }, { \"title\": \"Build number\", \"value\": `${buildNumber}` }, { \"title\": \"Start time\", \"value\": `${startTime}` }, { \"title\": \"Triggered by\", \"value\": `${deployExecutor}` }, { \"title\": \"Git Revision\", \"value\": `${gitRevision}` }, { \"title\": \"Environment\", \"value\": `${environment}` }, { \"title\": \"Git Tag Name\", \"value\": `${gitTagName}` } ] } ] } ], \"$schema\": \"http://adaptivecards.io/schemas/adaptive-card.json\", \"version\": \"1.2\", \"fallbackText\": \"This card requires Adaptive Cards v1.5 support to be rendered properly.\" } } ] } ); const options = { method: 'POST', headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(teamsPayload), } }; // Function to send message to Teams const sendMessageToTeams = () =&gt; { return new Promise((resolve, reject) =&gt; { const req = https.request(teamsWebhookUrl, options, (res) =&gt; { let body = ''; res.on('data', (chunk) =&gt; { body += chunk; }); res.on('end', () =&gt; { resolve(body); }); }); req.on('error', (error) =&gt; { reject(error); }); // Send the JSON payload to Teams req.write(teamsPayload); req.end(); }); }; try { const response = await sendMessageToTeams(); console.log('Response:', response); return { statusCode: 200, body: 'Message sent to Teams successfully' }; } catch (error) { console.error('Error:', error); return { statusCode: 500, body: 'Error sending message to Teams' }; } }; . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#21-lambda-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#21-lambda-함수-코드"
  },"430": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "2.2 Lambda 함수 상세 설명",
    "content": "2.2.1 이벤트 데이터 처리 . Lambda 함수는 Jenkins로부터 전달받은 custom event 객체에서 변수를 선언하면서, 필요한 정보를 추출합니다. custom event 객체에는 젠킨슨에서 배포와 관련된 상세 정보를 제공합니다. custom event 객체는 젠킨슨 파이프라인 단계에서 정의할 수 있습니다. const { jobName, jenkinsUrl, buildNumber, startTime, deployExecutor, gitRevision, environment, gitTagName } = event; . 2.2.2 메시지 제목 생성 . 메시지의 제목은 Jenkins 작업 이름(jobName)에서 결정됩니다. 단순하게 문자열로 정의하셔도 무방합니다. let messageTitle = jobName.substring(jobName.lastIndexOf(\"-\") + 1).charAt(0).toUpperCase() + jobName.substring(jobName.lastIndexOf(\"-\") + 1).slice(1).toLowerCase(); messageTitle = `${messageTitle} API - Jenkins 배포 승인 알림 메세지`; . 2.2.3 Teams 메시지 페이로드 구성 . 배포 정보와 승인 페이지 링크를 포함하는 Adaptive Card 형식의 메시지를 구성합니다. const teamsPayload = JSON.stringify({ \"type\": \"message\", \"attachmentLayout\": \"list\", \"attachments\": [{ \"contentType\": \"application/vnd.microsoft.card.adaptive\", \"content\": { \"type\": \"AdaptiveCard\", \"body\": [ { \"type\": \"Container\", \"style\": \"emphasis\", \"items\": [{ \"type\": \"ColumnSet\", \"columns\": [{ \"type\": \"Column\", \"items\": [{ \"type\": \"TextBlock\", \"size\": \"large\", \"weight\": \"bolder\", \"text\": messageTitle, \"wrap\": true, \"style\": \"heading\" }], \"width\": \"stretch\" }] }], \"bleed\": true }, { \"type\": \"ActionSet\", \"actions\": [{ \"type\": \"Action.OpenUrl\", \"title\": \"View Approval Page\", \"url\": `${jenkinsUrl}input/` }] } // FactSet 및 기타 정보 추가 ], \"$schema\": \"http://adaptivecards.io/schemas/adaptive-card.json\", \"version\": \"1.2\", \"fallbackText\": \"This card requires Adaptive Cards v1.5 support to be rendered properly.\" } }] }); . 2.2.4 메세지 전송 . 구성된 메세지를 Teams Incoming Webhooks URL로 전송합니다. HTTPS POST 요청을 사용하며, 요청 성공 여부에 따라 응답코드를 반환합니다. const options = { method: 'POST', headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(teamsPayload), } }; const sendMessageToTeams = () =&gt; { return new Promise((resolve, reject) =&gt; { const req = https.request(teamsWebhookUrl, options, (res) =&gt; { let body = ''; res.on('data', (chunk) =&gt; { body += chunk; }); res.on('end', () =&gt; { resolve(body); }); }); req.on('error', (error) =&gt; { reject(error); }); req.write(teamsPayload); req.end(); }); }; . 2.2.5 응답 처리 . 메시지 전송 성공 시 “Message sent to Teams successfully”와 상태 코드 200을 반환합니다. 오류 발생 시 오류 메시지와 상태 코드 500을 반환합니다. try { const response = await sendMessageToTeams(); console.log('Response:', response); return { statusCode: 200, body: 'Message sent to Teams successfully' }; } catch (error) { console.error('Error:', error); return { statusCode: 500, body: 'Error sending message to Teams' }; } . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#22-lambda-%ED%95%A8%EC%88%98-%EC%83%81%EC%84%B8-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#22-lambda-함수-상세-설명"
  },"431": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "3. Jenkins 구성",
    "content": "Jenkins에서는 배포 알림 메세지를 Teams로 보내기 위해 Office 365 Connector 플러그인을 사용할 수도 있고 Lambda를 이용해 커스텀한 메세지를 보낼 수 있습니다. 3.1 플러그인을 활용하여 파이프라인 알림 메세지 보내기 . 3.1.1 Office 365 Connector Plugin 설치하기 . 메세지를 보낼 스테이지를 구성하기 위한 젠킨슨 잡을 생성합니다. 본 블로그는 pipeline project로 구성하였습니다. 젠킨슨 플러그인에서 Office 365 Connector을 설치합니다. 젠킨슨 job 구성에 Office 365 Connector이 새롭게 생성되었음을 확인합니다. 3.1.2 Office 365 Connector 구성하기 . 1. Notification webhooks 를 구성합니다. | URL - Teams channel 에서 발급받은 Incomming Webhook Url을 넣어줍니다. | Name - 임의의 이름을 정해줍니다. | . 2. 고급 기능을 통해 빌드 상태에 따라 알림 메세지를 전송할 수 있습니다. Build status 설명 . 3. Advanced Configuration을 구성합니다. | Macros - 특정 조건이 만족될 때만 알림이 전송되도록 추가적인 조건을 정의합니다. | 아래 예시는 checkout 스텝을 실행한 후 env.GIT_BRANCH 를 통해 가져온 브랜치 이름이 main인 경우만 알림을 보내겠다는 의미입니다. | . | Fact Definitions - Teams Channel로 보내는 메세지에 사용자 정의 정보를 추가할 수 있습니다. macros 뿐만아니라 Fact Definitons에서도 젠킨슨 파이프라인 내에 정의된 커스텀 변수 혹은 젠킨슨에서 제공해주는 환경변수 모두 사용 가능합니다. | 아래 예시는 알림 메시지에 현재 잡 빌드 번호를 추가하고 싶을 때 사용하는 방법입니다. | . | . | Timeout - TCP와 HTTP 연결에 대한 타임아웃을 밀리초 단위로 설정합니다. 기본값은 30000 ( 30초 ) 입니다. 젠킨슨이 알림을 전송하는 데 걸리는 최대 시간을 뜻합니다. | . 3.2 람다를 통해 커스텀 알림 메세지 구성하기 . Jenkins 파이프라인에서 커스텀 알림 메시지를 보낼 람다를 호출하는 스크립트를 작성하여 배포 승인 요청을 포함한 다양한 정보를 Teams 채널로 전송할 수 있습니다. 3.2.1 Teams 젠킨슨 파이프라인 파일을 만들어 줍니다. stage('Invoke Teams Approval') { script { GIT_COMMIT_ID = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim() // Git 커밋 ID를 가져오는 스크립트 echo \"Git Commit ID =&gt; [${GIT_COMMIT_ID}]\" wrap([$class: 'BuildUser']) { def user = env.BUILD_USER_ID step([$class : 'LambdaInvokeBuildStep', lambdaInvokeBuildStepVariables: [ awsRegion : \"${AWS_REGION}\", functionName : \"${LAMBDA_FUNCTION_NAME}\", synchronous : true, payload: \"{ \\\"jobName\\\": \\\"${env.JOB_NAME}\\\", \\\"jenkinsUrl\\\": \\\"${env.BUILD_URL}\\\", \\\"buildNumber\\\": \\\"${env.BUILD_NUMBER}\\\", \\\"startTime\\\": \\\"${env.BUILD_TIMESTAMP}\\\", \\\"deployExecutor\\\": \\\"${user}\\\", \\\"gitRevision\\\": \\\"${GIT_COMMIT_ID}\\\", \\\"environment\\\": \\\"${ENV_TARGET}\\\", \\\"gitTagName\\\": \\\"${CONTAINER_IMAGE_TAG}\\\"}\", useInstanceCredentials: true ] ]) } def userInput = input( id: 'deploy-confirm', message: 'Deploy to production?', ok: 'Proceed', submitter: 'admin', parameters: [] ) } } . 3.2.2 Teams 젠킨슨 파이프라인 코드 상세 설명 . 3.2.2.1 Git Commit ID 추출 . GIT_COMMIT_ID = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim() echo \"Git Commit ID =&gt; [${GIT_COMMIT_ID}]\" . 3.2.2.2 사용자 정보 추출 . BuildUser 래퍼를 사용하여 현재 Jenkins 빌드를 트리거한 사용자의 ID를 가져옵니다. wrap([$class: 'BuildUser']) { def user = env.BUILD_USER_ID ... } . 3.2.2.3 AWS Lambda 함수 호출 . 참고자료 : AWS Lamabda Plugin . LambdaInvokeBuildStep 은 AWS Lambda 함수를 관리하고 호출 할 수 있도록 해주는 플러그인입니다. 그중 invokeLambda 메소드를 사용하여 람다를 호출하고 Lambda에게 전달할 EVENT JSON을 구성하고 전달합니다. synchronous 옵션을 통해 Lambda 함수를 동기식으로 호출합니다. Lambda 함수의 실행 결과를 기다리고 응답을 반환한 후 다음 단계로 넘어갈 수 있도록 합니다. wrap([$class: 'BuildUser']) { def user = env.BUILD_USER_ID step([$class : 'LambdaInvokeBuildStep', lambdaInvokeBuildStepVariables: [ awsRegion : \"${AWS_REGION}\", functionName : \"${LAMBDA_FUNCTION_NAME}\", synchronous : true, payload: \"{ \\\"jobName\\\": \\\"${env.JOB_NAME}\\\", \\\"jenkinsUrl\\\": \\\"${env.BUILD_URL}\\\", \\\"buildNumber\\\": \\\"${env.BUILD_NUMBER}\\\", \\\"startTime\\\": \\\"${env.BUILD_TIMESTAMP}\\\", \\\"deployExecutor\\\": \\\"${user}\\\", \\\"gitRevision\\\": \\\"${GIT_COMMIT_ID}\\\", \\\"environment\\\": \\\"${ENV_TARGET}\\\", \\\"gitTagName\\\": \\\"${CONTAINER_IMAGE_TAG}\\\"}\", useInstanceCredentials: true ] ]) } . 3.2.2.4 사용자 입력 요청 . 참고자료 : Pipeline:Input Step . input step 은 Jenkins 파이프라인 실행을 일시 중지하고 사용자의 승인을 기다리게 해주는 플러그인입니다. 사용자 입력을 기다리는 페이지가 호출되고 사용자에게는 “계속” 또는 “중단” 옵션이 보여지게 됩니다. | id - 파이프라인 내에 여러 input 스텝이 있을경우 명확히 관리할 수 있도록 사용합니다. | submitter - 이 입력에 응답할 수 있는 사용자 ID와/또는 외부 그룹을 지정합니다. | . def userInput = input( id: 'deploy-confirm', message: 'Deploy to production?', ok: 'Proceed', submitter: 'admin', parameters: [] ) . ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#3-jenkins-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams#3-jenkins-구성"
  },"432": {
    "doc": "1-3 Teams 배포 승인 메세지",
    "title": "1-3 Teams 배포 승인 메세지",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins/jenkins-notification-teams"
  },"433": {
    "doc": "1. Jenkins",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins#color-utilities",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins#color-utilities"
  },"434": {
    "doc": "1. Jenkins",
    "title": "Table of contents",
    "content": ". 참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/CICD/Jenkins#table-of-contents",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins#table-of-contents"
  },"435": {
    "doc": "1. Jenkins",
    "title": "1. Jenkins",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Jenkins",
    
    "relUrl": "/docs/02_Tech/CICD/Jenkins"
  },"436": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "Authorization@Edge: Lambda@Edge와 JSON Web Tokens을 사용하여 웹 애플리케이션 보안 강화하기",
    "content": " ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#authorizationedge-lambdaedge%EC%99%80-json-web-tokens%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88-%EA%B0%95%ED%99%94%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#authorizationedge-lambdaedge와-json-web-tokens을-사용하여-웹-애플리케이션-보안-강화하기"
  },"437": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "Table of contents",
    "content": ". | 1. Amazon CloudFront란? | 2. Lambda@Edge와 Amazon Cognito | 3. Lambda@Edge를 이용한 인증의 이점 | 4. 솔루션 개요 | 5. 솔루션 흐름 | 6. 요청 차단 테스트 | 7. 배포 방법 | 8. 테스트 방법 | 9. Cache Behavior란? | 10. CloudFront Functions vs Lambda@Edge | CloudFront Functions와 Lambda@Edge 비교 . | 사용 사례 . | CloudFront Functions의 적합한 사용 사례 | Lambda@Edge의 적합한 사용 사례 | 작업 내용 정리 | . | . | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#table-of-contents",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#table-of-contents"
  },"438": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "1. Amazon CloudFront란?",
    "content": "Amazon CloudFront는 글로벌 콘텐츠 배포 네트워크(CDN) 서비스로, 데이터, 비디오, 애플리케이션 및 API를 낮은 지연 시간과 높은 전송 속도로 시청자에게 안전하게 전달합니다. Lambda@Edge를 사용하면 AWS Lambda 함수를 고객에게 가까운 AWS 위치에서 CloudFront 이벤트에 응답하여 실행할 수 있습니다. 서버를 프로비저닝하거나 관리할 필요 없이 코드가 CloudFront 이벤트(뷰어의 콘텐츠 요청 또는 오리진 서버 요청 등)에 의해 트리거됩니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#1-amazon-cloudfront%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#1-amazon-cloudfront란"
  },"439": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "2. Lambda@Edge와 Amazon Cognito",
    "content": "Lambda@Edge는 다음 지점에서 CloudFront 요청 및 응답을 변경하는 데 사용할 수 있습니다: . CloudFront가 뷰어의 요청을 받은 후 (Viewer Request) CloudFront가 오리진으로 요청을 전달하기 전 (Origin Request) CloudFront가 오리진으로부터 응답을 받은 후 (Origin Response) CloudFront가 응답을 뷰어에게 전달하기 전 (Viewer Response) 샘플 애플리케이션은 JSON Web Tokens(JWT)를 사용하여 비공개 콘텐츠에 대한 접근을 인증합니다. JWT는 JSON 기반의 표준으로, 콘텐츠의 진위성과 무결성을 확인할 수 있는 액세스 토큰을 생성합니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#2-lambdaedge%EC%99%80-amazon-cognito",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#2-lambdaedge와-amazon-cognito"
  },"440": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "3. Lambda@Edge를 이용한 인증의 이점",
    "content": ". | 향상된 성능: 뷰어와 가까운 Lambda@Edge에서 인증 기능을 실행하여 지연 시간과 응답 시간을 줄입니다. | 오리진 서버의 부하 감소: JWT 서명 검증과 같은 CPU 집약적인 작업을 오프로드하여 오리진 서버의 부하를 줄입니다. | 보안 강화: 오리진 인프라에 도달하기 전에 인증되지 않은 요청을 필터링할 수 있습니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#3-lambdaedge%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%A6%9D%EC%9D%98-%EC%9D%B4%EC%A0%90",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#3-lambdaedge를-이용한-인증의-이점"
  },"441": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "4. 솔루션 개요",
    "content": "이 블로그 포스트에서는 Lambda@Edge를 사용하여 뷰어 요청을 인증하는 방법을 샘플 애플리케이션을 통해 설명합니다. 이 솔루션은 Amazon Cognito와 Amazon S3도 사용합니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#4-%EC%86%94%EB%A3%A8%EC%85%98-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#4-솔루션-개요"
  },"442": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "5. 솔루션 흐름",
    "content": ". | 로그인 시도: 사용자의 웹 브라우저가 Amazon Cognito 사용자 지정 UI 페이지로 리디렉션되어 로그인 및 인증을 시도합니다. | 인증 및 검증: 인증 후 Cognito는 JWT를 생성하고 서명한 후 JWT를 URL에 포함시켜 리디렉션 응답을 보냅니다. | 접근 요청: 웹 브라우저는 JWT를 추출하여 비공개 콘텐츠에 대한 요청을 생성하고, Authorization 헤더에 JWT를 포함시켜 요청을 보냅니다. | Lambda@Edge 요청 처리: CloudFront는 요청을 가장 가까운 엣지 로케이션으로 라우팅하며, Viewer Request 이벤트에서 Lambda@Edge 함수를 실행합니다. | JWT 검증: Lambda@Edge 함수는 JWT를 디코딩하고, 사용자 자격을 확인하며, 서명을 검증합니다. | 오리진 접근: 검증이 완료되면 Lambda@Edge 함수는 Authorization 헤더를 제거하고 요청을 오리진으로 전달합니다. 이 예시에서는 비공개 Amazon S3 버킷이 오리진으로 사용됩니다. | 데이터 흐름 설명 이 솔루션은 Amazon CloudFront를 사용하여 지연 시간을 줄이고 성능을 가속화합니다. | 정적 콘텐츠는 Amazon S3에 저장되며, 비공개 데이터는 비공개 S3 버킷에 JSON 형식으로 저장됩니다. | Lambda@Edge는 요청에 포함된 JWT를 검증하여 유효한 요청만 오리진으로 전달합니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#5-%EC%86%94%EB%A3%A8%EC%85%98-%ED%9D%90%EB%A6%84",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#5-솔루션-흐름"
  },"443": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "6. 요청 차단 테스트",
    "content": ". | 접근 차단 확인: 인증되지 않은 상태에서 비공개 데이터를 요청하면 Lambda@Edge가 접근을 차단합니다. | JWT 획득: Amazon Cognito에서 사용자로 등록하고 인증을 받아 JWT를 획득합니다. | 비공개 데이터 요청: JWT를 포함한 요청을 통해 비공개 데이터에 접근합니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#6-%EC%9A%94%EC%B2%AD-%EC%B0%A8%EB%8B%A8-%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#6-요청-차단-테스트"
  },"444": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "7. 배포 방법",
    "content": ". | 스택 생성: CloudFormation 스택을 사용하여 솔루션을 배포합니다. | Lambda@Edge 함수 게시: Lambda 함수를 게시하여 CloudFront 배포와 연결합니다. | CloudFront 배포 구성: Lambda 함수를 Viewer Request 이벤트에 연결합니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#7-%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#7-배포-방법"
  },"445": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "8. 테스트 방법",
    "content": ". | 애플리케이션 위치 찾기: CloudFormation 스택의 MAINURL로 이동하여 웹 애플리케이션에 접근합니다. | 접근 차단 확인: 인증되지 않은 상태에서 접근을 시도해 차단 여부를 확인합니다. | JWT 획득 및 데이터 요청: Amazon Cognito를 통해 인증하고 JWT를 획득하여 비공개 데이터를 요청합니다. 결론 | . 이 블로그 포스트에서는 Lambda@Edge와 JSON Web Tokens을 사용하여 Amazon CloudFront 배포에서 뷰어 요청을 인증하는 방법을 설명했습니다. 이 솔루션을 통해 웹 애플리케이션의 성능과 보안을 모두 강화할 수 있습니다. 자세한 내용은 GitHub에서 소스 코드를 확인할 수 있습니다. 이 솔루션에 대한 질문이나 문제는 CloudFront 포럼, Cognito 포럼 또는 AWS 지원팀에 문의하십시오. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#8-테스트-방법"
  },"446": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "9. Cache Behavior란?",
    "content": "요청을 처리하는 방법을 정의하는 구성 요소 / 어떤 캐시 동작에 Lambda 함수를 연결하지를 결정하는 옵션 . 만약 * 기본값으로 설정하면 모든 경로에 대해 동일한 캐시 동작을 적용합니다. /images 다음과 같이 특정 경로 패턴에 대해 캐시 동작을 정의할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#9-cache-behavior%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#9-cache-behavior란"
  },"447": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "10. CloudFront Functions vs Lambda@Edge",
    "content": "CloudFront Function : 웹 요청에 대한 가벼운 계산 작업을 수행하는데 이상적입니다. JavaScript 런타임을 지원하며 HTTP 헤더 조작, URL 리디렉션, 캐시 키 조작, 액세스 인증등을 수행할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#10-cloudfront-functions-vs-lambdaedge",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#10-cloudfront-functions-vs-lambdaedge"
  },"448": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "CloudFront Functions와 Lambda@Edge 비교",
    "content": "| 특징 | CloudFront Functions | Lambda@Edge | . | 프로그래밍 언어 | JavaScript (ECMAScript 5.1 호환) | Node.js 및 Python | . | 이벤트 소스 | Viewer request, Viewer response | Viewer request, Viewer response, Origin request, Origin response | . | Amazon CloudFront KeyValueStore 지원 | 예 (JavaScript 런타임 2.0에서만) | 아니요 | . | 확장성 | 초당 10,000,000 요청 이상 처리 가능 | 리전당 초당 최대 10,000 요청 | . | 함수 지속 시간 | 서브밀리초 | 최대 5초 (Viewer request 및 Viewer response), 최대 30초 (Origin request 및 Origin response) | . | 최대 메모리 | 2MB | 128MB – 10,240MB (10GB) | . | 함수 코드 및 라이브러리 최대 크기 | 10KB | 1MB (Viewer request 및 Viewer response), 50MB (Origin request 및 Origin response) | . | 네트워크 액세스 | 아니요 | 예 | . | 파일 시스템 액세스 | 아니요 | 예 | . | 요청 본문 액세스 | 아니요 | 예 | . | 지리적 위치 및 장치 데이터 액세스 | 예 | 아니요 (Viewer request 및 Viewer response), 예 (Origin request 및 Origin response) | . | CloudFront 내에서 완전한 빌드 및 테스트 가능 여부 | 예 | 아니요 | . | 함수 로깅 및 지표 | 예 | 예 | . | 가격 | 무료 티어 제공; 요청당 요금 부과 | 무료 티어 없음; 요청 및 함수 지속 시간에 따라 요금 부과 | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#cloudfront-functions%EC%99%80-lambdaedge-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#cloudfront-functions와-lambdaedge-비교"
  },"449": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "사용 사례",
    "content": "CloudFront Functions의 적합한 사용 사례 . | 캐시 키 정규화: HTTP 요청 속성(헤더, 쿼리 문자열, 쿠키, URL 경로)을 변환하여 최적의 캐시 키를 생성하고 캐시 적중률을 개선합니다. | 헤더 조작: 요청 또는 응답에서 HTTP 헤더를 삽입, 수정 또는 삭제합니다. | URL 리디렉션 또는 다시 쓰기: 요청 정보를 기반으로 사용자를 다른 페이지로 리디렉션하거나 경로를 변경합니다. | 요청 권한 부여: JWT와 같은 해시된 권한 부여 토큰을 검증하여 요청을 인증합니다. | . CloudFront Functions 시작하기 . Lambda@Edge의 적합한 사용 사례 . | 수 밀리초 이상의 실행 시간이 필요한 함수 | 조정 가능한 CPU 또는 메모리가 필요한 함수 | 타사 라이브러리(AWS SDK 포함)에 의존하는 함수 | 외부 서비스 처리를 위해 네트워크 액세스가 필요한 함수 | 파일 시스템 액세스 또는 HTTP 요청 본문에 액세스가 필요한 함수 | . Lambda@Edge 시작하기 . 확장성 부분 재 정리 . CloudFront Functions는 Edge보다 훨신 높은 초당 트래픽 처리가 가능합니다. 초당 천만 / Edge 리전당 초당 만 . CloudFront Function은 주로 짧고 가벼운 작업에 최적화 되었습니다. Edge는 더 복잡하고 시간이 오래 걸리는 작업을 처리할 수 있지만 초당 트래픽 처리가 제한됩니다. 함수 지속 시간 . 이벤트에 응답하여 코드를 실행할 때 걸리는 시간에 대한 차이를 설명 . 함수가 실행되는 시간이 밀리초 단위로 매우 빠르다 . Lambda@Edge - viewer request 5ch // 상대적으로 긴 실행시간을 허용합니다. 최대 메모리 . 메모리 할당 제한 설명 / 각 function이 얼마나 많은 메모리를 사용할 수 있는지에 대한 차이점 . CloudFront는 2MB만 사용 가능 . Lambda@Edge는 128 ~ 10240 사용 가능 . cloudfront 내에서 완전한 빌드 및 테스트 가능 . CloudEdge 함수 코드 및 라이브러리 최대 크기: -&gt; RS256 방식까진 가능 1MB (Viewer request 및 Viewer response) . 네트워크 액세스 CloudFront Functions: 네트워크 액세스를 지원하지 않습니다. 의미: CloudFront Functions는 외부 네트워크에 접근할 수 없으므로, 외부 API 호출이나 데이터베이스 연결이 필요한 작업에 적합하지 않습니다. Lambda@Edge: 네트워크 액세스를 지원합니다. 의미: Lambda@Edge는 외부 네트워크에 접근할 수 있어 외부 API 호출이나 데이터베이스 연결을 수행할 수 있습니다. 파일 시스템 액세스 CloudFront Functions: 파일 시스템 액세스를 지원하지 않습니다. 의미: CloudFront Functions는 로컬 파일 시스템에 접근하거나 파일을 읽고 쓸 수 없습니다. Lambda@Edge: 파일 시스템 액세스를 지원합니다. 의미: Lambda@Edge는 로컬 파일 시스템에 접근할 수 있어 파일 읽기/쓰기 작업을 수행할 수 있습니다. 요청 본문 액세스 CloudFront Functions: 요청 본문에 접근할 수 없습니다. 의미: CloudFront Functions는 HTTP 요청의 본문 데이터를 읽을 수 없으므로, 본문 데이터를 기반으로 하는 작업에 적합하지 않습니다. Lambda@Edge: 요청 본문에 접근할 수 있습니다. 의미: Lambda@Edge는 HTTP 요청의 본문 데이터를 읽을 수 있어, 본문 데이터를 처리하는 작업에 적합합니다. 지리적 위치 및 장치 데이터 액세스 CloudFront Functions: 지리적 위치 및 장치 데이터에 접근할 수 있습니다. 의미: CloudFront Functions는 사용자 위치나 장치 정보를 기반으로 작업을 수행할 수 있습니다. Lambda@Edge: 지리적 위치 및 장치 데이터 접근 여부가 이벤트 유형에 따라 다릅니다. Viewer request 및 Viewer response: 지리적 위치 및 장치 데이터에 접근할 수 없습니다. Origin request 및 Origin response: 지리적 위치 및 장치 데이터에 접근할 수 있습니다. CloudFront 내에서 완전한 빌드 및 테스트 가능 여부 CloudFront Functions: CloudFront 내에서 완전한 빌드 및 테스트가 가능합니다. 의미: CloudFront Functions는 CloudFront 콘솔 내에서 직접 빌드하고 테스트할 수 있습니다. Lambda@Edge: CloudFront 내에서 완전한 빌드 및 테스트가 불가능합니다. 의미: Lambda@Edge는 AWS Lambda 콘솔에서 빌드하고 테스트해야 하며, CloudFront 콘솔 내에서는 테스트할 수 없습니다. 함수 로깅 및 지표 CloudFront Functions: 함수 로깅 및 지표를 지원합니다. 의미: CloudFront Functions는 실행 로그와 성능 지표를 제공하여 함수의 동작을 모니터링할 수 있습니다. Lambda@Edge: 함수 로깅 및 지표를 지원합니다. 의미: Lambda@Edge도 실행 로그와 성능 지표를 제공하여 함수의 동작을 모니터링할 수 있습니다. 가격 CloudFront Functions: 무료 티어 제공; 요청당 요금 부과 의미: CloudFront Functions는 무료 티어가 있으며, 요청 수에 따라 요금이 부과됩니다. Lambda@Edge: 무료 티어 없음; 요청 및 함수 지속 시간에 따라 요금 부과 의미: Lambda@Edge는 무료 티어가 없으며, 요청 수와 함수 실행 시간에 따라 요금이 부과됩니다. 이 비교를 통해 CloudFront Functions와 Lambda@Edge의 기능 차이를 이해하고, 특정 사용 사례에 적합한 도구를 선택할 수 있습니다. 가격 비교 . Lambda@Edge 보다 지연시간이 짧다 비용이 6/1 정도 . 가장 큰 차이점은 execution time, 네트워크 액세스 유무, 가격 . body 내용 접근이 불가 . 가격 (Request 요금 / 백만 개 당) : 0.1 USD / 0.6 USD . 작업 내용 정리 . | API Gateway . | HTTP API 구축 완료: HTTP API 구축완료 및 API 라우팅 경로 생성 방법 전달 완료. | CloudWatch 로그 수집 구축 완료: API Gateway의 로그가 CloudWatch로 수집되도록 설정 완료. API 호출 및 응답에 대한 모니터링 가능 | 인증 절차 구현 완료: Header에 포함된 Jwt 토큰을 통한 인증처리가 구현되었습니다. RS256 알고리즘 방식을 적용했으며, 현재 임시 토큰을 사용하고 있습니다. | API 호출 설정: POST https://$API_GATEWAY_DOMAIN/$ENV/tls 로 구성하였습니다. | . | Lambda . | SAM을 통한 배포 프로세스 구축: AWS SAM(Serverless Application Model)을 사용한 람다 배포 프로세스가 구축되었으며, 사용법도 함께 전달하였습니다. | SAMPLE 코드 업로드: JWT Authorization 및 Redis Search Lambda 함수 코드가 AWS CodeCommit을 통해 업로드되었습니다. | Lambda 코드 배포 예정: HAE 에서 실제 배포할 람다함수 소스를 업로드 예정 | . | GitLab . | 자격증명 설정: AWS S3에 접근하기 위한 GitLab AWS 자격증명 설정 방법 전달 완료. | 산출물 업로드 방법 가이드: GitLab에서 빌드 완료된 산출물을 지정된 S3 버킷에 업로드 하는 법 가이드 완료 | . | . 남은일 . | api gateway와 custom domain 연결 | Lambda source 업로드 후 opensearch 테스트 진행 | 실제 token을 이용한 jwt 인증 람다 테스트 | 배포 파이프라인 구축 필요 | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#사용-사례"
  },"450": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "1. Lambda@Edge 와 JWT Web Tokens",
    "content": " ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge"
  },"451": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "Authorization@Edge: Lambda@Edge와 JSON Web Tokens을 사용하여 웹 애플리케이션 보안 강화하기",
    "content": " ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#authorizationedge-lambdaedge%EC%99%80-json-web-tokens%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B3%B4%EC%95%88-%EA%B0%95%ED%99%94%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#authorizationedge-lambdaedge와-json-web-tokens을-사용하여-웹-애플리케이션-보안-강화하기"
  },"452": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "Table of contents",
    "content": ". | 1. Amazon CloudFront란? | 2. Lambda@Edge와 Amazon Cognito | 3. Lambda@Edge를 이용한 인증의 이점 | 4. 솔루션 개요 | 5. 솔루션 흐름 | 6. 요청 차단 테스트 | 7. 배포 방법 | 8. 테스트 방법 | 9. Cache Behavior란? | 10. CloudFront Functions vs Lambda@Edge | CloudFront Functions와 Lambda@Edge 비교 . | 사용 사례 . | CloudFront Functions의 적합한 사용 사례 | Lambda@Edge의 적합한 사용 사례 | 작업 내용 정리 | . | . | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#table-of-contents",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#table-of-contents"
  },"453": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "1. Amazon CloudFront란?",
    "content": "Amazon CloudFront는 글로벌 콘텐츠 배포 네트워크(CDN) 서비스로, 데이터, 비디오, 애플리케이션 및 API를 낮은 지연 시간과 높은 전송 속도로 시청자에게 안전하게 전달합니다. Lambda@Edge를 사용하면 AWS Lambda 함수를 고객에게 가까운 AWS 위치에서 CloudFront 이벤트에 응답하여 실행할 수 있습니다. 서버를 프로비저닝하거나 관리할 필요 없이 코드가 CloudFront 이벤트(뷰어의 콘텐츠 요청 또는 오리진 서버 요청 등)에 의해 트리거됩니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#1-amazon-cloudfront%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#1-amazon-cloudfront란"
  },"454": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "2. Lambda@Edge와 Amazon Cognito",
    "content": "Lambda@Edge는 다음 지점에서 CloudFront 요청 및 응답을 변경하는 데 사용할 수 있습니다: . CloudFront가 뷰어의 요청을 받은 후 (Viewer Request) CloudFront가 오리진으로 요청을 전달하기 전 (Origin Request) CloudFront가 오리진으로부터 응답을 받은 후 (Origin Response) CloudFront가 응답을 뷰어에게 전달하기 전 (Viewer Response) 샘플 애플리케이션은 JSON Web Tokens(JWT)를 사용하여 비공개 콘텐츠에 대한 접근을 인증합니다. JWT는 JSON 기반의 표준으로, 콘텐츠의 진위성과 무결성을 확인할 수 있는 액세스 토큰을 생성합니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#2-lambdaedge%EC%99%80-amazon-cognito",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#2-lambdaedge와-amazon-cognito"
  },"455": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "3. Lambda@Edge를 이용한 인증의 이점",
    "content": ". | 향상된 성능: 뷰어와 가까운 Lambda@Edge에서 인증 기능을 실행하여 지연 시간과 응답 시간을 줄입니다. | 오리진 서버의 부하 감소: JWT 서명 검증과 같은 CPU 집약적인 작업을 오프로드하여 오리진 서버의 부하를 줄입니다. | 보안 강화: 오리진 인프라에 도달하기 전에 인증되지 않은 요청을 필터링할 수 있습니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#3-lambdaedge%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%A6%9D%EC%9D%98-%EC%9D%B4%EC%A0%90",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#3-lambdaedge를-이용한-인증의-이점"
  },"456": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "4. 솔루션 개요",
    "content": "이 블로그 포스트에서는 Lambda@Edge를 사용하여 뷰어 요청을 인증하는 방법을 샘플 애플리케이션을 통해 설명합니다. 이 솔루션은 Amazon Cognito와 Amazon S3도 사용합니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#4-%EC%86%94%EB%A3%A8%EC%85%98-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#4-솔루션-개요"
  },"457": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "5. 솔루션 흐름",
    "content": ". | 로그인 시도: 사용자의 웹 브라우저가 Amazon Cognito 사용자 지정 UI 페이지로 리디렉션되어 로그인 및 인증을 시도합니다. | 인증 및 검증: 인증 후 Cognito는 JWT를 생성하고 서명한 후 JWT를 URL에 포함시켜 리디렉션 응답을 보냅니다. | 접근 요청: 웹 브라우저는 JWT를 추출하여 비공개 콘텐츠에 대한 요청을 생성하고, Authorization 헤더에 JWT를 포함시켜 요청을 보냅니다. | Lambda@Edge 요청 처리: CloudFront는 요청을 가장 가까운 엣지 로케이션으로 라우팅하며, Viewer Request 이벤트에서 Lambda@Edge 함수를 실행합니다. | JWT 검증: Lambda@Edge 함수는 JWT를 디코딩하고, 사용자 자격을 확인하며, 서명을 검증합니다. | 오리진 접근: 검증이 완료되면 Lambda@Edge 함수는 Authorization 헤더를 제거하고 요청을 오리진으로 전달합니다. 이 예시에서는 비공개 Amazon S3 버킷이 오리진으로 사용됩니다. | 데이터 흐름 설명 이 솔루션은 Amazon CloudFront를 사용하여 지연 시간을 줄이고 성능을 가속화합니다. | 정적 콘텐츠는 Amazon S3에 저장되며, 비공개 데이터는 비공개 S3 버킷에 JSON 형식으로 저장됩니다. | Lambda@Edge는 요청에 포함된 JWT를 검증하여 유효한 요청만 오리진으로 전달합니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#5-%EC%86%94%EB%A3%A8%EC%85%98-%ED%9D%90%EB%A6%84",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#5-솔루션-흐름"
  },"458": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "6. 요청 차단 테스트",
    "content": ". | 접근 차단 확인: 인증되지 않은 상태에서 비공개 데이터를 요청하면 Lambda@Edge가 접근을 차단합니다. | JWT 획득: Amazon Cognito에서 사용자로 등록하고 인증을 받아 JWT를 획득합니다. | 비공개 데이터 요청: JWT를 포함한 요청을 통해 비공개 데이터에 접근합니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#6-%EC%9A%94%EC%B2%AD-%EC%B0%A8%EB%8B%A8-%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#6-요청-차단-테스트"
  },"459": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "7. 배포 방법",
    "content": ". | 스택 생성: CloudFormation 스택을 사용하여 솔루션을 배포합니다. | Lambda@Edge 함수 게시: Lambda 함수를 게시하여 CloudFront 배포와 연결합니다. | CloudFront 배포 구성: Lambda 함수를 Viewer Request 이벤트에 연결합니다. | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#7-%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#7-배포-방법"
  },"460": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "8. 테스트 방법",
    "content": ". | 애플리케이션 위치 찾기: CloudFormation 스택의 MAINURL로 이동하여 웹 애플리케이션에 접근합니다. | 접근 차단 확인: 인증되지 않은 상태에서 접근을 시도해 차단 여부를 확인합니다. | JWT 획득 및 데이터 요청: Amazon Cognito를 통해 인증하고 JWT를 획득하여 비공개 데이터를 요청합니다. 결론 | . 이 블로그 포스트에서는 Lambda@Edge와 JSON Web Tokens을 사용하여 Amazon CloudFront 배포에서 뷰어 요청을 인증하는 방법을 설명했습니다. 이 솔루션을 통해 웹 애플리케이션의 성능과 보안을 모두 강화할 수 있습니다. 자세한 내용은 GitHub에서 소스 코드를 확인할 수 있습니다. 이 솔루션에 대한 질문이나 문제는 CloudFront 포럼, Cognito 포럼 또는 AWS 지원팀에 문의하십시오. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#8-테스트-방법"
  },"461": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "9. Cache Behavior란?",
    "content": "요청을 처리하는 방법을 정의하는 구성 요소 / 어떤 캐시 동작에 Lambda 함수를 연결하지를 결정하는 옵션 . 만약 * 기본값으로 설정하면 모든 경로에 대해 동일한 캐시 동작을 적용합니다. /images 다음과 같이 특정 경로 패턴에 대해 캐시 동작을 정의할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#9-cache-behavior%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#9-cache-behavior란"
  },"462": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "10. CloudFront Functions vs Lambda@Edge",
    "content": "CloudFront Function : 웹 요청에 대한 가벼운 계산 작업을 수행하는데 이상적입니다. JavaScript 런타임을 지원하며 HTTP 헤더 조작, URL 리디렉션, 캐시 키 조작, 액세스 인증등을 수행할 수 있습니다. ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#10-cloudfront-functions-vs-lambdaedge",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#10-cloudfront-functions-vs-lambdaedge"
  },"463": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "CloudFront Functions와 Lambda@Edge 비교",
    "content": "| 특징 | CloudFront Functions | Lambda@Edge | . | 프로그래밍 언어 | JavaScript (ECMAScript 5.1 호환) | Node.js 및 Python | . | 이벤트 소스 | Viewer request, Viewer response | Viewer request, Viewer response, Origin request, Origin response | . | Amazon CloudFront KeyValueStore 지원 | 예 (JavaScript 런타임 2.0에서만) | 아니요 | . | 확장성 | 초당 10,000,000 요청 이상 처리 가능 | 리전당 초당 최대 10,000 요청 | . | 함수 지속 시간 | 서브밀리초 | 최대 5초 (Viewer request 및 Viewer response), 최대 30초 (Origin request 및 Origin response) | . | 최대 메모리 | 2MB | 128MB – 10,240MB (10GB) | . | 함수 코드 및 라이브러리 최대 크기 | 10KB | 1MB (Viewer request 및 Viewer response), 50MB (Origin request 및 Origin response) | . | 네트워크 액세스 | 아니요 | 예 | . | 파일 시스템 액세스 | 아니요 | 예 | . | 요청 본문 액세스 | 아니요 | 예 | . | 지리적 위치 및 장치 데이터 액세스 | 예 | 아니요 (Viewer request 및 Viewer response), 예 (Origin request 및 Origin response) | . | CloudFront 내에서 완전한 빌드 및 테스트 가능 여부 | 예 | 아니요 | . | 함수 로깅 및 지표 | 예 | 예 | . | 가격 | 무료 티어 제공; 요청당 요금 부과 | 무료 티어 없음; 요청 및 함수 지속 시간에 따라 요금 부과 | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#cloudfront-functions%EC%99%80-lambdaedge-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#cloudfront-functions와-lambdaedge-비교"
  },"464": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "사용 사례",
    "content": "CloudFront Functions의 적합한 사용 사례 . | 캐시 키 정규화: HTTP 요청 속성(헤더, 쿼리 문자열, 쿠키, URL 경로)을 변환하여 최적의 캐시 키를 생성하고 캐시 적중률을 개선합니다. | 헤더 조작: 요청 또는 응답에서 HTTP 헤더를 삽입, 수정 또는 삭제합니다. | URL 리디렉션 또는 다시 쓰기: 요청 정보를 기반으로 사용자를 다른 페이지로 리디렉션하거나 경로를 변경합니다. | 요청 권한 부여: JWT와 같은 해시된 권한 부여 토큰을 검증하여 요청을 인증합니다. | . CloudFront Functions 시작하기 . Lambda@Edge의 적합한 사용 사례 . | 수 밀리초 이상의 실행 시간이 필요한 함수 | 조정 가능한 CPU 또는 메모리가 필요한 함수 | 타사 라이브러리(AWS SDK 포함)에 의존하는 함수 | 외부 서비스 처리를 위해 네트워크 액세스가 필요한 함수 | 파일 시스템 액세스 또는 HTTP 요청 본문에 액세스가 필요한 함수 | . Lambda@Edge 시작하기 . 확장성 부분 재 정리 . CloudFront Functions는 Edge보다 훨신 높은 초당 트래픽 처리가 가능합니다. 초당 천만 / Edge 리전당 초당 만 . CloudFront Function은 주로 짧고 가벼운 작업에 최적화 되었습니다. Edge는 더 복잡하고 시간이 오래 걸리는 작업을 처리할 수 있지만 초당 트래픽 처리가 제한됩니다. 함수 지속 시간 . 이벤트에 응답하여 코드를 실행할 때 걸리는 시간에 대한 차이를 설명 . 함수가 실행되는 시간이 밀리초 단위로 매우 빠르다 . Lambda@Edge - viewer request 5ch // 상대적으로 긴 실행시간을 허용합니다. 최대 메모리 . 메모리 할당 제한 설명 / 각 function이 얼마나 많은 메모리를 사용할 수 있는지에 대한 차이점 . CloudFront는 2MB만 사용 가능 . Lambda@Edge는 128 ~ 10240 사용 가능 . cloudfront 내에서 완전한 빌드 및 테스트 가능 . CloudEdge 함수 코드 및 라이브러리 최대 크기: -&gt; RS256 방식까진 가능 1MB (Viewer request 및 Viewer response) . 네트워크 액세스 CloudFront Functions: 네트워크 액세스를 지원하지 않습니다. 의미: CloudFront Functions는 외부 네트워크에 접근할 수 없으므로, 외부 API 호출이나 데이터베이스 연결이 필요한 작업에 적합하지 않습니다. Lambda@Edge: 네트워크 액세스를 지원합니다. 의미: Lambda@Edge는 외부 네트워크에 접근할 수 있어 외부 API 호출이나 데이터베이스 연결을 수행할 수 있습니다. 파일 시스템 액세스 CloudFront Functions: 파일 시스템 액세스를 지원하지 않습니다. 의미: CloudFront Functions는 로컬 파일 시스템에 접근하거나 파일을 읽고 쓸 수 없습니다. Lambda@Edge: 파일 시스템 액세스를 지원합니다. 의미: Lambda@Edge는 로컬 파일 시스템에 접근할 수 있어 파일 읽기/쓰기 작업을 수행할 수 있습니다. 요청 본문 액세스 CloudFront Functions: 요청 본문에 접근할 수 없습니다. 의미: CloudFront Functions는 HTTP 요청의 본문 데이터를 읽을 수 없으므로, 본문 데이터를 기반으로 하는 작업에 적합하지 않습니다. Lambda@Edge: 요청 본문에 접근할 수 있습니다. 의미: Lambda@Edge는 HTTP 요청의 본문 데이터를 읽을 수 있어, 본문 데이터를 처리하는 작업에 적합합니다. 지리적 위치 및 장치 데이터 액세스 CloudFront Functions: 지리적 위치 및 장치 데이터에 접근할 수 있습니다. 의미: CloudFront Functions는 사용자 위치나 장치 정보를 기반으로 작업을 수행할 수 있습니다. Lambda@Edge: 지리적 위치 및 장치 데이터 접근 여부가 이벤트 유형에 따라 다릅니다. Viewer request 및 Viewer response: 지리적 위치 및 장치 데이터에 접근할 수 없습니다. Origin request 및 Origin response: 지리적 위치 및 장치 데이터에 접근할 수 있습니다. CloudFront 내에서 완전한 빌드 및 테스트 가능 여부 CloudFront Functions: CloudFront 내에서 완전한 빌드 및 테스트가 가능합니다. 의미: CloudFront Functions는 CloudFront 콘솔 내에서 직접 빌드하고 테스트할 수 있습니다. Lambda@Edge: CloudFront 내에서 완전한 빌드 및 테스트가 불가능합니다. 의미: Lambda@Edge는 AWS Lambda 콘솔에서 빌드하고 테스트해야 하며, CloudFront 콘솔 내에서는 테스트할 수 없습니다. 함수 로깅 및 지표 CloudFront Functions: 함수 로깅 및 지표를 지원합니다. 의미: CloudFront Functions는 실행 로그와 성능 지표를 제공하여 함수의 동작을 모니터링할 수 있습니다. Lambda@Edge: 함수 로깅 및 지표를 지원합니다. 의미: Lambda@Edge도 실행 로그와 성능 지표를 제공하여 함수의 동작을 모니터링할 수 있습니다. 가격 CloudFront Functions: 무료 티어 제공; 요청당 요금 부과 의미: CloudFront Functions는 무료 티어가 있으며, 요청 수에 따라 요금이 부과됩니다. Lambda@Edge: 무료 티어 없음; 요청 및 함수 지속 시간에 따라 요금 부과 의미: Lambda@Edge는 무료 티어가 없으며, 요청 수와 함수 실행 시간에 따라 요금이 부과됩니다. 이 비교를 통해 CloudFront Functions와 Lambda@Edge의 기능 차이를 이해하고, 특정 사용 사례에 적합한 도구를 선택할 수 있습니다. 가격 비교 . Lambda@Edge 보다 지연시간이 짧다 비용이 6/1 정도 . 가장 큰 차이점은 execution time, 네트워크 액세스 유무, 가격 . body 내용 접근이 불가 . 가격 (Request 요금 / 백만 개 당) : 0.1 USD / 0.6 USD . 작업 내용 정리 . | API Gateway . | HTTP API 구축 완료: HTTP API 구축완료 및 API 라우팅 경로 생성 방법 전달 완료. | CloudWatch 로그 수집 구축 완료: API Gateway의 로그가 CloudWatch로 수집되도록 설정 완료. API 호출 및 응답에 대한 모니터링 가능 | 인증 절차 구현 완료: Header에 포함된 Jwt 토큰을 통한 인증처리가 구현되었습니다. RS256 알고리즘 방식을 적용했으며, 현재 임시 토큰을 사용하고 있습니다. | API 호출 설정: POST https://$API_GATEWAY_DOMAIN/$ENV/tls 로 구성하였습니다. | . | Lambda . | SAM을 통한 배포 프로세스 구축: AWS SAM(Serverless Application Model)을 사용한 람다 배포 프로세스가 구축되었으며, 사용법도 함께 전달하였습니다. | SAMPLE 코드 업로드: JWT Authorization 및 Redis Search Lambda 함수 코드가 AWS CodeCommit을 통해 업로드되었습니다. | Lambda 코드 배포 예정: HAE 에서 실제 배포할 람다함수 소스를 업로드 예정 | . | GitLab . | 자격증명 설정: AWS S3에 접근하기 위한 GitLab AWS 자격증명 설정 방법 전달 완료. | 산출물 업로드 방법 가이드: GitLab에서 빌드 완료된 산출물을 지정된 S3 버킷에 업로드 하는 법 가이드 완료 | . | . 남은일 . | api gateway와 custom domain 연결 | Lambda source 업로드 후 opensearch 테스트 진행 | 실제 token을 이용한 jwt 인증 람다 테스트 | 배포 파이프라인 구축 필요 | . ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge#%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge#사용-사례"
  },"465": {
    "doc": "1. Lambda@Edge 와 JWT Web Tokens",
    "title": "1. Lambda@Edge 와 JWT Web Tokens",
    "content": " ",
    "url": "/docs/02_Tech/AWS/Lambda@Edge",
    
    "relUrl": "/docs/02_Tech/AWS/Lambda@Edge"
  },"466": {
    "doc": "Languages",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/01_Languages#color-utilities",
    
    "relUrl": "/docs/01_Languages#color-utilities"
  },"467": {
    "doc": "Languages",
    "title": "Table of contents",
    "content": ". | TOC | . ",
    "url": "/docs/01_Languages#table-of-contents",
    
    "relUrl": "/docs/01_Languages#table-of-contents"
  },"468": {
    "doc": "Languages",
    "title": "Languages",
    "content": " ",
    "url": "/docs/01_Languages",
    
    "relUrl": "/docs/01_Languages"
  },"469": {
    "doc": "Next.js",
    "title": "Learn Next.js",
    "content": "Next.js는 React 기반의 프레임워크로, 서버 사이드 렌더링, 스태틱 사이트 생성, 그리고 웹 애플리케이션 최적화를 위한 다양한 기능을 제공합니다. 이 글에서는 Next.js를 이용해 간단한 금융 대시보드 페이지를 만드는 과정을 설명합니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#learn-nextjs",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#learn-nextjs"
  },"470": {
    "doc": "Next.js",
    "title": "목차",
    "content": ". | 글 요약 | 시작하기 전 | 1. 프로젝트 생성하기 . | 1.1 프로젝트 내용 이해하기 | . | 2. 개발 프로젝스 실행하기 | 3. CSS 스타일링 방법 . | 3.1 글로벌 스타일 | 3.2 글로벌 스타일 적용 | 3.2.1 /app/layout.tsx 상세 설명 | 3.3 글로벌 스타일 결과 확인 | 3.4 Tailwind CSS | . | 4. 사용자 정의 폰트와 이미지 추가하기 . | 4.1 사용자 정의 폰트 추가 방법 . | 4.1.1 사용자 정의 폰트 글로벌 적용 | 4.1.2 코드 상세 설명 | 4.1.3 브라우저에서 확인 | . | 4.2 이미지 추가와 최적화 . | 4.2.1 page.tsx 구성하기 | 4.2.2 코드 상세설명 | 4.2.3 브라우저 확인 | . | . | 5. 페이지와 레이아웃 만들기 . | 5.1 page.tsx | 5.1.1 대시보드 페이지 생성 . | 5.1.3 중첩 라우트 생성 방법 | 5.2 layout.tsx | 5.2.1 대시보드 레이아웃 구성하기 | 5.2.2 대시보드 레이아웃 코드 상세설명 | 5.2.3 루트 레이아웃과 대시보드 레이아웃의 차이 | . | 5.3 dashbaord 페이지 브라우저 확인 | . | 6 페이지 전환 . | 6.1 | 컴포넌트 사용하기 . | 6.1.1 | 컴포넌트 적용하기 | 6.1.2 코드 상세 설명 | 6.1.3 페이지 전환 브라우저 확인 | 6.1.4 자동 코드 분할 및 프리패칭 . | 6.1.4.1 자동 코드 분할 | 6.1.4.2 프리패칭 | . | . | 6.2 usePathname() 훅 사용하여 사용자 위치를 시각적으로 나타내기 . | 6.2.1 usePathname() 훅 | 6.2.2 NavLink 컴포넌트를 클라이언트 컴포넌트로 만들기 | 6.2.3 현재 경로 확인 및 활성 링크 스타일 적용하기 | 6.2.4 브라우저에서 확인하기 | . | . | 7. 데이터베이스 . | 7.1 github repository 만들기 | 7.2 Vercel Account 만들기 | 7.3 PostgreSQL 데이터베이스 설정하기 with Vercel | 7.4 데이터 베이스 연결정보 확인 | 7.5 데이터 베이스 seeding | . | 8 데이터베이스 데이터를 이용하여 대시보드 구성하기 . | 8.1 서버 컴포넌트를 사용하여 데이터를 가져오기 | 8.2 dashboard/page.tsx 코드 상세 내용 | 8.3 Fetching data for | 8.4 Fetching data for | 8.5 Fetch data for the components | 8.6 데이터 관리법 . | 8.6.1 Request Waterfalls | 8.6.3 Parallel data fetching | . | . | 9. 정적 및 동적 대시보드 구현하기 . | 9.1 정적 렌더링 | 9.2 동적 렌더링 | 9.3 대시보드 동적으로 만들기 | 9.4 지연되는 데이터 페칭 대응하기 . | 9.4.1 스트리밍 | 9.4.2 실제 구현 | 9.4.3 route group | 9.4.4 를 사용해 특정 컴포넌트 스트리밍 하기 | . | . | . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#목차"
  },"471": {
    "doc": "Next.js",
    "title": "글 요약",
    "content": "제작할 웹 어플리케이션은 다음과 같은 기능을 가지고 있습니다. 공개 홈페이지: 모든 사용자가 접근할 수 있는 홈 페이지입니다. 로그인 페이지: 사용자 인증을 위한 로그인 페이지입니다. 인증에 의해 보호되는 대시보드 페이지: 인증된 사용자만 접근할 수 있는 대시보드 페이지들입니다. CRUD: 사용자가 금융 정보를 관리할 수 있는 기능입니다. 데이터베이스: 애플리케이션의 데이터를 관리하는 데이터베이스 설정입니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#글-요약"
  },"472": {
    "doc": "Next.js",
    "title": "시작하기 전",
    "content": "이 과정은 React 및 JavaScript에 대한 기본적인 이해를 가정합니다. 참고자료 : Learn Next.js . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#시작하기-전"
  },"473": {
    "doc": "Next.js",
    "title": "1. 프로젝트 생성하기",
    "content": "sample next.js application 만들기 . npx create-next-app@latest nextjs-dashboard --use-npm --example \"https://github.com/vercel/next-learn/tree/main/dashboard/starter-example\" . 1.1 프로젝트 내용 이해하기 . 폴더 구조 . | /app: 애플리케이션의 라우트, 컴포넌트, 로직을 포함하며, 주로 작업할 폴더입니다. | /app/lib: 재사용 가능한 유틸리티 함수와 데이터 페칭 함수 등, 애플리케이션에서 사용되는 함수들 입니다. | /app/ui: 카드, 테이블, 폼 등 애플리케이션의 UI 컴포넌트를 담고있는 디렉토리 입니다. | /public: 이미지와 같은 애플리케이션의 정적 페이지를 구성할 리소스 입니다. | /scripts: 데이터베이스 관련 디렉토리입니다. | 설정 파일: next.config.js에 nextjs 설정파일을 구성할 수 있습니다. | . 플레이스홀더 데이터 . 데이터베이스나 API를 아직 사용하지 않다면 플레이스홀더 데이터를 이용해 미리 데이터를 구성할 수 있습니다. 이 프로젝트에서는 app/lib/placeholder-data.js에 플레이스홀더 데이터를 구성했습니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#1-프로젝트-생성하기"
  },"474": {
    "doc": "Next.js",
    "title": "2. 개발 프로젝스 실행하기",
    "content": "프로젝트는 typescript로 작성되었습니다. 프로젝트의 패키지를 설치하고 시작합니다. npm i npm run dev . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#2-%EA%B0%9C%EB%B0%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%EC%8A%A4-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#2-개발-프로젝스-실행하기"
  },"475": {
    "doc": "Next.js",
    "title": "3. CSS 스타일링 방법",
    "content": "3.1 글로벌 스타일 . 프로젝트 내에 있는 /app/ui/global.css을 사용하여 애플리케이션 전체에 공통적으로 적용되는 CSS 규칙을 정의할 수 있습니다. 3.2 글로벌 스타일 적용 . 어플리케이션 최상위 컴포넌트에 적용해야 합니다. next.js에서는 루트 레이아웃이라고 부릅니다. /app/layout.tsx에 해당 global.css를 임포트 해오는 과정을 아래와 같이 추가합니다. 이렇게 적용하면 애플리케이션의 모든 컴포넌트와 페이지에 적용되게 됩니다. import '@/app/ui/global.css'; import React from \"react\"; export default function RootLayout({ children, }: { children: React.ReactNode; }) { return ( &lt;html lang=\"en\"&gt; &lt;body&gt;{children}&lt;/body&gt; &lt;/html&gt; ); } . 3.2.1 /app/layout.tsx 상세 설명 . 루트레이아웃은 애플리케이션의 최상위 구조를 설정하며, 모든 페이지와 컴포넌트는 이 레이아웃 내에서 렌더링됩니다. RootLayout 함수 컴포넌트 정의 . | props : { children }: { children: React.ReactNode; } . | children의 타입을 정의해주었습니다. // React.ReactNode는 렌더링 될 수 있는 거의 모든 종류의 React 노드 ( 텍스트, HTML , 다른 컴포넌트 )를 포함할 수 있는 타입 | . | return : &lt;html&gt; 요소를 반환하며, 내부 &lt;body&gt; 태그 내에는 children이 렌더링 되는데, 앞서 RootLayout을 사용하여 래핑된 모든 자식 컴포넌트를 의미합니다. | . 3.3 글로벌 스타일 결과 확인 . 앞서 local에 생성한 주소에서 글로벌 스타일이 적용되었는지 확인해봅니다. 3.4 Tailwind CSS . Tailwind CSS는 유틸리티 클래스를 직접 TSX 마크업에 빠르게 작성할 수 있도록 해주는 CSS 프레임워크입니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#3-css-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#3-css-스타일링-방법"
  },"476": {
    "doc": "Next.js",
    "title": "4. 사용자 정의 폰트와 이미지 추가하기",
    "content": "Next.js는 next/font 모듈을 사용하여 폰트를 자동으로 최적화합니다. 4.1 사용자 정의 폰트 추가 방법 . | /app/ui 폴더에 fonts.ts 파일을 생성합니다. | 아래와 같이 코드를 구성합니다. subsets 은 폰트 모듈에서 제공하는 폰트 스타일 입니다. | . import { Inter } from 'next/font/google'; export const inter = Inter({ subsets: ['latin'] }); . 4.1.1 사용자 정의 폰트 글로벌 적용 . | /app/layout.tsx 파일에서 이 폰트를 &lt;body&gt; 요소에 추가합니다. | . import '@/app/ui/global.css'; import { inter } from '@/app/ui/fonts'; export default function RootLayout({ children, }: { children: React.ReactNode; }) { return ( &lt;html lang=\"en\"&gt; &lt;body className={`${inter.className} antialiased`}&gt;{children}&lt;/body&gt; &lt;/html&gt; ); } . 4.1.2 코드 상세 설명 . | ${inter.className} : Inter 폰트를 적용하기 위한 ‘next/font’ 모듈이 제공하는 클래스 이름을 동적으로 할당합니다. | antialiased : 폰트의 가장자리를 부드럽게 처리해주는 클래스입니다. | . 4.1.3 브라우저에서 확인 . 4.2 이미지 추가와 최적화 . 페이지에 구체적인 이미지를 추가해야할 경우가 있습니다. 각 페이지는 다를 수 있기 때문에 구체적인 각각의 구성요소는 해당 페이지의 컴포넌트 파일에서 직접관리합니다. 따라서 최초 홈 페이지를 정의하고 있는 /app/page.tsx 파일에서 이미지를 추가하는 과정이 필요합니다. 4.2.1 page.tsx 구성하기 . | next/image 컴포넌트 임포트: next/image 컴포넌트를 사용하면 이미지를 자동으로 최적화하고, 뷰포트에 맞게 크기를 조정할 수 있습니다. | . import Image from 'next/image'; . | 이미지 추가: 특정 클래스를 사용하여 app/page.tsx 파일에 데스크탑 화면에서만 표시되도록 추가 | . import AcmeLogo from '@/app/ui/acme-logo'; import { ArrowRightIcon } from '@heroicons/react/24/outline'; import Link from 'next/link'; import { lusitana } from '@/app/ui/fonts'; import Image from 'next/image'; export default function Page() { return ( // ... &lt;div className=\"flex items-center justify-center p-6 md:w-3/5 md:px-28 md:py-12\"&gt; {/* Add Hero Images Here */} &lt;Image src=\"/hero-desktop.png\" width={1000} height={760} className=\"hidden md:block\" alt=\"Screenshots of the dashboard project showing desktop version\" /&gt; &lt;/div&gt; //... ); } . 4.2.2 코드 상세설명 . | src : /public 내 위치한 이미지를 참조합니다. | className=”hidden md:block” : Tailwind CSS 사용하여 데스크탑 화면에서만 이미지가 표시되도록 하고(md:block) 모바일 화면에서는 숨깁니다.(hidden) | . 4.2.3 브라우저 확인 . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#4-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%ED%8F%B0%ED%8A%B8%EC%99%80-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#4-사용자-정의-폰트와-이미지-추가하기"
  },"477": {
    "doc": "Next.js",
    "title": "5. 페이지와 레이아웃 만들기",
    "content": "next.js의 layout.tsx는 공통 스타일 적용 외에도 특정 페이지 그룹간에 공통된 UI를 공유하는 목적으로 사용될 수 있습니다. 5.1 page.tsx . | page.tsx 파일: 특정 경로에 대한 UI를 렌더링하는 React 컴포넌트를 자동으로 구성할 수 있게 해주는 파일입니다. 예를 들어, /app/page.tsx는 애플리케이션의 홈 페이지(/)에 해당하는 컴포넌트를 정의합니다. 이 파일을 페이지 렌러링을 위한 필수 파일입니다. | . 5.1.1 대시보드 페이지 생성 . 공통적으로 사용되는 사이드 네비게이션 같은 구성요소를 만들 수 있습니다. Next.js에서는 파일 시스템 기반 라우팅을 사용하여 애플리케이션의 페이지와 경로를 구성합니다. 이 방식은 디렉토리와 파일구조를 통해 자동으로 라우트를 생성하고 관리할 수 있게 해주며, 개발자가 명시적으로 라우팅 로직을 작성할 필요를 줄여줍니다. 5.1.3 중첩 라우트 생성 방법 . 단순히 디렉토리를 중첩하여 구성하고 각 디렉토리 안에 page.tsx 파일을 추가하면 됩니다. /app /ui /dashboard page.tsx . /app/ui/dashboard/page.tsx파일은 /dashboard 라우트와 연결되며, 해당 경로는 http://localhost:3000/ui/dashboard 가 됩니다. 파일 시스템 기반 라우팅은 URL 경로와 애플리케이션의 파일 구조가 일치하도록 함으로써, 명확한 프로젝트 구조를 유지할 수 있도록 합니다. 5.2 layout.tsx . | layout.tsx 파일: 특정 섹션 또는 페이지 그룹에 공통적으로 적용되는 레이아웃을 정의하는데 사용됩니다. 예를 들어, header 혹은 navigation-bar 와 같은 반복되는 UI를 재사용하기 위해 사용됩니다. | . 5.2.1 대시보드 레이아웃 구성하기 . 대시보드 관련 페이지들에 공통적으로 적용되는 UI를 가진 /app/ui/dashboard/layout.tsx를 만들 수 있습니다. import SideNav from '@/app/ui/dashboard/sidenav'; export default function Layout({ children }: { children: React.ReactNode }) { return ( &lt;div className=\"flex h-screen flex-col md:flex-row md:overflow-hidden\"&gt; &lt;div className=\"w-full flex-none md:w-64\"&gt; &lt;SideNav /&gt; &lt;/div&gt; &lt;div className=\"flex-grow p-6 md:overflow-y-auto md:p-12\"&gt;{children}&lt;/div&gt; &lt;/div&gt; ); } . 5.2.2 대시보드 레이아웃 코드 상세설명 . | { children }: { children: React.ReactNode }: Layout 함수 컴포넌트는 React.ReactNode를 통해 내부 컨텐츠가 무엇인지 알 필요 없이, 다양한 상황에서 해당 레이아웃에 사용될 컨텐츠를 렌더링 할 수 있습니다. | . 5.2.3 루트 레이아웃과 대시보드 레이아웃의 차이 . 루트 레이아웃은 전체 애플리케이션에 공통적인 기본 구조와 스타일을 제공하는 반면, 대시보드와 같은 특정 섹션에 대한 레이아웃은 그 섹션의 고유한 요구 사항에 맞춰 추가적인 UI 구성 요소나 스타일을 제공합니다. 5.3 dashbaord 페이지 브라우저 확인 . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#5-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%99%80-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#5-페이지와-레이아웃-만들기"
  },"478": {
    "doc": "Next.js",
    "title": "6 페이지 전환",
    "content": "대시보드를 만들었으니, 대시보드 경로 간에 탐색할 수 있게 하는 링크를 추가할 수 있습니다. Next.js는 | 컴포넌트 및 usePathname hook을 통해 이를 구현할 수 있습니다. 6.1 | 컴포넌트 사용하기 . 기존 페이지간 전환을 위해 HTML에서 &lt;a&gt; 태그를 사용했습니다. 하지만 Next.js에서는 &lt;Link /&gt; 컴포넌트를 사용하여 애플리케이션 내의 페이지들 사이에서 탐색을 할 수 있게 합니다. 6.1.1 | 컴포넌트 적용하기 . /app/ui/dashboard/nav-links.tsx 에서 Link component를 import 한 후 아래와 같이 기존 &lt;a&gt; 태그 대신 &lt;Link&gt; 태그로 변경합니다. import { UserGroupIcon, HomeIcon, DocumentDuplicateIcon, } from '@heroicons/react/24/outline'; import Link from 'next/link'; // Map of links to display in the side navigation. // Depending on the size of the application, this would be stored in a database. const links = [ { name: 'Home', href: 'dashboard', icon: HomeIcon }, { name: 'Invoices', href: 'invoices', icon: DocumentDuplicateIcon, }, { name: 'Customers', href: 'customers', icon: UserGroupIcon }, ]; export default function NavLinks() { return ( &lt;&gt; {links.map((link) =&gt; { const LinkIcon = link.icon; return ( &lt;Link key={link.name} href={link.href} className=\"flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3\" &gt; &lt;LinkIcon className=\"w-6\" /&gt; &lt;p className=\"hidden md:block\"&gt;{link.name}&lt;/p&gt; &lt;/Link&gt; ); })} &lt;/&gt; ); } . 6.1.2 코드 상세 설명 . | 사이드 네비게이션에 표시할 링크들을 정의합니다. | name - 링크의 표시 이름 | href - 탐색할 경로 | icon은 링크 옆에 표시될 아이콘 | . | . const links = [ { name: 'Home', href: 'dashboard', icon: HomeIcon }, { name: 'Invoices', href: 'invoices', icon: DocumentDuplicateIcon, }, { name: 'Customers', href: 'customers', icon: UserGroupIcon }, ]; . | links 배열을 순회하며, 각 링크에 대한 | 컴포넌트를 렌더링합니다. | . {links.map((link) =&gt; { const LinkIcon = link.icon; return ( &lt;Link key={link.name} href={link.href} className=\"flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3\" &gt; &lt;LinkIcon className=\"w-6\" /&gt; &lt;p className=\"hidden md:block\"&gt;{link.name}&lt;/p&gt; &lt;/Link&gt; ); } . 6.1.3 페이지 전환 브라우저 확인 . 6.1.4 자동 코드 분할 및 프리패칭 . 6.1.4.1 자동 코드 분할 . React에서는 사용자가 첯음 사이트를 방문할 때 애플리케이션의 모든 코드를 한번에 다운로드 합니다. 반면에 Next.js에서는 자동 코드 분할 기능을 사용하여 사용자가 특정 페이지를 방문할 때 그 페이지에 필요한 코드만을 로드합니다. 이는 각 코드별로 다른 번들을 가지게 되며 이는 아래와 같은 장점을 가지게 됩니다. | 빠른 초기로드 : 처음 사이트를 방문할 때 필요한 코드만 로드하기 때문에 빠르게 초기 페이지 로드가 가능합니다. | 에러 처리 : 한 페이지에서 발생한 오류가 애플리케이션 전체에 영향을 끼치지 않습니다. | . 6.1.4.2 프리패칭 . 사용자가 페이지에 방문하기 전에, 해당 페이지에 필요한 코드를 미리 로드하는 기능입니다. | 페이지 탐색 시 빠른 반응: | 컴포넌트가 사용될 때, Next.js는 자동으로 해당 링크의 타겟 페이지에 필요한 코드를 백그라운드에서 미리 로드합니다. 사용자가 링크를 클릭하면, 이미 로드된 코드 덕분에 페이지 전환이 빠르게 이루어집니다. | 사용자 경험: 이 기능 덕분에 애플리케이션은 전체 페이지를 새로고침하지 않고도 빠른 페이지 전환을 제공할 수 있습니다. | . 6.2 usePathname() 훅 사용하여 사용자 위치를 시각적으로 나타내기 . 네비게이션에서 사용자에게 현재 위치를 알려주는 UI 패턴 입니다. 현재 페이지에 해당하는 네비게이션 링크를 다른 링크들과 구별하여 표시할 수 있도록 도와주는 usePathname() 훅을 Next.js에서는 제공합니다. 6.2.1 usePathname() 훅 . usePathname() 훅은 현재 브라우저의 경로(URL)를 반환해 줍니다. 이 값을 사용해 현재 위치와 네비게이션 링크의 경로를 비교함으로써, 사용자가 현재 어느 페이지에 있는지 알 수 있습니다. 6.2.2 NavLink 컴포넌트를 클라이언트 컴포넌트로 만들기 . usePathName() 훅은 클라이언트 사이드에서만 실행됩니다. 따라서 이 훅을 사용하는 컴포넌트는 서버 사이드 렌더링과정에서는 실행되지 않고 브라우저에서만 실행됩니다. dashboard/nav-links.tsx . 'use client'; import { UserGroupIcon, HomeIcon, InboxIcon, } from '@heroicons/react/24/outline'; import Link from 'next/link'; import { usePathname } from 'next/navigation'; // ... 6.2.3 현재 경로 확인 및 활성 링크 스타일 적용하기 . pathname 변수에 현재 경로 할당하기 . export default function NavLinks() { const pathname = usePathname(); // ... } . 스타일 적용하기 . 'use client'; import { UserGroupIcon, HomeIcon, DocumentDuplicateIcon, } from '@heroicons/react/24/outline'; import Link from 'next/link'; import { usePathname } from 'next/navigation'; import clsx from 'clsx'; // ... export default function NavLinks() { const pathname = usePathname(); return ( &lt;&gt; {links.map((link) =&gt; { const LinkIcon = link.icon; return ( &lt;Link key={link.name} href={link.href} className={clsx( 'flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3', { 'bg-sky-100 text-blue-600': pathname === link.href, }, )} &gt; &lt;LinkIcon className=\"w-6\" /&gt; &lt;p className=\"hidden md:block\"&gt;{link.name}&lt;/p&gt; &lt;/Link&gt; ); })} &lt;/&gt; ); } . 6.2.4 브라우저에서 확인하기 . 이제 경로를 변경하면 왼쪽 네비게이션 패널에 파란색으로 현재 경로의 패널에 시각적으로 표시가 됩니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#6-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%A0%84%ED%99%98",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#6-페이지-전환"
  },"479": {
    "doc": "Next.js",
    "title": "7. 데이터베이스",
    "content": "Next.js 대시보드 를 구성하는데 사용될 PostgreSQL을 설정합니다. 7.1 github repository 만들기 . 현재까지 구성한 내용을 git repository에 push 합니다. 7.2 Vercel Account 만들기 . vercel . 앞서 생성한 레포지토리와 연결해줍니다. 그 후 deploy를 클릭합니다. 배포된 프로젝트를 확인합니다. 7.3 PostgreSQL 데이터베이스 설정하기 with Vercel . | Vercel 프로젝트 대시보드에서 Storage 탭을 선택합니다. | 사용가능한 저장 옵션 중에서 Postgres를 선택하고 데이터베이스를 생성합니다. | 생성 단계 중 지역을 선택하는 부분에서 살고있는 지역과 가장 가까운 곳으로 선택합니다. 본 블로그에서는 Singapore sin1 을 선택하였습니다. | . 참고 문서 : 자세한 설치가이드 . 7.4 데이터 베이스 연결정보 확인 . | .env.local 탭 : 연결된 PostgreSQL 데이터베이스를 선택하여 .env.local 탭을 찾아 생성된 연결 정보를 확인합니다. | . | 소스 프로젝트에서 .env 파일을 생성한 후 앞서 생성한 데이터베이스 연결 정보를 넣어줍니다. | npm i @vercel/postgres 명령어를 실행하여 라이브러리를 설치합니다. | . 7.5 데이터 베이스 seeding . 프로젝트의 /scripts 폴더 내에 seed.js파일이 있습니다. 해당 파일을 이용하여 생성한 데이터 베이스에 초기 데이터를 넣을 수 있습니다. 다음과 같이 package.json 파일을 수정합니다. \"scripts\": { \"build\": \"next build\", \"dev\": \"next dev\", \"prettier\": \"prettier --write --ignore-unknown .\", \"prettier:check\": \"prettier --check --ignore-unknown .\", \"start\": \"next start\", \"seed\": \"node -r dotenv/config ./scripts/seed.js\" }, . 이후 npm run seed 를 실행합니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#7-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#7-데이터베이스"
  },"480": {
    "doc": "Next.js",
    "title": "8 데이터베이스 데이터를 이용하여 대시보드 구성하기",
    "content": "서버 컴포넌트를 통해 백엔드 리소스에 접근하여 데이터를 가져와 대시보드 개요 페이지를 구축할 수 있습니다. 8.1 서버 컴포넌트를 사용하여 데이터를 가져오기 . /app/dashboard/page.tsx 재 구성하기 . import { Card } from '@/app/ui/dashboard/cards'; import RevenueChart from '@/app/ui/dashboard/revenue-chart'; import LatestInvoices from '@/app/ui/dashboard/latest-invoices'; import { lusitana } from '@/app/ui/fonts'; export default async function Page() { return ( &lt;main&gt; &lt;h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}&gt; Dashboard &lt;/h1&gt; &lt;div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-4\"&gt; {/* &lt;Card title=\"Collected\" value={totalPaidInvoices} type=\"collected\" /&gt; */} {/* &lt;Card title=\"Pending\" value={totalPendingInvoices} type=\"pending\" /&gt; */} {/* &lt;Card title=\"Total Invoices\" value={numberOfInvoices} type=\"invoices\" /&gt; */} {/* &lt;Card title=\"Total Customers\" value={numberOfCustomers} type=\"customers\" /&gt; */} &lt;/div&gt; &lt;div className=\"mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8\"&gt; {/* &lt;RevenueChart revenue={revenue} /&gt; */} {/* &lt;LatestInvoices latestInvoices={latestInvoices} /&gt; */} &lt;/div&gt; &lt;/main&gt; ); } . 8.2 dashboard/page.tsx 코드 상세 내용 . | 비동기 컴포넌트를 사용한 데이터 가져오기 | . async 키워드로 함수를 선언하면 await를 사용할 수 있습니다. 이는 비동기 작업이 완료될 때까지 함수의 실행을 일시 중지 하고 완료되면 재개합니다. 서버로부터 데이터를 가져오는 과정에서 필요한 데이터가 준비될 때까지 기다린다음 해당 데이터를 페이지 컴포넌트로 전달하여 렌더링 할 수 있도록 처리합니다. // /app/dashboard/page.tsx import { fetchRevenue, fetchLatestInvoices } from '@/app/lib/data'; export default async function Page() { // 데이터 페칭 로직 } . 8.3 Fetching data for . | 데이터 페칭 함수를 import 합니다. | 컴포넌트 관련 주석을 해제하고 활성화 합니다. | 컴포넌트 파일(/app/ui/dashboard/revenue-chart.tsx) 내부의 코드도 주석 해제합니다. | . /app/dashboard/page.tsx . import { Card } from '@/app/ui/dashboard/cards'; import RevenueChart from '@/app/ui/dashboard/revenue-chart'; import LatestInvoices from '@/app/ui/dashboard/latest-invoices'; import { lusitana } from '@/app/ui/fonts'; import { fetchRevenue } from '@/app/lib/data'; export default async function Page() { const revenue = await fetchRevenue(); // ... } . | 브라우저 확인 | . 8.4 Fetching data for . | fetchLatestInvoices 호출 | dashboard/page.tsx에서 fetchLatestInvoices 와 관련된 컴포넌트 주석 해제 | (/app/ui/dashboard/latest-invoices.tsx) 내부의 관련 코드도 주석 해제 | . /app/ui/dashboard/page.tsx . import { Card } from '@/app/ui/dashboard/cards'; import RevenueChart from '@/app/ui/dashboard/revenue-chart'; import LatestInvoices from '@/app/ui/dashboard/latest-invoices'; import { lusitana } from '@/app/ui/fonts'; import { fetchRevenue, fetchLatestInvoices } from '@/app/lib/data'; export default async function Page() { const revenue = await fetchRevenue(); const latestInvoices = await fetchLatestInvoices(); // ... } . | 브라우저 확인 | . 8.5 Fetch data for the components . 브라우저에서 확인하기 . 8.6 데이터 관리법 . 8.6.1 Request Waterfalls . waterfall 방식은 이전 요청이 끝날때까지 기다리는 순차적인 방식을 의미합니다. 데이터 페칭의 경우, 각 요청은 이전 요청이 데이터를 반환할 때까지 시작할 수 없습니다. 예시 /dashboard/page.tsx . fetchReveneu()가 실행된 후에 latestInvoices()를 시작할 수 있습니다. const revenue = await fetchRevenue(); const latestInvoices = await fetchLatestInvoices(); // fetchRevenue()가 완료될 때까지 대기 const { numberOfInvoices, numberOfCustomers, totalPaidInvoices, totalPendingInvoices, } = await fetchCardData(); // fetchLatestInvoices()가 완료될 때까지 대기 . 8.6.3 Parallel data fetching . waterfalls 방식 대신 성능을 개선하기 위해 병렬 데이터 페칭을 사용하여 데이터 요청을 동시에 진행해 애플리케이션 로딩 시간을 단축할 수 있습니다. | 병렬 페칭의 원리 병렬 데이터 페칭은 Promise.all() 또는 Promise.allSettled() 함수를 사용하여 모든 프로미스를 동시에 초기화하는 방식입니다. | . 예시 /app/lib/data.js . export async function fetchCardData() { try { const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`; const customerCountPromise = sql`SELECT COUNT(*) FROM customers`; const invoiceStatusPromise = sql`SELECT SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS \"paid\", SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS \"pending\" FROM invoices`; const data = await Promise.all([ invoiceCountPromise, customerCountPromise, invoiceStatusPromise, ]); // ... } } . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8C%80%EC%8B%9C%EB%B3%B4%EB%93%9C-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#8-데이터베이스-데이터를-이용하여-대시보드-구성하기"
  },"481": {
    "doc": "Next.js",
    "title": "9. 정적 및 동적 대시보드 구현하기",
    "content": "9.1 정적 렌더링 . 정적 렌더링은 데이터 페칭과 렌더링이 서버에서 배포시에 이루어집니다. 배포된 결과는 CDN에서 배포및 캐싱될 수 있습니다. | 정적 렌더링의 장점 . | 웹사이트 속도 향상 : 사전 렌더링된 콘텐츠를 통해 사용자는 빠르고 안정적으로 웹사이트레 접근할 수 있습니다. | 서버 부하 감소 : 콘텐츠가 캐시되기 때문에 서버는 각 사용자 요청에 동적으로 콘텐츠를 생성할 필요가 없습니다. | SEO 최적화 : 사전 렌더링된 콘텐츠는 검색 엔진 크롤러가 색인을 생성하기 쉽워 검색 엔진을 향상시킬 수 있습니다. | . | . 9.2 동적 렌더링 . 동적 렌더링은 콘텐츠가 사용자가 페이지를 방문할 때마다 서버에서 렌더링 됩니다. | 동적 렌더링의 장점 . | 실시간 데이터: 동적 렌더링을 통해 애플리케이션은 실시간 또는 자주 업데이트되는 데이터를 표시할 수 있습니다. | 사용자별 콘텐츠: 개인화된 콘텐츠, 예를 들어 대시보드나 사용자 프로필을 쉽게 제공하고 사용자 상호작용에 따라 데이터를 업데이트할 수 있습니다. | 요청 시점 정보: 요청 시점에만 알 수 있는 정보(예: 쿠키 또는 URL 검색 파라미터)에 접근할 수 있습니다. | . | . 9.3 대시보드 동적으로 만들기 . next js는 unstable_noStore 라는 API를 제공하여 동적데이터를 필요로 하는 컴포넌트나 데이터 패칭 함수에서 데이터가 캐싱되지 않도록 설정할 수 있습니다. /app/lib/data.ts 에서 fetching 함수를 아래와 같이 수정할 수 있습니다. // ... import { unstable_noStore as noStore } from 'next/cache'; export async function fetchRevenue() { // Add noStore() here to prevent the response from being cached. // This is equivalent to in fetch(..., {cache: 'no-store'}). noStore(); // ... } export async function fetchLatestInvoices() { noStore(); // ... } export async function fetchCardData() { noStore(); // ... } export async function fetchFilteredInvoices( query: string, currentPage: number, ) { noStore(); // ... } export async function fetchInvoicesPages(query: string) { noStore(); // ... } export async function fetchFilteredCustomers(query: string) { noStore(); // ... } export async function fetchInvoiceById(query: string) { noStore(); // ... } . 9.4 지연되는 데이터 페칭 대응하기 . 9.4.1 스트리밍 . 스트리밍은 데이터를 서버에서 클라이언트로 준비되는 대로 전송하는 데이터 전송 기술입니다. 스트리밍을 통해, 느린 데이터 요청이 전체 페이지를 보여주지 못하는 문제를 방지할 수 있습니다. 모든 데이터가 로드되기 전에 페이지의 일부를 사용자에게 노출할 수 있게 해줍니다. 스트리밍은 컴포넌트 모델과 잘 어울립니다. 각 컴포넌트를 하나의 조각으로 간주하여 조각이 준비되는대로 전송할 수 있기 때문입니다. 스트리밍을 구현하는 방법은 두가지가 있습니다. | 페이지 수준에서 loading.tsx를 이용합니다. | loading.tsx는 페이지가 로드되는 동안 사용자에게 표시되는 임시 UI 입니다. 이 방법을 통해 데이터를 패칭하는 동안 로딩 화면을 표시할 수 있습니다. | . | 특정 컴포넌트에 &lt;Suspense&gt; 를 사용합니다. | 컴포넌트들의 로딩 상태를 처리합니다. 특정 컴포넌트가 데이터를 로드하는 동안 대체 컨텐츠를 표시할 수 있습니다. | . | . 9.4.2 실제 구현 . | loading.tsx | . /app/dashboard 내에 loading.tsx 파일을 생성합니다. 해당 파일은 Next.js의 특수한 파일로 페이지 콘텐츠가 로드되는 동안 표시할 대체 UI를 생성할 수 있게 해줍니다. export default function Loading() { return &lt;div&gt;Loading...&lt;/div&gt;; } . | 로딩 스켈레톤 | . 데이터가 로드되는 동안 콘텐츠의 레이아웃을 대략적으로 표시하는 UI 패턴입니다. 앞서 만든 loading.tsx 파일에서 &lt;DashboardSkeleton&gt; 컴포넌트를 추가해줍니다. import DashboardSkeleton from '@/app/ui/skeletons'; export default function Loading() { return &lt;DashboardSkeleton /&gt;; } . 로딩중인 모습 . 데이터 페칭이 완료된 모습 . 9.4.3 route group . | 스켈레톤 컴포넌트 버그 수정하기 | . 현재 구성된 로딩 스켈레톤은 dashboard 뿐만 아니라 invoices 와 customers 페이지에도 일괄 적용되고 있습니다. loading.tsx 가 파일시스템에서 /invoices/page.tsx와 /customers/page.tsx보다 상위 레벨에 위치하고 있기 때문입니다. route group을 통해 특정 페이지에만 적용되게 변경할 수 있습니다. /dashboard/(overview) 라는 새 폴더를 생성합니다. 이후 loading.tsx 파일과 page.tsx 파일을 넣어줍니다. 이렇게 하면 대시보드의 개요 페이지에만 적용이 되게 됩니다. | route group의 이점 | . URL 경로 구조에 영향을 주지 않고 파일을 조직할 수 있습니다. () 를 사용해 새 폴더를 생성하면 그 이름은 URL 경로에 포함되지 않습니다. 라우트 그룹을 통해 애플리케이션을 관리하기 쉬운 구조로 조직화 할 수 있습니다. 9.4.4 를 사용해 특정 컴포넌트 스트리밍 하기 . 를 사용하면 특정 조건이 충족될 때 까지 애플리케이션의 일부를 지연시킬 수 있습니다. 이를 통해 동적 컴포넌트를 Suspense로 감싼 다음, 동적 컴포넌트가 로드되는 동안 표시할 대체 컴포넌트를 전달 할 수 있습니다. 현재 fetchRevenue() 함수는 전체 페이지 로딩을 지연시키고 있습니다. Suspense를 사용하여 이 컴포넌트만 스트리밍 하고 페이지의 나머지 UI를 우선 표시할 수 있습니다. /dashboard/(overview)/page.tsx 에서 fetchRevenue() 함수와 그 데이터의 모든 인스턴스를 삭제합니다. 그리고 컴포넌트로 를 감싸줍니다. 로딩되는 동안 표시될 컴포넌트도 넣어줍니다. ```typescript import { Card } from '@/app/ui/dashboard/cards'; import RevenueChart from '@/app/ui/dashboard/revenue-chart'; import LatestInvoices from '@/app/ui/dashboard/latest-invoices'; import { inter } from '@/app/ui/fonts'; import { fetchLatestInvoices, fetchCardData } from '@/app/lib/data'; import {Suspense} from \"react\"; import {RevenueChartSkeleton} from \"@/app/ui/skeletons\"; export default async function Page() { const latestInvoices = await fetchLatestInvoices(); const { numberOfInvoices, numberOfCustomers, totalPaidInvoices, totalPendingInvoices, } = await fetchCardData(); } ``` 컴포넌트 내부에서 자체 데이터를 패치하도록 업데이트 합니다. /app/ui/dashboard/revenue-chart.tsx ```typescript jsx import { generateYAxis } from '@/app/lib/utils'; import { CalendarIcon } from '@heroicons/react/24/outline'; import { lusitana } from '@/app/ui/fonts'; import { fetchRevenue } from '@/app/lib/data'; // ... export default async function RevenueChart() { // Make component async, remove the props const revenue = await fetchRevenue(); // Fetch data inside the component const chartHeight = 350; const { yAxisLabels, topLabel } = generateYAxis(revenue); if (!revenue || revenue.length === 0) { return No data available. ; } return ( &lt;h1 className={`${inter.className} mb-4 text-xl md:text-2xl`}&gt; Dashboard &lt;/h1&gt; { &lt;Card title=\"Collected\" value={totalPaidInvoices} type=\"collected\" /&gt; } { &lt;Card title=\"Pending\" value={totalPendingInvoices} type=\"pending\" /&gt; } { &lt;Card title=\"Total Invoices\" value={numberOfInvoices} type=\"invoices\" /&gt; } { &lt;Card title=\"Total Customers\" value={numberOfCustomers} type=\"customers\" /&gt; } &lt;Suspense fallback={}&gt; &lt;/Suspense&gt; &lt;LatestInvoices latestInvoices={latestInvoices} /&gt; ); } ``` 브라우저에서 확인 ![img-18.png](img-18.png) #### 9.4.5 컴포넌트 그룹화 컴포넌트들을 Suspense로 래핑하는 작업을 진행하겠습니다. 정적인 컴포넌트가 우선 표시된 후, 그 다음 동적인 카드를 표시하게 할 수 있습니다. /dashboard/(overview)/page.tsx ```typescript jsx import RevenueChart from '@/app/ui/dashboard/revenue-chart'; import LatestInvoices from '@/app/ui/dashboard/latest-invoices'; import { inter } from '@/app/ui/fonts'; import {Suspense} from \"react\"; import CardWrapper from '@/app/ui/dashboard/cards'; import {RevenueChartSkeleton, LatestInvoicesSkeleton, CardsSkeleton } from \"@/app/ui/skeletons\"; export default async function Page() { return ( &lt;h1 className={`${inter.className} mb-4 text-xl md:text-2xl`}&gt; Dashboard &lt;/h1&gt; &lt;Suspense fallback={}&gt; &lt;/Suspense&gt; ``` /app/ui/dashboard/cards.tsx ```typescript jsx // ... import { fetchCardData } from '@/app/lib/data'; // ... export default async function CardWrapper() { const { numberOfInvoices, numberOfCustomers, totalPaidInvoices, totalPendingInvoices, } = await fetchCardData(); return ( &lt;&gt; &lt;Card title=\"Collected\" value={totalPaidInvoices} type=\"collected\" /&gt; &lt;Card title=\"Pending\" value={totalPendingInvoices} type=\"pending\" /&gt; &lt;Card title=\"Total Invoices\" value={numberOfInvoices} type=\"invoices\" /&gt; &lt;Card title=\"Total Customers\" value={numberOfCustomers} type=\"customers\" /&gt; &lt;/&gt; ); } ``` 이 방식을 적용하고 페이지를 새로고침하면, 모든 카드가 동시에 로드되는 것을 확인 할 수 있습니다. routing group을 통해 여러 컴포넌트를 동시에 로드할 수 있습니다. #### 9.4.5 사용 전략 **배치 시 고려할 사항** * 페이지가 스트리밍됨에 따라 사용자가 경험할 페이지의 흐름. * 우선 순위를 둘 콘텐츠의 종류. * 컴포넌트가 데이터 패칭에 의존하는지 여부. 방법 1. loading.tsx - 전체 페이지를 스트리밍 할 수 있지만, 컴포넌트 중 하나 때문에 로딩 시간이 지연될 수 있다. 방법 2. 모든 컴포넌트를 개별적으로 스트리밍 할 수 있지만 준비되는 대로 UI가 표시되어 시각적으로 불편할 수 있다. 방법 3. 래퍼 컴포넌트를 통해 그룹별 스트리밍 할 수 있다. ## 10 . Search and Pagination /invoices page에서 serch 와 pagination 기능을 추가해볼 수 있습니다. `/app/dashboard/invoices/page.tsx` ```typescript jsx import Pagination from '@/app/ui/invoices/pagination'; import Search from '@/app/ui/search'; import Table from '@/app/ui/invoices/table'; import { CreateInvoice } from '@/app/ui/invoices/buttons'; import { lusitana } from '@/app/ui/fonts'; import { InvoicesTableSkeleton } from '@/app/ui/skeletons'; import { Suspense } from 'react'; export default async function Page() { return ( &lt;h1 className={`${lusitana.className} text-2xl`}&gt;Invoices&lt;/h1&gt; {/* &lt;Suspense key={query + currentPage} fallback={}&gt; &lt;Table query={query} currentPage={currentPage} /&gt; &lt;/Suspense&gt; */} {/* &lt;Pagination totalPages={totalPages} /&gt; */} ); } ``` **컴포넌트 설명** - 는 사용자가 특정 인보이스를 검색할 수 있게 합니다. - 는 사용자가 인보이스 페이지를 넘나들 수 있게 합니다. - 은 인보이스를 표시합니다. 검색 기능은 클라이언트와 서버 양쪽에서 작동합니다. 사용자가 클라이언트에서 인보이스를 검색할 때 URL 파라미터가 업데이트되고, 데이터는 서버에서 패치되며, 새로운 데이터로 테이블이 서버에서 다시 렌더링됩니다. ### 10.1 URL 검색 파라미터 Next.js에서는 클라이언트 측 상태에 검색 상태를 관리하는게 아닌 URL 검색 파라미터를 사용합니다. **검색 파라미터의 장점** **북마크 가능하고 공유 가능한 URL** - 검색 파라미터가 URL에 포함되어 있기 때문에, 사용자는 현재 상태 및 검색 쿼리와 필터등을 저장할 수 있습니다. **서버 사이드 렌더링 및 초기로드** - URL 파라미터는 서버에서 직접 사용할 수 있어 초기 상태를 렌더링하는데 유리합니다. **분석 및 추적** - 검색 쿼리와 필터가 URL에 포함되어 있기 때문에, 클라이언트 로직 없이 사용자의 행동을 추적할 수 있습니다. ### 10.2 검색 기능 추가하기 Next.js 의 클라이언트 훅을 사용하여 검색 기능을 구현할 수 있습니다. **사용할 Next.js 클라이언트 훅** - **useSearchParams** - 현재 URL의 파라미터에 접근할 수 있게 해줍니다. 예를 들어, `/dashboard/invoices?page=1&amp;query=pending` URL에 대한 검색 파라미터는 `{page: '1', query: 'pending'}` 입니다. - **usePathname** - 현재 URL의 경로명(pathname)을 읽을 수 있게 해줍니다. 예를 들어, `/dashboard/invoices` 라우트에 대해 usePathname은 `/dashboard/invoices`를 반환합니다. - **useRouter** - 클라이언트 컴포넌트 내에서 라우트 간의 이동을 가능하게 합니다. **구현 프로세스** 1. 사용자 입력 확인 2. URL을 검색 파라미터로 업데이트 3. 입력 필드와 URL 동기화 유지 4. 검색 쿼리를 반영하여 테이블 업데이트 #### 10.2.1 사용자 입력 확인 `/app/ui/search.tsx` ```typescript jsx 'use client'; import { MagnifyingGlassIcon } from '@heroicons/react/24/outline'; export default function Search({ placeholder }: { placeholder: string }) { function handleSearch(term: string) { console.log(term); } return ( Search &lt;input className=\"peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500\" placeholder={placeholder} onChange={(e) =&gt; { handleSearch(e.target.value); }} /&gt; ); } ``` `\"use client\"` - 클라이언트에서 사용될 컴포넌트를 의미합니다. 이벤트 리스너와 훅을 사용할 수 있습니다. `` - 검색 입력 필드입니다. `handleSearch` - 유저의 입력값을 포착할 함수를 선언합니다. `` 요소에 `onChange` 리스너를 추가하여 입력 값이 변경될 때마다 `handleSearch` 함수를 호출하도록 합니다. **invoce 채널에 입력 요소가 생긴 모습** ![img-19.png](img-19.png)ㅇ **콘솔 로그 확인하기** ![img-20.png](img-20.png) 검색 필드에 입력하는 동안, 컴포넌트의 onChange 이벤트 핸들러에 의해 설정된 handleSearch 함수가 호출되며, 이 함수 내에서 console.log()를 통해 검색어가 로그로 출력됩니다. #### 10.2.2 URL을 검색 파라미터로 업데이트 앞서 구현한 사용자 입력 포착 기능으로, 이제 사용자가 입력한 검색어를 URL에 반영하여 애플리케이션의 상태를 동적으로 관리할 수 있습니다. `'next/navigation'`에서 `useSearchParams` 훅을 임포트하고, `defaultValue`에 할당합니다. `/app/ui/search.tsx` ```typescript jsx 'use client'; import { MagnifyingGlassIcon } from '@heroicons/react/24/outline'; import { useSearchParams } from 'next/navigation'; export default function Search() { const searchParams = useSearchParams(); function handleSearch(term: string) { console.log(term); } // ... } ``` `handleSearch` 함수 내부에서 앞서 생성한 searchParmas를 인자로 받는 새로운 `URLSearchParams` 인스턴스를 생성합니다. ```typescript jsx 'use client'; import { MagnifyingGlassIcon } from '@heroicons/react/24/outline'; import { useSearchParams } from 'next/navigation'; export default function Search() { const searchParams = useSearchParams(); function handleSearch(term: string) { const params = new URLSearchParams(searchParams); } // ... } ``` `URLSearchParams`는 웹 API의 일부로, URL의 쿼리 파라미터를 조작하는데 사용되는 메소드를 제공합니다. 이를 통해 개발자가 URL 쿼리 스트링을 쉽게 조작할 수 있습니다. 예를 들어 `?page=1&amp;query=a` 와 같은 쿼리를 만들 수 있습니다. 아래 코드는 사용자의 입력이 있다면 query 파라미터를 설정하고 없으면 삭제합니다. ```typescript jsx 'use client'; import { MagnifyingGlassIcon } from '@heroicons/react/24/outline'; import { useSearchParams } from 'next/navigation'; export default function Search() { const searchParams = useSearchParams(); function handleSearch(term: string) { const params = new URLSearchParams(searchParams); if (term) { params.set('query', term); } else { params.delete('query'); } } // ... } ``` `useRouter`와 `usePathname`을 임포트하고, `useRouter()`의 `replace` 메서드를 사용하여 URL을 업데이트합니다. `/app/ui/search.tsx` ```typescript jsx 'use client'; import { MagnifyingGlassIcon } from '@heroicons/react/24/outline'; import { useSearchParams, usePathname, useRouter } from 'next/navigation'; export default function Search() { const searchParams = useSearchParams(); const pathname = usePathname(); const { replace } = useRouter(); function handleSearch(term: string) { const params = new URLSearchParams(searchParams); if (term) { params.set('query', term); } else { params.delete('query'); } replace(`${pathname}?${params.toString()}`); } } ``` 이렇게 하면 사용자가 검색 바에 입력할 때마다 ${pathname}?${params.toString()}가 URL을 동적으로 업데이트합니다. 예를 들어 사용자가 \"Lee\"를 검색하면 /dashboard/invoices?query=lee와 같이 URL이 업데이트됩니다. 이 구현을 통해, 검색 기능이 URL에 반영되게 됩니다. 또한, Next.js의 클라이언트 측 네비게이션을 활용하여 페이지를 새로고침하지 않고도 URL을 업데이트할 수 있습니다. #### 10.2.3 URL과 입력 필드 동기화 하기 사용자가 애플리케이션 내에서 검색을 수행할 때, 그 검색 상태를 URL에 반영하여 해당 상태를 공유할 수 있도록 합니다. 이는 공유 받은 사람들도 검색 쿼리가 URL에 반영되기 때문에 같은 검색 결과를 볼 수 있게 됩니다. 이를 통해 사용자의 검색 상태가 URL에 저장이 되며, 애플리케이션은 사용자가 접근한 URL을 확인하고 이전 검색상태를 복원할 수 있게 됩니다. **구현방법** `useSearchParams` 훅을 사용하여 URL의 파라미터에 접근하고, 입력 필드에 `defaultValue` 속성을 통해 두 값을 동기화 할 수 있습니다. `/app/ui/search.tsx` ```typescript jsx &lt;input className=\"peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500\" placeholder={placeholder} onChange={(e) =&gt; { handleSearch(e.target.value); }} defaultValue={searchParams.get('query')?.toString()} /&gt; ``` **제어 컴포넌트 vs 비 제어 컴포넌트** * 제어 컴포넌트 (Controlled Component) - 제어 컴포넌트는 `value` 속성을 통해 React가 입력 필드의 상태를 직접 관리하는 방식입니다. 이 방식에서는 입력 필드에 직접 입력하는 것이 아니라, 상태(state) 변경을 통해 입력값이 조절됩니다. 이는 React 상태를 통해 입력 필드의 값이 언제나 동기화되어 있음을 보장하며, 상태 관리 로직을 React 내부에 집중시킬 수 있습니다. * 비제어 컴포넌트 (Uncontrolled Component) - 비제어 컴포넌트는 `defaultValue` 속성을 사용하여 입력 필드가 자체 상태를 관리하도록 합니다. **URL 쿼리 파라미터와 `defaultValue`** ```typescript jsx defaultValue={searchParams.get('query')?.toString()} ``` 이 코드는 URL의 쿼리 파라미터가 있다면 그 값으로 입력 필드의 초기값을 설정하는 코드입니다. 이 접근 방식의 장점은 사용자가 특정 검색어로 페이지에 접근했을 때 (예: /search?query=example), 해당 검색어(example)가 입력 필드에 자동으로 채워져서 표시되도록 할 수 있다는 점입니다. #### 10.2.4 테이블 컴포넌트 업데이트 하기 사용자의 컴색 쿼리에 따라 테이블 컴포넌트를 업데이트 할 수 있습니다. /dashboard/invoices/page.tsx ```typescript jsx import Pagination from '@/app/ui/invoices/pagination'; import Search from '@/app/ui/search'; import Table from '@/app/ui/invoices/table'; import { CreateInvoice } from '@/app/ui/invoices/buttons'; import { lusitana } from '@/app/ui/fonts'; import { Suspense } from 'react'; import { InvoicesTableSkeleton } from '@/app/ui/skeletons'; export default async function Page({ searchParams, }: { searchParams?: { query?: string; page?: string; }; }) { const query = searchParams?.query || ''; const currentPage = Number(searchParams?.page) || 1; return ( &lt;h1 className={`${lusitana.className} text-2xl`}&gt;Invoices&lt;/h1&gt; &lt;Suspense key={query + currentPage} fallback={}&gt; &lt;Table query={query} currentPage={currentPage} /&gt; &lt;/Suspense&gt; {/* &lt;Pagination totalPages={totalPages} /&gt; */} ); } ``` `` 컴포넌트 내에서 (app/ui/invoices/table.tsx) `query` 및 `currentPage` prop을 사용하여 검색조건에 맞는 invoice를 fetching 하는 로직을 확인할 수 있습니다. ```typescript jsx // 필요한 import들... export default async function InvoicesTable({ query, currentPage, }: { query: string; currentPage: number; }) { // 검색 쿼리와 현재 페이지를 기반으로 필터링된 인보이스 패칭 const invoices = await fetchFilteredInvoices(query, currentPage); // 인보이스 데이터를 테이블에 반영하는 로직... } ``` **useSearchParams() 훅 vs. searchParams prop** 클라이언트 컴포넌트인 ``에서는 `useSearchParams()` 훅을 사용하여 클라이언트 측에서 파라미터에 접근했습니다. 반면에, 서버에서 데이터를 패칭하는 `` 컴포넌트는 페이지 컴포넌트로부터 `searchParams` prop을 전달받아 사용했습니다. 클라이언트에서 파라미터를 읽어야 할 때는 useSearchParams() 훅을 사용하고, 서버에서 처리할 때는 prop을 통해 필요한 파라미터를 컴포넌트로 전달하는 것이 좋습니다. ### 10.3 debouncing 디바운싱은 함수가 실행될 수 있는 비율을 제한하는 관행입니다. 이를 통해 사용자가 타이핑을 멈췄을 때만 데이터베이스를 쿼리할 수 있도록 설정할 수 있습니다. 디바운싱이 적용되지 않는다면 사용자가 입력할 때마다 아래와 같이 데이터베이스를 쿼리하게 될 것입니다. ![img-21.png](img-21.png) **디바운싱 작동 방식** 트리거 이벤트: 디바운싱되어야 할 이벤트(예: 검색 상자에서의 키 입력)가 발생하면 타이머가 시작됩니다. 대기: 타이머가 만료되기 전에 새 이벤트가 발생하면 타이머가 리셋됩니다. 실행: 타이머가 카운트다운의 끝에 도달하면 디바운스된 함수가 실행됩니다. `use-debounce` 라이브러리 활용 /app/ui/search.tsx ```typescript jsx // ... import { useDebouncedCallback } from 'use-debounce'; // Inside the Search Component... const handleSearch = useDebouncedCallback((term) =&gt; { console.log(`Searching... ${term}`); const params = new URLSearchParams(searchParams); if (term) { params.set('query', term); } else { params.delete('query'); } replace(`${pathname}?${params.toString()}`); }, 300); ``` 사용자가 타이핑을 멈춘 후 300ms 가 지난 후에 코드가 실행될 수 있도록 합니다. ### 10.4 Pagination 사용자가 페이지를 넘겨가며 모든 결과 쿼리를 확인할 수 있습니다. `/dashboard/invoices/page.tsx` 서버에서 데이터를 fetching 합니다. ```typescript jsx // ... import { fetchInvoicesPages } from '@/app/lib/data'; export default async function Page({ searchParams, }: { searchParams?: { query?: string, page?: string, }, }) { const query = searchParams?.query || ''; const currentPage = Number(searchParams?.page) || 1; const totalPages = await fetchInvoicesPages(query); return ( // ... ); } ``` `` 컴포넌트에 totalPages prop을 전달합니다. ```typescript jsx // ... export default async function Page({ searchParams, }: { searchParams?: { query?: string; page?: string; }; }) { const query = searchParams?.query || ''; const currentPage = Number(searchParams?.page) || 1; const totalPages = await fetchInvoicesPages(query); return ( &lt;h1 className={`${lusitana.className} text-2xl`}&gt;Invoices&lt;/h1&gt; &lt;Suspense key={query + currentPage} fallback={}&gt; &lt;Table query={query} currentPage={currentPage} /&gt; &lt;/Suspense&gt; &lt;Pagination totalPages={totalPages} /&gt; ); } ``` pagination component 구현 `` 컴포넌트는 클라이언트 컴포넌트로, 현재 페이지와 총 페이지 수를 기반으로 페이지네이션을 구현합니다. 새 페이지 번호를 설정하기 위해 `URLSearchParams`를 사용하고, `pathname`을 사용하여 URL 문자열을 생성합니다. ```typescript jsx 'use client'; import { ArrowLeftIcon, ArrowRightIcon } from '@heroicons/react/24/outline'; import clsx from 'clsx'; import Link from 'next/link'; import { generatePagination } from '@/app/lib/utils'; import { usePathname, useSearchParams } from 'next/navigation'; export default function Pagination({ totalPages }: { totalPages: number }) { const pathname = usePathname(); const searchParams = useSearchParams(); const currentPage = Number(searchParams.get('page')) || 1; // ... } ``` 페이지 번호 리셋 `` 컴포넌트의 handleSearch 함수를 업데이트 합니다. ```typescript jsx 'use client'; import { useDebouncedCallback } from 'use-debounce'; import { usePathname, useRouter, useSearchParams } from 'next/navigation'; // 기타 필요한 import들... export default function Search({ placeholder }: { placeholder: string }) { const searchParams = useSearchParams(); const { replace } = useRouter(); const pathname = usePathname(); const handleSearch = useDebouncedCallback((term) =&gt; { const params = new URLSearchParams(searchParams); params.set('page', '1'); // 페이지 번호를 1로 설정 if (term) { params.set('query', term); } else { params.delete('query'); } replace(`${pathname}?${params.toString()}`); }, 300); // 검색 로직... } ``` ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#9-%EC%A0%95%EC%A0%81-%EB%B0%8F-%EB%8F%99%EC%A0%81-%EB%8C%80%EC%8B%9C%EB%B3%B4%EB%93%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#9-정적-및-동적-대시보드-구현하기"
  },"482": {
    "doc": "Next.js",
    "title": "Next.js",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js"
  },"483": {
    "doc": "Markdown",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/01_languages/Markdown#color-utilities",
    
    "relUrl": "/docs/01_languages/Markdown#color-utilities"
  },"484": {
    "doc": "Markdown",
    "title": "Table of contents",
    "content": ". ",
    "url": "/docs/01_languages/Markdown#table-of-contents",
    
    "relUrl": "/docs/01_languages/Markdown#table-of-contents"
  },"485": {
    "doc": "Markdown",
    "title": "Markdown",
    "content": " ",
    "url": "/docs/01_languages/Markdown",
    
    "relUrl": "/docs/01_languages/Markdown"
  },"486": {
    "doc": "1. Network",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS#color-utilities",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#color-utilities"
  },"487": {
    "doc": "1. Network",
    "title": "Table of contents",
    "content": ". | AWS EC2에서 Docker를 사용하여 Jenkins 배포하기 . | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS EC2 Ubuntu OS를 awscli를 통해 배포 | . | . ",
    "url": "/docs/02_Tech/AWS/ECS#table-of-contents",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#table-of-contents"
  },"488": {
    "doc": "1. Network",
    "title": "AWS EC2에서 Docker를 사용하여 Jenkins 배포하기",
    "content": "AWS EC2 인스턴스에 Docker를 사용하여 Jenkins를 배포하는 방법을 공유합니다. ",
    "url": "/docs/02_Tech/AWS/ECS#aws-ec2%EC%97%90%EC%84%9C-docker%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-jenkins-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#aws-ec2에서-docker를-사용하여-jenkins-배포하기"
  },"489": {
    "doc": "1. Network",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/02_Tech/AWS/ECS#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#목차"
  },"490": {
    "doc": "1. Network",
    "title": "글을 쓴 배경",
    "content": "Jenkins를 AWS EC2 인스턴스에 설치하는 과정을 기록하기 위해 작성하였습니다. ",
    "url": "/docs/02_Tech/AWS/ECS#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#글을-쓴-배경"
  },"491": {
    "doc": "1. Network",
    "title": "글 요약",
    "content": "AWS EC2 인스턴스에 userdata를 이용하여 Docker로 Jenkins를 Ubuntu OS에 배포하는 방법을 공유합니다. AWS EC2 인스턴스 생성부터 Docker 이미지를 이용한 배포 프로세스까지 스크립트를 이용해 한번에 설치할 수 있도록 구성하였습니다. ",
    "url": "/docs/02_Tech/AWS/ECS#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#글-요약"
  },"492": {
    "doc": "1. Network",
    "title": "시작하기 전",
    "content": "AWS, Docker, Jenkins에 대한 기본적인 이해가 있으신 분들을 위해 작성되었습니다. AWS EC2 인스턴스 생성 및 설정, Docker에 대한 기본 지식이 필요합니다. Ubuntu version 22.04 LTS / 사용한 UBUNTU_AMI_ID =ami-09a7535106fbd42d5 . 사용한 docker image - jenkins/jenkins:jdk17 . 젠킨슨 버전 - 2.449 . 사용한 레포지토리 주소 Jenkins-repo . ",
    "url": "/docs/02_Tech/AWS/ECS#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#시작하기-전"
  },"493": {
    "doc": "1. Network",
    "title": "1. AWS EC2 Ubuntu OS를 awscli를 통해 배포",
    "content": "참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/AWS/ECS#1-aws-ec2-ubuntu-os%EB%A5%BC-awscli%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/02_Tech/AWS/ECS#1-aws-ec2-ubuntu-os를-awscli를-통해-배포"
  },"494": {
    "doc": "1. Network",
    "title": "1. Network",
    "content": " ",
    "url": "/docs/02_Tech/AWS/ECS",
    
    "relUrl": "/docs/02_Tech/AWS/ECS"
  },"495": {
    "doc": "Next.js",
    "title": "ECS 용량공급자",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#ecs-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#ecs-용량공급자"
  },"496": {
    "doc": "Next.js",
    "title": "목차",
    "content": ". | TOC | . # . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#목차"
  },"497": {
    "doc": "Next.js",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#%EB%AA%A9%EC%B0%A8-1",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#목차-1"
  },"498": {
    "doc": "Next.js",
    "title": "글을 쓴 배경",
    "content": "ECS 서비스를 이용해 sample application 도커 이미지를 배포하는 방법을 공유합니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#글을-쓴-배경"
  },"499": {
    "doc": "Next.js",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#글-요약"
  },"500": {
    "doc": "Next.js",
    "title": "시작하기 전",
    "content": "참고자료 AWS ECS Workshop . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#시작하기-전"
  },"501": {
    "doc": "Next.js",
    "title": "1. 용량공급자란",
    "content": "Amazon Elastic Container Registry(ECR)에 ECS에서 실행되는 애플리케이션 이미지를 저장 및 관리할 수 있습니다. ECS TaskDefinition에 Amazon ECR 리포지토리를 지정하기만 하면 Amazon ECS에서 지정된 이미지를 가져와 배포합니다. 우선, 배포할 이미지를 업로드 해줍니다. 저는 nginx container 이미지를 업로드해주었습니다. 참고자료 : Amazon ECR . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#1-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90%EB%9E%80",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#1-용량공급자란"
  },"502": {
    "doc": "Next.js",
    "title": "2. AWS ECS Cluster 에서 용량공급자 선택하기",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#2-aws-ecs-cluster-%EC%97%90%EC%84%9C-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs#2-aws-ecs-cluster-에서-용량공급자-선택하기"
  },"503": {
    "doc": "Next.js",
    "title": "Next.js",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs"
  },"504": {
    "doc": "Next.js",
    "title": "Learn Next.js",
    "content": "Next.js는 React 기반의 프레임워크로, 서버 사이드 렌더링, 스태틱 사이트 생성, 그리고 웹 애플리케이션 최적화를 위한 다양한 기능을 제공합니다. 이 글에서는 Next.js를 이용해 간단한 금융 대시보드 페이지를 만드는 과정을 설명합니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#learn-nextjs",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#learn-nextjs"
  },"505": {
    "doc": "Next.js",
    "title": "목차",
    "content": ". | 글 요약 | 시작하기 전 | . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#목차"
  },"506": {
    "doc": "Next.js",
    "title": "글 요약",
    "content": "제작할 웹 어플리케이션은 다음과 같은 기능을 가지고 있습니다. 공개 홈페이지: 모든 사용자가 접근할 수 있는 홈 페이지입니다. 로그인 페이지: 사용자 인증을 위한 로그인 페이지입니다. 인증에 의해 보호되는 대시보드 페이지: 인증된 사용자만 접근할 수 있는 대시보드 페이지들입니다. CRUD: 사용자가 금융 정보를 관리할 수 있는 기능입니다. 데이터베이스: 애플리케이션의 데이터를 관리하는 데이터베이스 설정입니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#글-요약"
  },"507": {
    "doc": "Next.js",
    "title": "시작하기 전",
    "content": "이 과정은 React 및 JavaScript에 대한 기본적인 이해를 가정합니다. 참고자료 : Learn Next.js . 원래 react code . app.tsx ```typescript jsx import { HashRouter, BrowserRouter, Routes, Route, Outlet, } from “react-router-dom”; import { USE_BROWSER_ROUTER } from “./common/constants”; import GlobalHeader from “./components/global-header”; import DashboardPage from “./pages/dashboard/dashboard-page”; import ViewItemPage from “./pages/section1/view-item/view-item-page”; import AllItemsPage from “./pages/section1/all-items/all-items-page”; import AddItemPage from “./pages/section1/add-item/add-item-page”; import NotFound from “./pages/not-found”; import “./styles/app.scss”; . export default function App() { const Router = USE_BROWSER_ROUTER ? BrowserRouter : HashRouter; . return ( &lt;div style=&gt; &lt;div style=&gt;&nbsp;&lt;/div&gt; &lt;div&gt; &lt;Route index path=\"/\" element={} /&gt; &lt;Route path=\"/section1\" element={}&gt; &lt;Route path=\"\" element={} /&gt; &lt;Route path=\"add\" element={} /&gt; &lt;Route path=\"items/:itemId\" element={} /&gt; &lt;/Route&gt; &lt;Route path=\"*\" element={} /&gt; &lt;/div&gt; &lt;/div&gt; ); } . main.tsx ```typescript jsx import React from \"react\"; import ReactDOM from \"react-dom/client\"; import { StorageHelper } from \"./common/helpers/storage-helper\"; import App from \"./app\"; import \"@cloudscape-design/global-styles/index.css\"; const root = ReactDOM.createRoot( document.getElementById(\"root\") as HTMLElement ); const theme = StorageHelper.getTheme(); StorageHelper.applyTheme(theme); root.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt; ); . main.tsx와 현재의 app.tsx 파일에서 사용하고 있는 react-router-dom 관련 코드는 더 이상 필요하지 않습니다. Next.js는 자체적으로 파일 기반 라우팅 시스템을 제공하기 때문에 별도의 라우터를 사용할 필요가 없습니다. Next.js에서 페이지와 라우팅을 관리하는 방법은 간단합니다. pages 디렉토리 내에 각 경로에 해당하는 파일 또는 폴더를 생성하면 되는데, 파일의 구조가 URL 경로와 직접 매핑됩니다. 예를 들어, 다음과 같이 구조화할 수 있습니다: . pages/index.tsx – 홈페이지(/) pages/section1/index.tsx – 섹션1의 메인 페이지(/section1) pages/section1/all-items.tsx – 모든 아이템 페이지(/section1/all-items) pages/section1/add-item.tsx – 아이템 추가 페이지(/section1/add-item) pages/section1/items/[itemId].tsx – 개별 아이템 보기 페이지(/section1/items/123) . Next.js에서는 pages/_app.tsx 파일이 전역적인 레이아웃이나 페이지 간 공유해야 할 상태를 관리하는 데 사용됩니다. 예를 들어 StorageHelper의 테마 관련 코드는 _app.tsx 파일에서 처리할 수 있습니다. | _app.tsx 파일을 활용하여 공통 레이아웃 적용 _app.tsx 파일은 모든 페이지에 공통적으로 적용될 레이아웃 및 상태를 관리합니다. 이는 헤더, 푸터, 사이드바 등의 UI 컴포넌트를 모든 페이지에서 재사용할 수 있게 해 줍니다. 예를 들어, layout.tsx 파일의 코드를 _app.tsx로 이동시키거나 layout.tsx를 _app.tsx에서 불러와 사용할 수 있습니다. | _document.tsx 파일을 활용하여 문서 기본 설정 적용 _document.tsx는 서버에서 단 한 번만 로드되는 HTML 문서의 기본 구조를 설정합니다. 이 파일을 사용하여 문서의 lang 속성, 메타 태그, 글로벌 CSS 등을 설정할 수 있습니다. | . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js#시작하기-전"
  },"508": {
    "doc": "Next.js",
    "title": "Next.js",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/nextjs/learn-next-js"
  },"509": {
    "doc": "Portfolio",
    "title": "김경민 - 개발 좋아하는 DevOps Engineer",
    "content": ". | 개인 블로그 : https://blog.kimkm.com | 개인 github 주소 : https://github.com/kimkmari | 연락처 : kimkmari04@gmail.com | . DevOps . | AWS Resource 및 배포 툴을 이용하여 파이프라인 구축. ( CodePipeline , Jenkins, Github action, CircleCI ) | IaC를 활용한 AWS 클라우드 환경 구축. ( CDK , Terraform ) | 어플리케이션 개발 지원을 위한 AWS Resource 활용. ( Lambda , API Gateway , CloudFront ) | 사내 업무 향상을 위한 사내 어플리케이션 개발. ( Image Resizing , AWS Resource Exporter , ChatGPT Slack , EKS SandBox ) | 컨테이너화된 애플리케이션의 안전한 공급을 위한 DevSecOps 환경 구성 ( Prowler , Kubescape , ArgoCD , helm ) | . Career - 2024 . JWT Authorizer Project . | 설명: AWS Gateway 혹은 CloudFront를 활용하여 RS384 알고리즘 기반 키 페어 방식의 JWT 토큰 인증 구현 프로젝트 | 구현: Java 21 런타임으로 설정된 Lambda를 사용하여 개발. AWS 리소스를 활용해 효율적인 캐싱을 구현하고 트래픽을 분산하여 과부하를 줄였습니다. | 산출물: . | JAVA21 - SAM - LAMBDA - TEMPLATE | | . | . Image Resizing Project . | 설명: CloudFront 또는 S3 Object Lambda Access Points를 이용하여 원본 이미지를 요청된 사이즈로 변환하는 프로젝트 | 구현: Node.js 20 런타임으로 설정된 Lambda를 사용하여 개발. 새로 생성된 이미지를 저장하지 않고 캐싱하여 제공하는 방식으로 자원 효율성을 극대화했습니다. | 산출물: | . AWS Exporter Project . | 설명: Slack과 Lambda를 이용해 특정 계정의 모든 AWS 리소스를 Excel 파일로 변환하는 사내 업무 효율화를 위한 애플리케이션 제작 | 구현: Python 3.12 런타임으로 설정된 Lambda를 사용하여 개발. Slack 커맨드를 통해 AWS 리소스 정보를 담은 Excel 파일을 반환하여 프로젝트 자원 현황표 작성 지원하였습니다. | 산출물: | . IaC CDK Project . | 설명: AWS CDK V2를 이용해 애플리케이션 배포 파이프라인 구축 | 구현: 모듈화된 구조로, 하나의 모듈을 이용하여 여러 프로젝트를 다양한 구성 정보로 배포 가능하도록 설정하여 재활용성을 높였습니다. | . Career - 2023 . Container Security Enhancement Project . | 설명: 다양한 조직의 EKS 환경을 표준화 하고 거버넌스를 수립하여 사용되는 컨테이너와 의존성의 안전성을 검증하는 프로젝트 | 구현: 중앙 저장소에 저장될 컨테이너의 취약성 검사, 서명, SBOM 생성 프로세스를 구축. 또한 kubescape를 활용한 Helm 차트 검증 프로세스 구축 Github Action을 통해 구현하였습니다. | . Pipeline Project . | 설명: AWS ECS 클러스터 환경에서 Jenkins와 CodeDeploy를 이용한 컨테이터화된 애플리케이션 배포 | 구현: Node.js 기반 어플리케이션 배포. Microsoft Teams Messenger를 통한 파이프라인 제어를 구현하여 사용자 편의성을 향상하였고, 클러스터 환경을 통해 가용성을 확보하였습니다. | 산출물: | . EKS SandBox Project . | 설명: 실무자들이 원하는 세팅으로 간단하게 EKS 환경 및 대시보드를 구축할 수 있는 어플리케이션 배포 | 구현: Slack을 연동하여 사용자 친화적인 UI로 원하는 설정의 초기 세팅된 EKS 배포를 Terraform IaC tool을 이용해 배포. | 산출물: | . Career - 2022 . Chat GPT Slack 용 application 개발 . | 설명: nodejs 20을 이용한 slack 에서 사용할 수 있는 chat gpt 개발 | 구현: open AI api를 이용하여 구현하였습니다. | 산출물: | . Java Application Development Project . | 설명: JAVA17을 이용한 당근마켓 클론 API 서버 개발 | 구현: AWS Pipeline 을 이용해 배포하였습니다. | 산출물: | . Diary Mobile Application Project . | 설명: JAVA17을 이용한 모바일 다이어리 어플리케이션 개발 | 구현: Designer , Front Developer 와 협업하여 모바일 어플리케이션을 배포하였습니다. | 산출물: | . ETC . Translator 활동 . | 설명: 2024년 현재 사내 영어 회의의 동시 통역가로 활동하고 있습니다. 다양한 기술을 영어로 설명하면서 외국인 고객과의 소통을 돕고있습니다. | . 중소벤처기업부 비대면 예비 창업 패키지 선정 . | 설명: 2022년 배달 어플리케이션 아이디어를 제안하여 지원을 받고 모바일 어플리케이션 사업을 진행하였습니다. | . 자격증 . | AWS Solutions Architect | DevOps Engineer | Machine Learning | . PROFILE / CONTACT . | 1995.04.28 | 한양대학교 ERICA 신산업 공학 소프트웨어 학부 / 경영학부 복수 전공 | . ",
    "url": "/docs/00_Portfolio/portfolio.html#%EA%B9%80%EA%B2%BD%EB%AF%BC---%EA%B0%9C%EB%B0%9C-%EC%A2%8B%EC%95%84%ED%95%98%EB%8A%94-devops-engineer",
    
    "relUrl": "/docs/00_Portfolio/portfolio.html#김경민---개발-좋아하는-devops-engineer"
  },"510": {
    "doc": "Portfolio",
    "title": "Portfolio",
    "content": ". ",
    "url": "/docs/00_Portfolio/portfolio.html",
    
    "relUrl": "/docs/00_Portfolio/portfolio.html"
  },"511": {
    "doc": "Project",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/03_Project#color-utilities",
    
    "relUrl": "/docs/03_Project#color-utilities"
  },"512": {
    "doc": "Project",
    "title": "Table of contents",
    "content": ". ",
    "url": "/docs/03_Project#table-of-contents",
    
    "relUrl": "/docs/03_Project#table-of-contents"
  },"513": {
    "doc": "Project",
    "title": "Project",
    "content": " ",
    "url": "/docs/03_Project",
    
    "relUrl": "/docs/03_Project"
  },"514": {
    "doc": "깃 블로그 만들기",
    "title": "나만의 깃 블로그 만들고 도커 이미지로 로컬 테스트 해보기",
    "content": " ",
    "url": "/docs/03_Project/Project_1_gitblog#%EB%82%98%EB%A7%8C%EC%9D%98-%EA%B9%83-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EB%8F%84%EC%BB%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A1%9C-%EB%A1%9C%EC%BB%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%B4%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog#나만의-깃-블로그-만들고-도커-이미지로-로컬-테스트-해보기"
  },"515": {
    "doc": "깃 블로그 만들기",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | Git Theme 선정 . | 선택한 Theme: Just the Docs | 추천 테마 | . | 테마 사용법 (Just the Docs 기준) . | Just the Docs 템플릿 사용하기 | . | . ",
    "url": "/docs/03_Project/Project_1_gitblog#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog#목차"
  },"516": {
    "doc": "깃 블로그 만들기",
    "title": "글을 쓴 배경",
    "content": "Tech 경험을 공유하기 위해 블로그를 작성하기로 하였습니다. 여러 블로그 플랫폼을 고민한 끝에 git blog를 선택하여 관련 경험을 공유하고자 합니다. ",
    "url": "/docs/03_Project/Project_1_gitblog#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog#글을-쓴-배경"
  },"517": {
    "doc": "깃 블로그 만들기",
    "title": "글 요약",
    "content": ". | Jekyll과 Git을 활용한 블로그 배포: Jekyll을 이용한 정적 웹페이지 생성과 Git을 통한 배포 과정을 설명합니다. | Just the Docs 테마 사용법: 깃 블로그 제작시 선택한 Just the Docs 테마 적용 방법을 안내합니다. | 로컬 검증 방법: 도커를 활용하여 쉽게 로컬 환경에서 Jekyll 기반의 블로그를 검증하고 실행할 수 있는 방법을 공유합니다. | Markdown으로 글 작성하기: 블로그 글 작성을 위한 Markdown 사용 법을 공유합니다. | 테크블로그 구조 공유: 제가 구축한 테크 블로그의 구조를 소개하고, 블로그 시작이 막막한 분들을 위한 참고 방향을 제시합니다. | . ",
    "url": "/docs/03_Project/Project_1_gitblog#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog#글-요약"
  },"518": {
    "doc": "깃 블로그 만들기",
    "title": "시작하기 전",
    "content": "이 블로그는 Git과 docker를 간단하게라도 사용할 줄 아는 사람을 대상으로 합니다. gitHub Pages를 만드는데 필요한 Jekyll은 Windows에서 공식적으로 지원되지 않습니다. 참고 페이지: GitHub Pages 공식 문서 . 사용된 리소스: Git, Docker . ",
    "url": "/docs/03_Project/Project_1_gitblog#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog#시작하기-전"
  },"519": {
    "doc": "깃 블로그 만들기",
    "title": "Git Theme 선정",
    "content": "선택한 Theme: Just the Docs . | Just the Docs: GitHub Repository | . 추천 테마 . | Flexible Jekyll | Just the Docs | Kasper | Lanyon | Clean Blog | Type on Strap | . ",
    "url": "/docs/03_Project/Project_1_gitblog#git-theme-%EC%84%A0%EC%A0%95",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog#git-theme-선정"
  },"520": {
    "doc": "깃 블로그 만들기",
    "title": "테마 사용법 (Just the Docs 기준)",
    "content": "Just the Docs 템플릿 사용하기 . | 레포지토리 생성 . | Just the Docs GitHub Repository의 README.md의 “use the template” 링크를 클릭합니다. | 원하는 이름을 설정하고 레포지토리를 생성합니다. username.github.io 형식을 사용해야합니다. | . | 레포지토리를 웹사이트로 변환하기 (GitHub Pages 활성화) . | GitHub Pages는 무료 웹 호스팅 서비스로, Jekyll과의 통합을 공식적으로 지원합니다. Jekyll 정보 | Jekyll은 정적 웹 사이트를 자동으로 빌드하고 배포하는 Ruby 기반 라이브러리입니다. 레포지토리의 Markdown 파일들을 HTML로 변환하여 최종 웹 페이지를 생성합니다. | . | GitHub Pages 사이트 활성화하기 . | GitHub Docs 웹사이트 만들기 Docs . | Settings에 있는 Pages 클릭 . | Pages 섹션에 있는 Build and deployment 선택하기 ( Configuring a publishing source for your GitHub Pages site ) . | Deploy from a branch - 특정 브랜치(예: main)에 push 이벤트가 발생할 때 자동으로 GitHub Pages 사이트가 빌드되고 배포됩니다. 브랜치와 폴더(/ 루트 또는 /docs 폴더)를 지정하여, 해당 브랜치의 특정 폴더에서 사이트가 배포될 수 있도록 설정할 수 있습니다. | 장점 - 설정이 간단. jekyll 기반 사이트를 빠르게 시작할 수 있다. | 단점 - jekyll 외의 다른 빌드 프로세스나 커스텀 빌드 스크립트를 사용하려면 적합하지 않음. 빌드과정에서 생성된 사이트를 서버에 배포할 때 사용되는 실제 파일들이 동일한 브랜치에 저장되게 됩니다. | . | GitHub Actions - 사용자는 GitHub Actions을 작성하여 사이트를 빌드하고 배포하는 과정을 완전 제어할 수 있습니다. | 장점 - Jekyll 외의 빌드 도구를 사용하거나, 복잡한 빌드 및 배포 프로세스를 구성할 수 있는 유연성 제공 | 단점 - Github Actions에 대한 이해 필요 | . | . | 본 블로그에서는 Github Actions를 선택합니다. | just-the-docs template을 이용해 레포지토리를 생성했다면 이미 github workflow 설정이 되어있습니다. | 추후 커스터마이징을 고려해 GitHub Actions를 선택하였습니다. | main 브랜치에 push event 가 발생하면 빌드와 배포작업이 실행됩니다. 해당 내용은 github repository의 Actions부분에서 확인할 수 있습니다. | . | Custom domain이 있다면 입력해줍니다. | . | 배포 내용 확인하기 . | Pages 섹션에서 “Visit site”를 클릭하여 배포된 사이트를 확인합니다. | . | 외부에 내 블로그를 잠시 노출하고 싶지 않다면 Unpublish site 를 클릭합니다. 정지된 웹페이지는 repository 에 push 이벤트 발생 시 다시 publishing 되게 됩니다. GitHub Pages 사이트 게시 취소 | . | . ",
    "url": "/docs/03_Project/Project_1_gitblog#%ED%85%8C%EB%A7%88-%EC%82%AC%EC%9A%A9%EB%B2%95-just-the-docs-%EA%B8%B0%EC%A4%80",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog#테마-사용법-just-the-docs-기준"
  },"521": {
    "doc": "깃 블로그 만들기",
    "title": "깃 블로그 만들기",
    "content": " ",
    "url": "/docs/03_Project/Project_1_gitblog",
    
    "relUrl": "/docs/03_Project/Project_1_gitblog"
  },"522": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "젠킨슨 파이프라인을 이용해 ECS Cluster에 Java Application 배포하기",
    "content": " ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#%EC%A0%A0%ED%82%A8%EC%8A%A8-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-ecs-cluster%EC%97%90-java-application-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#젠킨슨-파이프라인을-이용해-ecs-cluster에-java-application-배포하기"
  },"523": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. ECS 클러스터 구축 | 2. Jenkins Pipeline 구축 | 3. ECR 구축 | 4. Jenkins 배포 테스트 | . ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#목차"
  },"524": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "글을 쓴 배경",
    "content": "Jenkins 파이프라인을 이용하여 AWS Elastic Container Service Cluster 에 Java Application을 배포하는 과정을 설명하고자 합니다. ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#글을-쓴-배경"
  },"525": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "글 요약",
    "content": ". | 전체 아키텍처 설명 | . | 주요 리소스 설명 . | CodeCommit: AWS가 제공하는 GitHub과 같은 코드 저장소입니다. | Jenkins: 빌드 및 배포 전반을 자동화 할 수 있게 도와주는 오픈소스입니다. | ECR: Amazon Elastic Container Registry는 컨테이너 이미지를 저장하고 관리하는 서비스입니다. Jenkins에서 빌드된 이미지는 이곳에 저장되며, ECS 배포 시 사용됩니다. | CodeDeploy: AWS CodeDeploy는 애플리케이션을 배포하는 서비스입니다. 본 아키텍처에서는 CodeDeploy가 ECR에서 이미지를 가져와 ECS에 어플리케이션을 배포하는 역할을 합니다. | ECS: Amazon Elastic Container Service는 컨테이너를 쉽게 실행하고 관리할 수 있게 해주는 컨테이너 오케스트레이션 서비스입니다. | . ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#글-요약"
  },"526": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "시작하기 전",
    "content": "이 블로그는 Jenkins과 AWS를 어느정도 사용해보신 DevOps를 위한 글 입니다. Java 어플리케이션을 배포할 예정이기에 Java 개발 지식을 가지고 있어야합니다. ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#시작하기-전"
  },"527": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "1. ECS 클러스터 구축",
    "content": " ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#1-ecs-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%B6%95",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#1-ecs-클러스터-구축"
  },"528": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "2. Jenkins Pipeline 구축",
    "content": " ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#2-jenkins-pipeline-%EA%B5%AC%EC%B6%95",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#2-jenkins-pipeline-구축"
  },"529": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "3. ECR 구축",
    "content": " ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#3-ecr-%EA%B5%AC%EC%B6%95",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#3-ecr-구축"
  },"530": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "4. Jenkins 배포 테스트",
    "content": " ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline#4-jenkins-%EB%B0%B0%ED%8F%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline#4-jenkins-배포-테스트"
  },"531": {
    "doc": "Jenkins Pipeline - ECS",
    "title": "Jenkins Pipeline - ECS",
    "content": " ",
    "url": "/docs/03_Project/Project_2_ecs_pipeline",
    
    "relUrl": "/docs/03_Project/Project_2_ecs_pipeline"
  },"532": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "AWS Exporter Slack Application",
    "content": " ",
    "url": "/docs/03_Project/Project_3_aws_exporter#aws-exporter-slack-application",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter#aws-exporter-slack-application"
  },"533": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. AWS SAM을 통한 Lambda 관리 | 2. Python Lambda 구현 . | 2.1 Slack을 통한 람다 트리거 . | 2.1.1 Local Test Mode | 2.1.2 Local Test Mode main.py 코드 상세 설명 | 2.1.2 Slack Mode | . | 2.2 AWS Resource 조회 | 2.3 조회된 결과를 Excel 로 반환 | . | . ",
    "url": "/docs/03_Project/Project_3_aws_exporter#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter#목차"
  },"534": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "글을 쓴 배경",
    "content": "AWS 자원 정보를 Slack을 통해 편리하게 조회하고 조회된 결과를 excel로 변환하여 현재 리소스 파악을 용이하게 할 목적으로 제작되었습니다. ",
    "url": "/docs/03_Project/Project_3_aws_exporter#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter#글을-쓴-배경"
  },"535": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/03_Project/Project_3_aws_exporter#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter#글-요약"
  },"536": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "시작하기 전",
    "content": " ",
    "url": "/docs/03_Project/Project_3_aws_exporter#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter#시작하기-전"
  },"537": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "1. AWS SAM을 통한 Lambda 관리",
    "content": "AWS SAM은 AWS CloudFormation의 확장 프레임워크로, YAML 또는 JSON 템플릿을 사용하여 서버리스 애플리케이션을 정의할 수 있습니다. SAM을 사용하면 Lambda 함수의 버전 관리를 Git과 같은 형상 관리 도구로 수행할 수 있으며, 배포를 쉽게 자동화할 수 있습니다. 관련 문서 : AWS Serverless Application Model (AWS SAM) 란 무엇입니까? . 관련 문서 : AWS Lambda이란 무엇인가요? . ",
    "url": "/docs/03_Project/Project_3_aws_exporter#1-aws-sam%EC%9D%84-%ED%86%B5%ED%95%9C-lambda-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter#1-aws-sam을-통한-lambda-관리"
  },"538": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "2. Python Lambda 구현",
    "content": "Lambda 함수가 Slack을 통해 인수를 전달받아 AWS 리소스를 조회하고 그 결과를 Excel 파일로 반환하는 과정을 설명합니다. 2.1 Slack을 통한 람다 트리거 . 슬랙을 통해 커맨드를 직접 전달하여 운영 환경과 유사하게 Lambda 코드를 테스트할 수도 있지만, 로컬 환경에서 람다 함수를 수정하고 바로 테스트 할 수도 있습니다. 2.1.1 Local Test Mode . 람다 함수는 호출될 때 실행되는 함수가 필요합니다. 이는 lambda_handler와 같은 특정 이름으로 정의된 함수입니다. 해당 함수는 트리거 될 때 두 개의 매개변수를 받습니다. event 와 context 입니다. event 값이 트리거 리소스로 부터 전달된다면 Lambda 함수는 엔트리 포인트인 lambda_handler 함수를 호출합니다. main.py . import sys import argparse from lambda_function import lambda_handler event={ \"token\": \"\", \"team_id\": \"\", \"team_domain\": \"\", \"channel_id\": \"\", \"channel_name\": \"general\", \"user_id\": \"U03J0TE7CSY\", \"user_name\": \"kimkm95\", \"command\": \"/excel\", \"text\": \"\", \"api_app_id\": \"\", \"is_enterprise_install\": \"\", \"response_url\": \"\", \"trigger_id\": \"\", \"local_mode\": \"\" } if __name__ == '__main__': parser = argparse.ArgumentParser(description='AWS Resource Exporter.') parser.add_argument('vpc_name_tag', nargs=1, help='VPC Name tag ex) my-vpc') parser.add_argument('region', nargs=1, help='AWS Region code. ex) ap-northeast-2') parser.add_argument('access_key', nargs=1, help='AWS Access Key') parser.add_argument('secret_access_key', nargs=1, help='AWS Secret Access Key') parser.add_argument('session_token', nargs='?', help='AWS Session Token', default=None) args = parser.parse_args() if len(sys.argv) == 1: parser.print_usage() else: print('Console to xlsx started') if args.session_token: event[\"text\"] = f\"{args.vpc_name_tag[0]} {args.region[0]} {args.access_key[0]} {args.secret_access_key[0]} {args.session_token}\" else: event[\"text\"] = f\"{args.vpc_name_tag[0]} {args.region[0]} {args.access_key[0]} {args.secret_access_key[0]}\" lambda_handler(event, []) . 2.1.2 Local Test Mode main.py 코드 상세 설명 . aws lambda함수는 트리거되는 리소스에 의해 이벤트가 제공되고 이때 lambda 함수의 엔트리 포인트는?? . 로컬에서 Lambda 함수를 테스트 하려면 Lambda 서비스가 제공하는 이벤트를 직접 생성하고, lambda 함수의 엔트리 포인트를 직접 호출해야합니다. 2.1.2 Slack Mode . 2.2 AWS Resource 조회 . 2.3 조회된 결과를 Excel 로 반환 . ",
    "url": "/docs/03_Project/Project_3_aws_exporter#2-python-lambda-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter#2-python-lambda-구현"
  },"539": {
    "doc": "AWS Exporter Application 개발하기",
    "title": "AWS Exporter Application 개발하기",
    "content": " ",
    "url": "/docs/03_Project/Project_3_aws_exporter",
    
    "relUrl": "/docs/03_Project/Project_3_aws_exporter"
  },"540": {
    "doc": "React",
    "title": "ECS 용량공급자",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#ecs-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#ecs-용량공급자"
  },"541": {
    "doc": "React",
    "title": "목차",
    "content": ". | TOC | . # . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#목차"
  },"542": {
    "doc": "React",
    "title": "목차",
    "content": ". | TOC | . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#%EB%AA%A9%EC%B0%A8-1",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#목차-1"
  },"543": {
    "doc": "React",
    "title": "글을 쓴 배경",
    "content": "ECS 서비스를 이용해 sample application 도커 이미지를 배포하는 방법을 공유합니다. ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#글을-쓴-배경"
  },"544": {
    "doc": "React",
    "title": "글 요약",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#글-요약"
  },"545": {
    "doc": "React",
    "title": "시작하기 전",
    "content": "참고자료 AWS ECS Workshop . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#시작하기-전"
  },"546": {
    "doc": "React",
    "title": "1. 용량공급자란",
    "content": "Amazon Elastic Container Registry(ECR)에 ECS에서 실행되는 애플리케이션 이미지를 저장 및 관리할 수 있습니다. ECS TaskDefinition에 Amazon ECR 리포지토리를 지정하기만 하면 Amazon ECS에서 지정된 이미지를 가져와 배포합니다. 우선, 배포할 이미지를 업로드 해줍니다. 저는 nginx container 이미지를 업로드해주었습니다. 참고자료 : Amazon ECR . ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#1-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90%EB%9E%80",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#1-용량공급자란"
  },"547": {
    "doc": "React",
    "title": "2. AWS ECS Cluster 에서 용량공급자 선택하기",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react#2-aws-ecs-cluster-%EC%97%90%EC%84%9C-%EC%9A%A9%EB%9F%89%EA%B3%B5%EA%B8%89%EC%9E%90-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react#2-aws-ecs-cluster-에서-용량공급자-선택하기"
  },"548": {
    "doc": "React",
    "title": "React",
    "content": " ",
    "url": "/docs/01_Language/TypeScript/AwsCloudScape/react",
    
    "relUrl": "/docs/01_Language/TypeScript/AwsCloudScape/react"
  },"549": {
    "doc": "2. Cloud Watch Alarm",
    "title": "CodeDeploy ECS Blue/Green 배포시 Install 단계 Timeout 시간 제한 조정 방법 (Feat. CloudWatch Alarm)",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#codedeploy-ecs-bluegreen-%EB%B0%B0%ED%8F%AC%EC%8B%9C-install-%EB%8B%A8%EA%B3%84-timeout-%EC%8B%9C%EA%B0%84-%EC%A0%9C%ED%95%9C-%EC%A1%B0%EC%A0%95-%EB%B0%A9%EB%B2%95-feat-cloudwatch-alarm",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#codedeploy-ecs-bluegreen-배포시-install-단계-timeout-시간-제한-조정-방법-feat-cloudwatch-alarm"
  },"550": {
    "doc": "2. Cloud Watch Alarm",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#목차"
  },"551": {
    "doc": "2. Cloud Watch Alarm",
    "title": "글을 쓴 배경",
    "content": "AWS ECS로 Blue/Green 배포를 진행하던 중 신규 task set 배포 과정에서 문제가 발생할 경우 Code Deploy의 Install 단계에서 최대 60분 동안 재시도 후 자동으로 실패하고 롤백이 이루어집니다. 이러한 기본 설정으로 인해 발생하는 시간 지연을 최소화하기 위해, Install 단계의 타임아웃 시간을 조정할 수 있는 방법을 찾게 되었습니다. 관련 문서 : CodeDeploy ECS Blue/Green 배포 시 Install 단계 Timeout 시간 제한 조정 . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#글을-쓴-배경"
  },"552": {
    "doc": "2. Cloud Watch Alarm",
    "title": "글 요약",
    "content": "AWS ECS에서 Blue/Green 배포를 진행할 때, CodeDeploy의 Install 단계에서 발생할 수 있는 지연을 최소화하기 위해 Timeout 설정을 조정하는 방법을 설명합니다. 본문은 CloudWatch Alarm을 사용하여 이러한 문제를 탐지하고 자동으로 대응하는 과정을 다룹니다. ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#글-요약"
  },"553": {
    "doc": "2. Cloud Watch Alarm",
    "title": "시작하기 전",
    "content": ". | AWS ECS와 CodeDeploy의 기본 작동 원리 | Blue/Green 배포 전략에 대한 이해 | AWS CloudWatch의 기본적인 사용법과 메트릭 시스템 | . ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway#시작하기-전"
  },"554": {
    "doc": "2. Cloud Watch Alarm",
    "title": "2. Cloud Watch Alarm",
    "content": " ",
    "url": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway",
    
    "relUrl": "/docs/02_Tech/AWS/APIGateway/RESTAPIGateway"
  },"555": {
    "doc": "2. SAM",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech/CICD/SAM#color-utilities",
    
    "relUrl": "/docs/02_Tech/CICD/SAM#color-utilities"
  },"556": {
    "doc": "2. SAM",
    "title": "Table of contents",
    "content": ". 참고자료 : https://www.jenkins.io/blog/2021/05/20/configure-plugins-with-jcasc/ . ",
    "url": "/docs/02_Tech/CICD/SAM#table-of-contents",
    
    "relUrl": "/docs/02_Tech/CICD/SAM#table-of-contents"
  },"557": {
    "doc": "2. SAM",
    "title": "2. SAM",
    "content": " ",
    "url": "/docs/02_Tech/CICD/SAM",
    
    "relUrl": "/docs/02_Tech/CICD/SAM"
  },"558": {
    "doc": "Security6",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/01_languages/Java/Security6#color-utilities",
    
    "relUrl": "/docs/01_languages/Java/Security6#color-utilities"
  },"559": {
    "doc": "Security6",
    "title": "Table of contents",
    "content": ". | TOC | . ",
    "url": "/docs/01_languages/Java/Security6#table-of-contents",
    
    "relUrl": "/docs/01_languages/Java/Security6#table-of-contents"
  },"560": {
    "doc": "Security6",
    "title": "Security6",
    "content": " ",
    "url": "/docs/01_languages/Java/Security6",
    
    "relUrl": "/docs/01_languages/Java/Security6"
  },"561": {
    "doc": "Tech",
    "title": "Color Utilities",
    "content": " ",
    "url": "/docs/02_Tech#color-utilities",
    
    "relUrl": "/docs/02_Tech#color-utilities"
  },"562": {
    "doc": "Tech",
    "title": "Table of contents",
    "content": ". ",
    "url": "/docs/02_Tech#table-of-contents",
    
    "relUrl": "/docs/02_Tech#table-of-contents"
  },"563": {
    "doc": "Tech",
    "title": "Tech",
    "content": " ",
    "url": "/docs/02_Tech",
    
    "relUrl": "/docs/02_Tech"
  },"564": {
    "doc": "2. Terramate",
    "title": "Terramate",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Terramate#terramate",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#terramate"
  },"565": {
    "doc": "2. Terramate",
    "title": "목차",
    "content": ". | 글을 쓴 배경 | 글 요약 | 시작하기 전 | 1. Terramate 소개 | 2. Terramate Stack이란? | 3. Terramate Stack 생성하기 | 4. Terramate Orchestration . | 4.1 Terramate Orchestration 명령어 | 4.2 Terramate를 이용한 stack 실행 순서 사용자 지정 | 4.3 Terramate 중첩 스택 | 4.4 변경된 스택 감지 | 4.5 병렬 실행 | . | 5. GitHub Action 이용해서 Terramate를 이용한 배포 파이프라인 구성하기 . | 5.1 GitHub에 Terraform 코드 업로드 | 5.2 Terramate 설치 | 5.3 Github Action workflows 파일 상세 설명 | 5.3 Github Action 파이프라인 확인 | 5.4 Github Actions 통합의미 | . | . ",
    "url": "/docs/02_Tech/CICD/Terramate#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#목차"
  },"566": {
    "doc": "2. Terramate",
    "title": "글을 쓴 배경",
    "content": "표준화 부족, 레거시 기술의 복잡성, 높은 인지 부담, 비효율적인 수작업 등이 엔터프라이즈 환경의 문제점으로 지적되었습니다. 이를 해결하기 위해 개발자 플랫폼을 통해 표준화된 도구와 기술 스택을 제공하여 개발자 경험과 생산성을 향상시키는 것이 중요한 과제로 제시되었습니다. 이에 따라 IaC관리 플랫폼인 Terramate 사용법을 작성해보았습니다. 참고 연설 : Platform as Code: Simplifying developer platform design with reference architectures . ",
    "url": "/docs/02_Tech/CICD/Terramate#%EA%B8%80%EC%9D%84-%EC%93%B4-%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#글을-쓴-배경"
  },"567": {
    "doc": "2. Terramate",
    "title": "글 요약",
    "content": "이 글에서는 Terramate를 사용하여 Terraform 스택을 생성, 관리 및 오케스트레이션하는 방법을 다룹니다. 각 스택에 Terraform 구성을 추가하고, 변경 사항을 감지하여 효율적으로 스택을 관리하는 방법을 설명합니다. git action flow와 통합하여 자동화된 배포 파이프라인을 구성해봅니다. 기존 사용하고 있는 프로젝트 코드와 통합해 봅니다. ",
    "url": "/docs/02_Tech/CICD/Terramate#%EA%B8%80-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#글-요약"
  },"568": {
    "doc": "2. Terramate",
    "title": "시작하기 전",
    "content": "github action 기본 지식 필요 terramate version : 0.8.4 terraform version : v1.8.5 . ",
    "url": "/docs/02_Tech/CICD/Terramate#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#시작하기-전"
  },"569": {
    "doc": "2. Terramate",
    "title": "1. Terramate 소개",
    "content": "Terramate는 IaC 관리 플랫폼으로, 팀이 Terraform, OpenTofu, Terragrunt, Kubernetes 등과 같은 IaC 도구를 사용하여 클라우드 인프라를 구축, 배포, 관리 및 모니터링을 할 수 있도록 돕습니다. Terramate는 무료 오픈 소스 CLI를 제공하며, 이를 Terramate Cloud와 통합할 수도 있습니다. Terramate는 기존 아키텍처에 사전 요구 사항이나 기존 Terraform 구성을 수정할 필요 없이 단 한 번의 명령어로 온보딩할 수 있습니다. ",
    "url": "/docs/02_Tech/CICD/Terramate#1-terramate-%EC%86%8C%EA%B0%9C",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#1-terramate-소개"
  },"570": {
    "doc": "2. Terramate",
    "title": "2. Terramate Stack이란?",
    "content": "스택은 Terraform과 OpenTofu를 단위별로 관리할 수 있도록 합니다. 스택 별로 독립적인 배포 및 관리를 가능하게 하여 병렬 처리로 실행 시간을 줄이고 변경된 스택만 업데이트하여 전체 인프라에 영향을 최소화할 수 있습니다. 스택은 특정 서비스를 배포하는 데 필요한 리소스의 번들이며, 스택을 묶어서 다양한 환경에 배포할 수 있습니다. 스택의 구성요소는 다음과 같습니다: . | 인프라 코드: Terraform의 .tf 파일를 사용하여 인프라 리소스와 구성을 선언합니다. | 상태: terraform.tfstate 파일을 통해 배포된 현재 인프라 상태를 설명합니다. | 구성: stack.tm.hcl 을 통해 스택 동작 및 구성을 정의합니다. | . ",
    "url": "/docs/02_Tech/CICD/Terramate#2-terramate-stack%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#2-terramate-stack이란"
  },"571": {
    "doc": "2. Terramate",
    "title": "3. Terramate Stack 생성하기",
    "content": "참조 자료 : Create and orchestrate Terraform Stacks with Terramate . 새로운 저장소 생성 . git init -b main terramate-stacks cd terramate-stacks . 샘플 스택 생성 . | 스택을 생성하면 stack.tm.hcl 파일이 생성됩니다. 이 파일들은 해당 디렉토리를 Terramate 스택으로 식별하기 위한 식별자 역할을 합니다. | . terramate create --name \"Example Stack A\" --description \"This is an awesome first example stack\" stacks/a terramate create --name \"Example Stack B\" --description \"This is an awesome second example stack\" stacks/b terramate create --name \"Example Stack C\" --description \"This is an awesome third example stack\" stacks/c . 명령어를 실행 한 후 stack.tm.hcl 샘플 파일 확인 . stack { name = \"Example Stack A\" description = \"This is an awesome first example stack\" id = \"e834b046-980e-47ce-9118-1bf56034aa73\" } . 스택 메타데이터 확인 . | 메타 데이터 확인 명령어 : terramate debug show metadata | . project metadata: terramate.stacks.list=[/stacks/a /stacks/b /stacks/c] stack \"/stacks/a\": terramate.stack.id=\"e834b046-980e-47ce-9118-1bf56034aa73\" terramate.stack.name=\"Example Stack A\" terramate.stack.description=\"This is an awesome first example stack\" terramate.stack.tags=[] terramate.stack.path.absolute=\"/stacks/a\" terramate.stack.path.basename=\"a\" terramate.stack.path.relative=\"stacks/a\" terramate.stack.path.to_root=\"../..\" . ",
    "url": "/docs/02_Tech/CICD/Terramate#3-terramate-stack-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#3-terramate-stack-생성하기"
  },"572": {
    "doc": "2. Terramate",
    "title": "4. Terramate Orchestration",
    "content": "현재 생성된 각 스택 디렉토리에 main.tf를 생성하고 terramate를 통해 테라폼 오케스트레이션 테스트를 진행합니다. 아래는 테스트용 terraform code를 stack 에 넣는 예시 명령어 입니다. null_resource를 사용하여 테스트를 실행해도 별다른 배포가 이루어지지 않습니다. echo 'resource \"null_resource\" \"stack\" {}' | tee stacks/a/main.tf stacks/b/main.tf stacks/c/main.tf &gt; /dev/null . 4.1 Terramate Orchestration 명령어 . | terramate를 이용해서 terraform 코드를 아래와 같이 배포할 수 있습니다. | . terramate run terraform init . terramate run terraform apply . 4.2 Terramate를 이용한 stack 실행 순서 사용자 지정 . 스택별 기본 실행 순서를 명시적으로 변경할 수 있습니다. Terramate의 before-and-after 구성을 사용하여 스택의 오케스트레이션 동작을 구성할 수 있습니다. 실행 순서 적용전 a 배포 후 b 배포 실행 . ❯ terramate run terraform apply terramate: Entering stack in /stacks/a terramate: Executing command \"terraform apply\" ... null_resource.stack: Creating... null_resource.stack: Creation complete after 0s [id=8860708672716908454] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. terramate: Entering stack in /stacks/b terramate: Executing command \"terraform apply\" ... null_resource.stack: Creating... null_resource.stack: Creation complete after 0s [id=7369955017342757335] . 실행 순서 적용 후 . | stack/a/stack.tm.hcl 파일을 다음과 같이 수정합니다 | . stack { name = \"Example Stack A\" description = \"This is an awesome first example stack\" id = \"e834b046-980e-47ce-9118-1bf56034aa73\" after = [ \"../b\" ] } . 결과 화면 . | 실행 순서가 b -&gt; a로 변한 것을 확인할 수 있습니다. | . terramate: Entering stack in /stacks/b terramate: Executing command \"terraform apply\" ... null_resource.stack: Creating... null_resource.stack: Creation complete after 0s [id=4049987914117276811] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. terramate: Entering stack in /stacks/a terramate: Executing command \"terraform apply\" ... null_resource.stack: Creating... null_resource.stack: Creation complete after 0s [id=1256199023530115670] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. 4.3 Terramate 중첩 스택 . Terramate 스택은 중첩될 수 있어, 인프라 코드를 트리 형태로 구성할 수 있습니다. 마찬가지로 중첩된 스택에서도 명시적 스택 순서를 적용할 수 있습니다. 4.4 변경된 스택 감지 . Terramate는 Git 레포지토리 변경 사항을 기반으로 변경된 스택을 감지하여 감지된 스택만 배포할 수 있습니다. changed 옵션을 통해 변경이 일어난 스택을 감지하고 해당 스택만 배포할 수 있습니다. 4.5 병렬 실행 . Terramate는 병렬 실행을 지원하여 여러 스택에서 명령어를 병렬적으로 실행할 수 있습니다. 명령어 : terramate run --parallel=3 terraform apply -auto-approve . ",
    "url": "/docs/02_Tech/CICD/Terramate#4-terramate-orchestration",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#4-terramate-orchestration"
  },"573": {
    "doc": "2. Terramate",
    "title": "5. GitHub Action 이용해서 Terramate를 이용한 배포 파이프라인 구성하기",
    "content": "참조 코드 : terramate-quickstart-aws . 참조 문서 : Introducing the Terramate GitHub Action . Terramate를 GitHub Actions 워크플로우에 통합하는 것이 GitHub Marketplace의 Terramate Action 도입으로 더욱 쉬워졌습니다. 이제 수동 설치의 번거로움은 잊고 효율적인 인프라 관리를 시작하세요. 5.1 GitHub에 Terraform 코드 업로드 . Terraform 코드를 GitHub 레포지토리에 업로드 하여 GitHub에서 제공하는 workflow를 이용하여 terramate를 관리할 것입니다. 5.2 Terramate 설치 . GitHub Actions를 사용하여 Terramate CLI를 자동으로 설치 할 수 있습니다. 이를 위해 .github/workflows 디렉토리에 워크플로우 파일을 생성합니다. 참고자료 : https://medium.com/terramate .github/workflows/terramate-setup.yml . name: Terramate Action Tests on: push: branches: - main pull_request: defaults: run: shell: bash jobs: simple: name: Terramate latest runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Install latest Terramate uses: ./ - name: Validate execution run: terramate version asdf: name: Terramate asdf runs-on: ubuntu-latest strategy: matrix: version: [0.4.2, 0.4.3, skip] steps: - name: Checkout uses: actions/checkout@v4 - name: Prepare asdf config if: $ run: echo \"terramate $\" &gt;.tool-versions - name: Prepare empty asdf config if: $ run: echo &gt;.tool-versions - name: Install asdf Terramate uses: ./ - name: Validate execution run: terramate version - name: Validate version - $ id: version if: $ run: terramate version | grep $ - name: Validate outputs - $ if: $ run: echo \"$\" | grep $ wrapper: name: Terramate with wrapper runs-on: ubuntu-latest strategy: matrix: version: [0.4.3, latest] steps: - name: Checkout uses: actions/checkout@v4 - name: Install Terramate Wrapper - $ uses: ./ with: version: $ - name: Validate execution - $ run: terramate version - name: Validate version - $ id: version if: $ run: terramate version | grep $ - name: Validate outputs - $ if: $ run: echo \"$\" | grep $ . 5.3 Github Action workflows 파일 상세 설명 . 위 workflows 파일에서는 terramate를 설치하는 다양한 방법들을 jobs 별로 정의해두었습니다. Job 1: simple . | Install latest Terramate: 최신 버전의 Terramate를 설치합니다. | Validate execution: Terramate가 올바르게 설치되었는지 버전을 확인합니다. | . Job 2: asdf . asdf는 버전 관리 도구입니다. 이 도구는 .tool-versions 파일을 통해 원하는 버전을 지정하고 필요에 따라 해당 버전을 설치하고 사용하게 합니다. | Install asdf Terramate: asdf를 사용하여 Terramate를 설치합니다. | Validate execution: Terramate가 올바르게 설치되었는지 버전을 확인합니다. | Validate version: 특정 버전이 올바르게 설치되었는지 검증합니다. | Validate outputs: 설치된 버전의 출력 결과를 검증합니다. | . Job 3: wrapper . wrapper는 Terramate 명령어를 감싸는 스크립트로, GitHub Actions 실행 환경에서 Terramate 명령어의 실행 결과를 후속 작업에서 사용할 수 있도록 도와줍니다. | Install Terramate Wrapper: 지정된 버전의 Terramate를 설치하고 래퍼 스크립트를 사용합니다. | Validate execution: Terramate가 올바르게 설치되었는지 버전을 확인합니다. | Validate version: 특정 버전이 올바르게 설치되었는지 검증합니다. | Validate outputs: 설치된 버전의 출력 결과를 검증합니다. | . 5.3 Github Action 파이프라인 확인 . GitHub Actions을 통해 Terramate가 잘 배포되었는지 확인합니다. 각 단계별로 Terramate 버전과 실행 결과를 검증합니다. 5.4 Github Actions 통합의미 . Terramate GitHub Action을 활용하면 일관된 환경을 유지 할 수 있으며 코드 변경이 있을 때마다 자동으로 테스트되고 배포될 수 있습니다. 여러 명의 팀과 함께 협업할때 stack관리측면에서 유용합니다. ",
    "url": "/docs/02_Tech/CICD/Terramate#5-github-action-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-terramate%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B0%B0%ED%8F%AC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate#5-github-action-이용해서-terramate를-이용한-배포-파이프라인-구성하기"
  },"574": {
    "doc": "2. Terramate",
    "title": "2. Terramate",
    "content": " ",
    "url": "/docs/02_Tech/CICD/Terramate",
    
    "relUrl": "/docs/02_Tech/CICD/Terramate"
  },"575": {
    "doc": "TypeScript",
    "title": "TypeScript",
    "content": " ",
    "url": "/docs/01_languages/TypeScript",
    
    "relUrl": "/docs/01_languages/TypeScript"
  },"576": {
    "doc": "TypeScript",
    "title": "목차",
    "content": ". ",
    "url": "/docs/01_languages/TypeScript#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/01_languages/TypeScript#목차"
  }
}
